import * as e from "../common/common.js";
import * as t from "../platform/platform.js";
import { assertNotNullOrUndefined as n } from "../platform/platform.js";
import * as r from "../../models/cpu_profile/cpu_profile.js";
import * as s from "../../models/text_utils/text_utils.js";
import * as i from "../i18n/i18n.js";
import * as a from "../root/root.js";
import * as o from "../host/host.js";
import * as l from "../protocol_client/protocol_client.js";
const d = new Map();
class c extends e.ObjectWrapper.ObjectWrapper {
	#e;
	constructor(e) {
		(super(), (this.#e = e));
	}
	target() {
		return this.#e;
	}
	async preSuspendModel(e) {}
	async suspendModel(e) {}
	async resumeModel() {}
	async postResumeModel() {}
	dispose() {}
	static register(e, t) {
		if (t.early && !t.autostart)
			throw new Error(
				`Error registering model ${e.name}: early models must be autostarted.`
			);
		d.set(e, t);
	}
	static get registeredModels() {
		return d;
	}
}
var h = Object.freeze({ __proto__: null, SDKModel: c });
const u = [
		{
			longhands: ["animation-delay-start", "animation-delay-end"],
			name: "-alternative-animation-delay",
		},
		{
			longhands: [
				"animation-duration",
				"animation-timing-function",
				"animation-delay-start",
				"animation-delay-end",
				"animation-iteration-count",
				"animation-direction",
				"animation-fill-mode",
				"animation-play-state",
				"animation-name",
				"animation-timeline",
				"animation-range-start",
				"animation-range-end",
			],
			name: "-alternative-animation-with-delay-start-end",
		},
		{
			longhands: [
				"animation-duration",
				"animation-timing-function",
				"animation-delay",
				"animation-iteration-count",
				"animation-direction",
				"animation-fill-mode",
				"animation-play-state",
				"animation-name",
				"animation-timeline",
				"animation-range-start",
				"animation-range-end",
			],
			name: "-alternative-animation-with-timeline",
		},
		{
			longhands: [
				"mask-image",
				"-webkit-mask-position-x",
				"-webkit-mask-position-y",
				"mask-size",
				"mask-repeat",
				"mask-origin",
				"mask-clip",
				"mask-composite",
				"mask-mode",
			],
			name: "-alternative-mask",
		},
		{
			longhands: [
				"view-timeline-name",
				"view-timeline-axis",
				"view-timeline-inset",
			],
			name: "-alternative-view-timeline-with-inset",
		},
		{ inherited: !0, name: "-webkit-border-horizontal-spacing" },
		{ name: "-webkit-border-image" },
		{ inherited: !0, name: "-webkit-border-vertical-spacing" },
		{
			keywords: ["stretch", "start", "center", "end", "baseline"],
			name: "-webkit-box-align",
		},
		{ keywords: ["slice", "clone"], name: "-webkit-box-decoration-break" },
		{ keywords: ["normal", "reverse"], name: "-webkit-box-direction" },
		{ name: "-webkit-box-flex" },
		{ name: "-webkit-box-ordinal-group" },
		{ keywords: ["horizontal", "vertical"], name: "-webkit-box-orient" },
		{
			keywords: ["start", "center", "end", "justify"],
			name: "-webkit-box-pack",
		},
		{ name: "-webkit-box-reflect" },
		{ longhands: ["break-after"], name: "-webkit-column-break-after" },
		{ longhands: ["break-before"], name: "-webkit-column-break-before" },
		{ longhands: ["break-inside"], name: "-webkit-column-break-inside" },
		{ inherited: !0, name: "-webkit-font-smoothing" },
		{
			inherited: !0,
			keywords: [
				"auto",
				"loose",
				"normal",
				"strict",
				"after-white-space",
				"anywhere",
			],
			name: "-webkit-line-break",
		},
		{ name: "-webkit-line-clamp" },
		{ inherited: !0, name: "-webkit-locale" },
		{
			longhands: [
				"-webkit-mask-image",
				"-webkit-mask-position-x",
				"-webkit-mask-position-y",
				"-webkit-mask-size",
				"-webkit-mask-repeat",
				"-webkit-mask-origin",
				"-webkit-mask-clip",
			],
			name: "-webkit-mask",
		},
		{
			longhands: [
				"-webkit-mask-box-image-source",
				"-webkit-mask-box-image-slice",
				"-webkit-mask-box-image-width",
				"-webkit-mask-box-image-outset",
				"-webkit-mask-box-image-repeat",
			],
			name: "-webkit-mask-box-image",
		},
		{ name: "-webkit-mask-box-image-outset" },
		{ name: "-webkit-mask-box-image-repeat" },
		{ name: "-webkit-mask-box-image-slice" },
		{ name: "-webkit-mask-box-image-source" },
		{ name: "-webkit-mask-box-image-width" },
		{ name: "-webkit-mask-clip" },
		{ name: "-webkit-mask-composite" },
		{ name: "-webkit-mask-image" },
		{ name: "-webkit-mask-origin" },
		{
			longhands: ["-webkit-mask-position-x", "-webkit-mask-position-y"],
			name: "-webkit-mask-position",
		},
		{ name: "-webkit-mask-position-x" },
		{ name: "-webkit-mask-position-y" },
		{ name: "-webkit-mask-repeat" },
		{ name: "-webkit-mask-size" },
		{ name: "-webkit-perspective-origin-x" },
		{ name: "-webkit-perspective-origin-y" },
		{
			inherited: !0,
			keywords: ["economy", "exact"],
			name: "-webkit-print-color-adjust",
		},
		{
			inherited: !0,
			keywords: ["logical", "visual"],
			name: "-webkit-rtl-ordering",
		},
		{
			inherited: !0,
			keywords: ["before", "after"],
			name: "-webkit-ruby-position",
		},
		{ inherited: !0, name: "-webkit-tap-highlight-color" },
		{ inherited: !0, name: "-webkit-text-combine" },
		{ inherited: !0, name: "-webkit-text-decorations-in-effect" },
		{ inherited: !0, name: "-webkit-text-fill-color" },
		{ inherited: !0, name: "-webkit-text-orientation" },
		{
			inherited: !0,
			keywords: ["none", "disc", "circle", "square"],
			name: "-webkit-text-security",
		},
		{
			inherited: !0,
			longhands: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
			name: "-webkit-text-stroke",
		},
		{ inherited: !0, name: "-webkit-text-stroke-color" },
		{ inherited: !0, name: "-webkit-text-stroke-width" },
		{ name: "-webkit-transform-origin-x" },
		{ name: "-webkit-transform-origin-y" },
		{ name: "-webkit-transform-origin-z" },
		{ keywords: ["auto", "none", "element"], name: "-webkit-user-drag" },
		{
			inherited: !0,
			keywords: ["read-only", "read-write", "read-write-plaintext-only"],
			name: "-webkit-user-modify",
		},
		{ inherited: !0, name: "-webkit-writing-mode" },
		{ inherited: !0, keywords: ["auto", "currentcolor"], name: "accent-color" },
		{ name: "additive-symbols" },
		{ name: "align-content" },
		{ name: "align-items" },
		{ name: "align-self" },
		{
			keywords: [
				"auto",
				"baseline",
				"alphabetic",
				"ideographic",
				"middle",
				"central",
				"mathematical",
				"before-edge",
				"text-before-edge",
				"after-edge",
				"text-after-edge",
				"hanging",
			],
			name: "alignment-baseline",
		},
		{ name: "all" },
		{ keywords: ["none"], name: "anchor-default" },
		{ keywords: ["none"], name: "anchor-name" },
		{
			longhands: [
				"animation-duration",
				"animation-timing-function",
				"animation-delay",
				"animation-iteration-count",
				"animation-direction",
				"animation-fill-mode",
				"animation-play-state",
				"animation-name",
			],
			name: "animation",
		},
		{
			keywords: ["replace", "add", "accumulate"],
			name: "animation-composition",
		},
		{ name: "animation-delay" },
		{ name: "animation-delay-end" },
		{ name: "animation-delay-start" },
		{
			keywords: ["normal", "reverse", "alternate", "alternate-reverse"],
			name: "animation-direction",
		},
		{ name: "animation-duration" },
		{
			keywords: ["none", "forwards", "backwards", "both"],
			name: "animation-fill-mode",
		},
		{ keywords: ["infinite"], name: "animation-iteration-count" },
		{ keywords: ["none"], name: "animation-name" },
		{ keywords: ["running", "paused"], name: "animation-play-state" },
		{
			longhands: ["animation-range-start", "animation-range-end"],
			name: "animation-range",
		},
		{ name: "animation-range-end" },
		{ name: "animation-range-start" },
		{ keywords: ["none", "auto"], name: "animation-timeline" },
		{
			keywords: [
				"linear",
				"ease",
				"ease-in",
				"ease-out",
				"ease-in-out",
				"jump-both",
				"jump-end",
				"jump-none",
				"jump-start",
				"step-start",
				"step-end",
			],
			name: "animation-timing-function",
		},
		{ keywords: ["none", "drag", "no-drag"], name: "app-region" },
		{ name: "appearance" },
		{ name: "ascent-override" },
		{ keywords: ["auto"], name: "aspect-ratio" },
		{ keywords: ["none"], name: "backdrop-filter" },
		{ keywords: ["visible", "hidden"], name: "backface-visibility" },
		{
			longhands: [
				"background-image",
				"background-position-x",
				"background-position-y",
				"background-size",
				"background-repeat",
				"background-attachment",
				"background-origin",
				"background-clip",
				"background-color",
			],
			name: "background",
		},
		{ keywords: ["scroll", "fixed", "local"], name: "background-attachment" },
		{
			keywords: [
				"normal",
				"multiply",
				"screen",
				"overlay",
				"darken",
				"lighten",
				"color-dodge",
				"color-burn",
				"hard-light",
				"soft-light",
				"difference",
				"exclusion",
				"hue",
				"saturation",
				"color",
				"luminosity",
			],
			name: "background-blend-mode",
		},
		{
			keywords: ["border-box", "padding-box", "content-box", "text"],
			name: "background-clip",
		},
		{ keywords: ["currentcolor"], name: "background-color" },
		{ keywords: ["auto", "none"], name: "background-image" },
		{
			keywords: ["border-box", "padding-box", "content-box"],
			name: "background-origin",
		},
		{
			longhands: ["background-position-x", "background-position-y"],
			name: "background-position",
		},
		{ name: "background-position-x" },
		{ name: "background-position-y" },
		{ name: "background-repeat" },
		{ keywords: ["auto", "cover", "contain"], name: "background-size" },
		{ name: "base-palette" },
		{ keywords: ["baseline", "sub", "super"], name: "baseline-shift" },
		{ keywords: ["auto", "first", "last"], name: "baseline-source" },
		{ keywords: ["auto"], name: "block-size" },
		{
			longhands: [
				"border-top-color",
				"border-top-style",
				"border-top-width",
				"border-right-color",
				"border-right-style",
				"border-right-width",
				"border-bottom-color",
				"border-bottom-style",
				"border-bottom-width",
				"border-left-color",
				"border-left-style",
				"border-left-width",
				"border-image-source",
				"border-image-slice",
				"border-image-width",
				"border-image-outset",
				"border-image-repeat",
			],
			name: "border",
		},
		{
			longhands: [
				"border-block-start-color",
				"border-block-start-style",
				"border-block-start-width",
				"border-block-end-color",
				"border-block-end-style",
				"border-block-end-width",
			],
			name: "border-block",
		},
		{
			longhands: ["border-block-start-color", "border-block-end-color"],
			name: "border-block-color",
		},
		{
			longhands: [
				"border-block-end-width",
				"border-block-end-style",
				"border-block-end-color",
			],
			name: "border-block-end",
		},
		{ name: "border-block-end-color" },
		{ name: "border-block-end-style" },
		{ name: "border-block-end-width" },
		{
			longhands: [
				"border-block-start-width",
				"border-block-start-style",
				"border-block-start-color",
			],
			name: "border-block-start",
		},
		{ name: "border-block-start-color" },
		{ name: "border-block-start-style" },
		{ name: "border-block-start-width" },
		{
			longhands: ["border-block-start-style", "border-block-end-style"],
			name: "border-block-style",
		},
		{
			longhands: ["border-block-start-width", "border-block-end-width"],
			name: "border-block-width",
		},
		{
			longhands: [
				"border-bottom-width",
				"border-bottom-style",
				"border-bottom-color",
			],
			name: "border-bottom",
		},
		{ keywords: ["currentcolor"], name: "border-bottom-color" },
		{ name: "border-bottom-left-radius" },
		{ name: "border-bottom-right-radius" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "border-bottom-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "border-bottom-width" },
		{
			inherited: !0,
			keywords: ["separate", "collapse"],
			name: "border-collapse",
		},
		{
			longhands: [
				"border-top-color",
				"border-right-color",
				"border-bottom-color",
				"border-left-color",
			],
			name: "border-color",
		},
		{ name: "border-end-end-radius" },
		{ name: "border-end-start-radius" },
		{
			longhands: [
				"border-image-source",
				"border-image-slice",
				"border-image-width",
				"border-image-outset",
				"border-image-repeat",
			],
			name: "border-image",
		},
		{ name: "border-image-outset" },
		{
			keywords: ["stretch", "repeat", "round", "space"],
			name: "border-image-repeat",
		},
		{ name: "border-image-slice" },
		{ keywords: ["none"], name: "border-image-source" },
		{ keywords: ["auto"], name: "border-image-width" },
		{
			longhands: [
				"border-inline-start-color",
				"border-inline-start-style",
				"border-inline-start-width",
				"border-inline-end-color",
				"border-inline-end-style",
				"border-inline-end-width",
			],
			name: "border-inline",
		},
		{
			longhands: ["border-inline-start-color", "border-inline-end-color"],
			name: "border-inline-color",
		},
		{
			longhands: [
				"border-inline-end-width",
				"border-inline-end-style",
				"border-inline-end-color",
			],
			name: "border-inline-end",
		},
		{ name: "border-inline-end-color" },
		{ name: "border-inline-end-style" },
		{ name: "border-inline-end-width" },
		{
			longhands: [
				"border-inline-start-width",
				"border-inline-start-style",
				"border-inline-start-color",
			],
			name: "border-inline-start",
		},
		{ name: "border-inline-start-color" },
		{ name: "border-inline-start-style" },
		{ name: "border-inline-start-width" },
		{
			longhands: ["border-inline-start-style", "border-inline-end-style"],
			name: "border-inline-style",
		},
		{
			longhands: ["border-inline-start-width", "border-inline-end-width"],
			name: "border-inline-width",
		},
		{
			longhands: [
				"border-left-width",
				"border-left-style",
				"border-left-color",
			],
			name: "border-left",
		},
		{ keywords: ["currentcolor"], name: "border-left-color" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "border-left-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "border-left-width" },
		{
			longhands: [
				"border-top-left-radius",
				"border-top-right-radius",
				"border-bottom-right-radius",
				"border-bottom-left-radius",
			],
			name: "border-radius",
		},
		{
			longhands: [
				"border-right-width",
				"border-right-style",
				"border-right-color",
			],
			name: "border-right",
		},
		{ keywords: ["currentcolor"], name: "border-right-color" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "border-right-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "border-right-width" },
		{
			inherited: !0,
			longhands: [
				"-webkit-border-horizontal-spacing",
				"-webkit-border-vertical-spacing",
			],
			name: "border-spacing",
		},
		{ name: "border-start-end-radius" },
		{ name: "border-start-start-radius" },
		{
			keywords: ["none"],
			longhands: [
				"border-top-style",
				"border-right-style",
				"border-bottom-style",
				"border-left-style",
			],
			name: "border-style",
		},
		{
			longhands: ["border-top-width", "border-top-style", "border-top-color"],
			name: "border-top",
		},
		{ keywords: ["currentcolor"], name: "border-top-color" },
		{ name: "border-top-left-radius" },
		{ name: "border-top-right-radius" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "border-top-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "border-top-width" },
		{
			longhands: [
				"border-top-width",
				"border-right-width",
				"border-bottom-width",
				"border-left-width",
			],
			name: "border-width",
		},
		{ keywords: ["auto"], name: "bottom" },
		{ keywords: ["none"], name: "box-shadow" },
		{ keywords: ["content-box", "border-box"], name: "box-sizing" },
		{
			keywords: [
				"auto",
				"avoid",
				"avoid-column",
				"avoid-page",
				"column",
				"left",
				"page",
				"recto",
				"right",
				"verso",
			],
			name: "break-after",
		},
		{
			keywords: [
				"auto",
				"avoid",
				"avoid-column",
				"avoid-page",
				"column",
				"left",
				"page",
				"recto",
				"right",
				"verso",
			],
			name: "break-before",
		},
		{
			keywords: ["auto", "avoid", "avoid-column", "avoid-page"],
			name: "break-inside",
		},
		{ keywords: ["auto", "dynamic", "static"], name: "buffered-rendering" },
		{ inherited: !0, keywords: ["top", "bottom"], name: "caption-side" },
		{ inherited: !0, keywords: ["auto", "currentcolor"], name: "caret-color" },
		{
			keywords: ["none", "left", "right", "both", "inline-start", "inline-end"],
			name: "clear",
		},
		{ keywords: ["auto"], name: "clip" },
		{
			keywords: [
				"border-box",
				"padding-box",
				"content-box",
				"margin-box",
				"fill-box",
				"stroke-box",
				"view-box",
				"none",
			],
			name: "clip-path",
		},
		{ inherited: !0, keywords: ["nonzero", "evenodd"], name: "clip-rule" },
		{ inherited: !0, keywords: ["currentcolor"], name: "color" },
		{
			inherited: !0,
			keywords: ["auto", "srgb", "linearrgb"],
			name: "color-interpolation",
		},
		{
			inherited: !0,
			keywords: ["auto", "srgb", "linearrgb"],
			name: "color-interpolation-filters",
		},
		{
			inherited: !0,
			keywords: ["auto", "optimizespeed", "optimizequality"],
			name: "color-rendering",
		},
		{ inherited: !0, name: "color-scheme" },
		{ keywords: ["auto"], name: "column-count" },
		{ keywords: ["balance", "auto"], name: "column-fill" },
		{ keywords: ["normal"], name: "column-gap" },
		{
			longhands: [
				"column-rule-width",
				"column-rule-style",
				"column-rule-color",
			],
			name: "column-rule",
		},
		{ keywords: ["currentcolor"], name: "column-rule-color" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "column-rule-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "column-rule-width" },
		{ keywords: ["none", "all"], name: "column-span" },
		{ keywords: ["auto"], name: "column-width" },
		{ longhands: ["column-width", "column-count"], name: "columns" },
		{
			keywords: [
				"none",
				"strict",
				"content",
				"size",
				"layout",
				"style",
				"paint",
				"inline-size",
				"block-size",
			],
			name: "contain",
		},
		{ name: "contain-intrinsic-block-size" },
		{ keywords: ["none"], name: "contain-intrinsic-height" },
		{ name: "contain-intrinsic-inline-size" },
		{
			longhands: ["contain-intrinsic-width", "contain-intrinsic-height"],
			name: "contain-intrinsic-size",
		},
		{ keywords: ["none"], name: "contain-intrinsic-width" },
		{ longhands: ["container-name", "container-type"], name: "container" },
		{ keywords: ["none"], name: "container-name" },
		{
			keywords: ["normal", "inline-size", "size", "scroll-state"],
			name: "container-type",
		},
		{ name: "content" },
		{ keywords: ["visible", "auto", "hidden"], name: "content-visibility" },
		{ keywords: ["none"], name: "counter-increment" },
		{ keywords: ["none"], name: "counter-reset" },
		{ keywords: ["none"], name: "counter-set" },
		{
			inherited: !0,
			keywords: [
				"auto",
				"default",
				"none",
				"context-menu",
				"help",
				"pointer",
				"progress",
				"wait",
				"cell",
				"crosshair",
				"text",
				"vertical-text",
				"alias",
				"copy",
				"move",
				"no-drop",
				"not-allowed",
				"e-resize",
				"n-resize",
				"ne-resize",
				"nw-resize",
				"s-resize",
				"se-resize",
				"sw-resize",
				"w-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"col-resize",
				"row-resize",
				"all-scroll",
				"zoom-in",
				"zoom-out",
				"grab",
				"grabbing",
			],
			name: "cursor",
		},
		{ name: "cx" },
		{ name: "cy" },
		{ keywords: ["none"], name: "d" },
		{ name: "descent-override" },
		{ inherited: !0, keywords: ["ltr", "rtl"], name: "direction" },
		{
			keywords: [
				"inline",
				"block",
				"list-item",
				"inline-block",
				"table",
				"inline-table",
				"table-row-group",
				"table-header-group",
				"table-footer-group",
				"table-row",
				"table-column-group",
				"table-column",
				"table-cell",
				"table-caption",
				"-webkit-box",
				"-webkit-inline-box",
				"flex",
				"inline-flex",
				"grid",
				"inline-grid",
				"contents",
				"flow-root",
				"none",
				"flow",
				"math",
				"ruby",
				"ruby-text",
			],
			name: "display",
		},
		{
			inherited: !0,
			keywords: [
				"auto",
				"alphabetic",
				"ideographic",
				"middle",
				"central",
				"mathematical",
				"hanging",
				"use-script",
				"no-change",
				"reset-size",
				"text-after-edge",
				"text-before-edge",
			],
			name: "dominant-baseline",
		},
		{
			inherited: !0,
			keywords: ["standard", "high", "constrained-high"],
			name: "dynamic-range-limit",
		},
		{ inherited: !0, keywords: ["show", "hide"], name: "empty-cells" },
		{ name: "fallback" },
		{ keywords: ["fixed", "content"], name: "field-sizing" },
		{ inherited: !0, name: "fill" },
		{ inherited: !0, name: "fill-opacity" },
		{ inherited: !0, keywords: ["nonzero", "evenodd"], name: "fill-rule" },
		{ keywords: ["none"], name: "filter" },
		{ longhands: ["flex-grow", "flex-shrink", "flex-basis"], name: "flex" },
		{
			keywords: [
				"auto",
				"fit-content",
				"min-content",
				"max-content",
				"content",
			],
			name: "flex-basis",
		},
		{
			keywords: ["row", "row-reverse", "column", "column-reverse"],
			name: "flex-direction",
		},
		{ longhands: ["flex-direction", "flex-wrap"], name: "flex-flow" },
		{ name: "flex-grow" },
		{ name: "flex-shrink" },
		{ keywords: ["nowrap", "wrap", "wrap-reverse"], name: "flex-wrap" },
		{
			keywords: ["none", "left", "right", "inline-start", "inline-end"],
			name: "float",
		},
		{ keywords: ["currentcolor"], name: "flood-color" },
		{ name: "flood-opacity" },
		{
			inherited: !0,
			longhands: [
				"font-style",
				"font-variant-ligatures",
				"font-variant-caps",
				"font-variant-numeric",
				"font-variant-east-asian",
				"font-variant-alternates",
				"font-variant-position",
				"font-weight",
				"font-stretch",
				"font-size",
				"line-height",
				"font-family",
				"font-optical-sizing",
				"font-size-adjust",
				"font-kerning",
				"font-feature-settings",
				"font-variation-settings",
			],
			name: "font",
		},
		{ name: "font-display" },
		{ inherited: !0, name: "font-family" },
		{ inherited: !0, keywords: ["normal"], name: "font-feature-settings" },
		{
			inherited: !0,
			keywords: ["auto", "normal", "none"],
			name: "font-kerning",
		},
		{ inherited: !0, keywords: ["auto", "none"], name: "font-optical-sizing" },
		{
			inherited: !0,
			keywords: ["normal", "light", "dark"],
			name: "font-palette",
		},
		{
			inherited: !0,
			keywords: [
				"xx-small",
				"x-small",
				"small",
				"medium",
				"large",
				"x-large",
				"xx-large",
				"xxx-large",
				"larger",
				"smaller",
				"-webkit-xxx-large",
			],
			name: "font-size",
		},
		{
			inherited: !0,
			keywords: [
				"none",
				"ex-height",
				"cap-height",
				"ch-width",
				"ic-width",
				"from-font",
			],
			name: "font-size-adjust",
		},
		{
			inherited: !0,
			keywords: [
				"normal",
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
			],
			name: "font-stretch",
		},
		{
			inherited: !0,
			keywords: ["normal", "italic", "oblique"],
			name: "font-style",
		},
		{
			inherited: !0,
			longhands: [
				"font-synthesis-weight",
				"font-synthesis-style",
				"font-synthesis-small-caps",
			],
			name: "font-synthesis",
		},
		{
			inherited: !0,
			keywords: ["auto", "none"],
			name: "font-synthesis-small-caps",
		},
		{ inherited: !0, keywords: ["auto", "none"], name: "font-synthesis-style" },
		{
			inherited: !0,
			keywords: ["auto", "none"],
			name: "font-synthesis-weight",
		},
		{
			inherited: !0,
			longhands: [
				"font-variant-ligatures",
				"font-variant-caps",
				"font-variant-alternates",
				"font-variant-numeric",
				"font-variant-east-asian",
				"font-variant-position",
			],
			name: "font-variant",
		},
		{ inherited: !0, keywords: ["normal"], name: "font-variant-alternates" },
		{
			inherited: !0,
			keywords: [
				"normal",
				"small-caps",
				"all-small-caps",
				"petite-caps",
				"all-petite-caps",
				"unicase",
				"titling-caps",
			],
			name: "font-variant-caps",
		},
		{
			inherited: !0,
			keywords: [
				"normal",
				"jis78",
				"jis83",
				"jis90",
				"jis04",
				"simplified",
				"traditional",
				"full-width",
				"proportional-width",
				"ruby",
			],
			name: "font-variant-east-asian",
		},
		{
			inherited: !0,
			keywords: [
				"normal",
				"none",
				"common-ligatures",
				"no-common-ligatures",
				"discretionary-ligatures",
				"no-discretionary-ligatures",
				"historical-ligatures",
				"no-historical-ligatures",
				"contextual",
				"no-contextual",
			],
			name: "font-variant-ligatures",
		},
		{
			inherited: !0,
			keywords: [
				"normal",
				"lining-nums",
				"oldstyle-nums",
				"proportional-nums",
				"tabular-nums",
				"diagonal-fractions",
				"stacked-fractions",
				"ordinal",
				"slashed-zero",
			],
			name: "font-variant-numeric",
		},
		{
			inherited: !0,
			keywords: ["normal", "sub", "super"],
			name: "font-variant-position",
		},
		{ inherited: !0, keywords: ["normal"], name: "font-variation-settings" },
		{
			inherited: !0,
			keywords: ["normal", "bold", "bolder", "lighter"],
			name: "font-weight",
		},
		{
			inherited: !0,
			keywords: ["auto", "none", "preserve-parent-color"],
			name: "forced-color-adjust",
		},
		{ longhands: ["row-gap", "column-gap"], name: "gap" },
		{
			longhands: [
				"grid-template-rows",
				"grid-template-columns",
				"grid-template-areas",
				"grid-auto-flow",
				"grid-auto-rows",
				"grid-auto-columns",
			],
			name: "grid",
		},
		{
			longhands: [
				"grid-row-start",
				"grid-column-start",
				"grid-row-end",
				"grid-column-end",
			],
			name: "grid-area",
		},
		{
			keywords: ["auto", "min-content", "max-content"],
			name: "grid-auto-columns",
		},
		{ keywords: ["row", "column"], name: "grid-auto-flow" },
		{
			keywords: ["auto", "min-content", "max-content"],
			name: "grid-auto-rows",
		},
		{
			longhands: ["grid-column-start", "grid-column-end"],
			name: "grid-column",
		},
		{ keywords: ["auto"], name: "grid-column-end" },
		{ longhands: ["column-gap"], name: "grid-column-gap" },
		{ keywords: ["auto"], name: "grid-column-start" },
		{ longhands: ["row-gap", "column-gap"], name: "grid-gap" },
		{ longhands: ["grid-row-start", "grid-row-end"], name: "grid-row" },
		{ keywords: ["auto"], name: "grid-row-end" },
		{ longhands: ["row-gap"], name: "grid-row-gap" },
		{ keywords: ["auto"], name: "grid-row-start" },
		{
			longhands: [
				"grid-template-rows",
				"grid-template-columns",
				"grid-template-areas",
			],
			name: "grid-template",
		},
		{ keywords: ["none"], name: "grid-template-areas" },
		{ keywords: ["none"], name: "grid-template-columns" },
		{ keywords: ["none"], name: "grid-template-rows" },
		{
			keywords: ["auto", "fit-content", "min-content", "max-content"],
			name: "height",
		},
		{ inherited: !0, name: "hyphenate-character" },
		{ inherited: !0, keywords: ["auto"], name: "hyphenate-limit-chars" },
		{ inherited: !0, keywords: ["none", "manual", "auto"], name: "hyphens" },
		{ inherited: !0, name: "image-orientation" },
		{
			inherited: !0,
			keywords: [
				"auto",
				"optimizespeed",
				"optimizequality",
				"-webkit-optimize-contrast",
				"pixelated",
			],
			name: "image-rendering",
		},
		{ name: "inherits" },
		{
			inherited: !1,
			keywords: ["drop", "normal", "raise"],
			name: "initial-letter",
		},
		{ name: "initial-value" },
		{ keywords: ["auto"], name: "inline-size" },
		{ longhands: ["top", "right", "bottom", "left"], name: "inset" },
		{
			keywords: [
				"none",
				"top",
				"bottom",
				"center",
				"left",
				"right",
				"x-start",
				"x-end",
				"y-start",
				"y-end",
				"start",
				"end",
				"self-start",
				"self-end",
				"all",
			],
			name: "inset-area",
		},
		{
			longhands: ["inset-block-start", "inset-block-end"],
			name: "inset-block",
		},
		{ name: "inset-block-end" },
		{ name: "inset-block-start" },
		{
			longhands: ["inset-inline-start", "inset-inline-end"],
			name: "inset-inline",
		},
		{ name: "inset-inline-end" },
		{ name: "inset-inline-start" },
		{ keywords: ["auto", "isolate"], name: "isolation" },
		{ name: "justify-content" },
		{ name: "justify-items" },
		{ name: "justify-self" },
		{ keywords: ["auto"], name: "left" },
		{ inherited: !0, keywords: ["normal"], name: "letter-spacing" },
		{ keywords: ["currentcolor"], name: "lighting-color" },
		{
			inherited: !0,
			keywords: ["auto", "loose", "normal", "strict", "anywhere"],
			name: "line-break",
		},
		{ name: "line-gap-override" },
		{ inherited: !0, keywords: ["normal"], name: "line-height" },
		{
			inherited: !0,
			longhands: ["list-style-position", "list-style-image", "list-style-type"],
			name: "list-style",
		},
		{ inherited: !0, keywords: ["none"], name: "list-style-image" },
		{
			inherited: !0,
			keywords: ["outside", "inside"],
			name: "list-style-position",
		},
		{
			inherited: !0,
			keywords: [
				"disc",
				"circle",
				"square",
				"disclosure-open",
				"disclosure-closed",
				"decimal",
				"none",
			],
			name: "list-style-type",
		},
		{
			longhands: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
			name: "margin",
		},
		{
			longhands: ["margin-block-start", "margin-block-end"],
			name: "margin-block",
		},
		{ keywords: ["auto"], name: "margin-block-end" },
		{ keywords: ["auto"], name: "margin-block-start" },
		{ keywords: ["auto"], name: "margin-bottom" },
		{
			longhands: ["margin-inline-start", "margin-inline-end"],
			name: "margin-inline",
		},
		{ keywords: ["auto"], name: "margin-inline-end" },
		{ keywords: ["auto"], name: "margin-inline-start" },
		{ keywords: ["auto"], name: "margin-left" },
		{ keywords: ["auto"], name: "margin-right" },
		{ keywords: ["auto"], name: "margin-top" },
		{
			inherited: !0,
			longhands: ["marker-start", "marker-mid", "marker-end"],
			name: "marker",
		},
		{ inherited: !0, keywords: ["none"], name: "marker-end" },
		{ inherited: !0, keywords: ["none"], name: "marker-mid" },
		{ inherited: !0, keywords: ["none"], name: "marker-start" },
		{ name: "mask" },
		{ name: "mask-clip" },
		{ name: "mask-composite" },
		{ name: "mask-image" },
		{ name: "mask-mode" },
		{ name: "mask-origin" },
		{
			longhands: ["-webkit-mask-position-x", "-webkit-mask-position-y"],
			name: "mask-position",
		},
		{ name: "mask-repeat" },
		{ name: "mask-size" },
		{ keywords: ["luminance", "alpha"], name: "mask-type" },
		{ inherited: !0, name: "math-depth" },
		{ inherited: !0, keywords: ["normal", "compact"], name: "math-shift" },
		{ inherited: !0, keywords: ["normal", "compact"], name: "math-style" },
		{ keywords: ["none"], name: "max-block-size" },
		{ keywords: ["none"], name: "max-height" },
		{ keywords: ["none"], name: "max-inline-size" },
		{ keywords: ["none"], name: "max-width" },
		{ name: "min-block-size" },
		{ name: "min-height" },
		{ name: "min-inline-size" },
		{ name: "min-width" },
		{
			keywords: [
				"normal",
				"multiply",
				"screen",
				"overlay",
				"darken",
				"lighten",
				"color-dodge",
				"color-burn",
				"hard-light",
				"soft-light",
				"difference",
				"exclusion",
				"hue",
				"saturation",
				"color",
				"luminosity",
				"plus-lighter",
			],
			name: "mix-blend-mode",
		},
		{ name: "navigation" },
		{ name: "negative" },
		{
			keywords: ["fill", "contain", "cover", "none", "scale-down"],
			name: "object-fit",
		},
		{ name: "object-position" },
		{ keywords: ["none"], name: "object-view-box" },
		{
			longhands: [
				"offset-position",
				"offset-path",
				"offset-distance",
				"offset-rotate",
				"offset-anchor",
			],
			name: "offset",
		},
		{ keywords: ["auto"], name: "offset-anchor" },
		{ name: "offset-distance" },
		{ keywords: ["none"], name: "offset-path" },
		{ keywords: ["auto", "normal"], name: "offset-position" },
		{ keywords: ["auto", "reverse"], name: "offset-rotate" },
		{ name: "opacity" },
		{ name: "order" },
		{ keywords: ["normal", "none"], name: "origin-trial-test-property" },
		{ inherited: !0, name: "orphans" },
		{
			longhands: ["outline-color", "outline-style", "outline-width"],
			name: "outline",
		},
		{ keywords: ["currentcolor"], name: "outline-color" },
		{ name: "outline-offset" },
		{
			keywords: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
			name: "outline-style",
		},
		{ keywords: ["thin", "medium", "thick"], name: "outline-width" },
		{ longhands: ["overflow-x", "overflow-y"], name: "overflow" },
		{
			inherited: !1,
			keywords: ["visible", "none", "auto"],
			name: "overflow-anchor",
		},
		{ name: "overflow-block" },
		{
			keywords: ["border-box", "content-box", "padding-box"],
			name: "overflow-clip-margin",
		},
		{ name: "overflow-inline" },
		{
			inherited: !0,
			keywords: ["normal", "break-word", "anywhere"],
			name: "overflow-wrap",
		},
		{
			keywords: ["visible", "hidden", "scroll", "auto", "overlay", "clip"],
			name: "overflow-x",
		},
		{
			keywords: ["visible", "hidden", "scroll", "auto", "overlay", "clip"],
			name: "overflow-y",
		},
		{ keywords: ["none", "auto"], name: "overlay" },
		{ name: "override-colors" },
		{
			longhands: ["overscroll-behavior-x", "overscroll-behavior-y"],
			name: "overscroll-behavior",
		},
		{ name: "overscroll-behavior-block" },
		{ name: "overscroll-behavior-inline" },
		{ keywords: ["auto", "contain", "none"], name: "overscroll-behavior-x" },
		{ keywords: ["auto", "contain", "none"], name: "overscroll-behavior-y" },
		{ name: "pad" },
		{
			longhands: [
				"padding-top",
				"padding-right",
				"padding-bottom",
				"padding-left",
			],
			name: "padding",
		},
		{
			longhands: ["padding-block-start", "padding-block-end"],
			name: "padding-block",
		},
		{ name: "padding-block-end" },
		{ name: "padding-block-start" },
		{ name: "padding-bottom" },
		{
			longhands: ["padding-inline-start", "padding-inline-end"],
			name: "padding-inline",
		},
		{ name: "padding-inline-end" },
		{ name: "padding-inline-start" },
		{ name: "padding-left" },
		{ name: "padding-right" },
		{ name: "padding-top" },
		{ keywords: ["auto"], name: "page" },
		{ longhands: ["break-after"], name: "page-break-after" },
		{ longhands: ["break-before"], name: "page-break-before" },
		{ longhands: ["break-inside"], name: "page-break-inside" },
		{ name: "page-orientation" },
		{
			inherited: !0,
			keywords: ["normal", "fill", "stroke", "markers"],
			name: "paint-order",
		},
		{ keywords: ["none"], name: "perspective" },
		{ name: "perspective-origin" },
		{ longhands: ["align-content", "justify-content"], name: "place-content" },
		{ longhands: ["align-items", "justify-items"], name: "place-items" },
		{ longhands: ["align-self", "justify-self"], name: "place-self" },
		{
			inherited: !0,
			keywords: [
				"none",
				"auto",
				"stroke",
				"fill",
				"painted",
				"visible",
				"visiblestroke",
				"visiblefill",
				"visiblepainted",
				"bounding-box",
				"all",
			],
			name: "pointer-events",
		},
		{ name: "popover-hide-delay" },
		{ name: "popover-show-delay" },
		{
			keywords: ["static", "relative", "absolute", "fixed", "sticky"],
			name: "position",
		},
		{ keywords: ["none"], name: "position-fallback" },
		{ keywords: ["normal"], name: "position-fallback-bounds" },
		{ name: "prefix" },
		{ inherited: !0, keywords: ["auto", "none"], name: "quotes" },
		{ name: "r" },
		{ name: "range" },
		{
			keywords: ["none", "both", "horizontal", "vertical", "block", "inline"],
			name: "resize",
		},
		{ keywords: ["auto"], name: "right" },
		{ name: "rotate" },
		{ keywords: ["normal"], name: "row-gap" },
		{ inherited: !0, name: "ruby-position" },
		{ keywords: ["auto"], name: "rx" },
		{ keywords: ["auto"], name: "ry" },
		{ name: "scale" },
		{ keywords: ["auto", "smooth"], name: "scroll-behavior" },
		{
			longhands: [
				"scroll-margin-top",
				"scroll-margin-right",
				"scroll-margin-bottom",
				"scroll-margin-left",
			],
			name: "scroll-margin",
		},
		{
			longhands: ["scroll-margin-block-start", "scroll-margin-block-end"],
			name: "scroll-margin-block",
		},
		{ name: "scroll-margin-block-end" },
		{ name: "scroll-margin-block-start" },
		{ name: "scroll-margin-bottom" },
		{
			longhands: ["scroll-margin-inline-start", "scroll-margin-inline-end"],
			name: "scroll-margin-inline",
		},
		{ name: "scroll-margin-inline-end" },
		{ name: "scroll-margin-inline-start" },
		{ name: "scroll-margin-left" },
		{ name: "scroll-margin-right" },
		{ name: "scroll-margin-top" },
		{
			longhands: [
				"scroll-padding-top",
				"scroll-padding-right",
				"scroll-padding-bottom",
				"scroll-padding-left",
			],
			name: "scroll-padding",
		},
		{
			longhands: ["scroll-padding-block-start", "scroll-padding-block-end"],
			name: "scroll-padding-block",
		},
		{ keywords: ["auto"], name: "scroll-padding-block-end" },
		{ keywords: ["auto"], name: "scroll-padding-block-start" },
		{ keywords: ["auto"], name: "scroll-padding-bottom" },
		{
			longhands: ["scroll-padding-inline-start", "scroll-padding-inline-end"],
			name: "scroll-padding-inline",
		},
		{ keywords: ["auto"], name: "scroll-padding-inline-end" },
		{ keywords: ["auto"], name: "scroll-padding-inline-start" },
		{ keywords: ["auto"], name: "scroll-padding-left" },
		{ keywords: ["auto"], name: "scroll-padding-right" },
		{ keywords: ["auto"], name: "scroll-padding-top" },
		{ keywords: ["none", "start", "end", "center"], name: "scroll-snap-align" },
		{ keywords: ["normal", "always"], name: "scroll-snap-stop" },
		{
			keywords: [
				"none",
				"x",
				"y",
				"block",
				"inline",
				"both",
				"mandatory",
				"proximity",
			],
			name: "scroll-snap-type",
		},
		{
			longhands: ["scroll-start-block", "scroll-start-inline"],
			name: "scroll-start",
		},
		{
			keywords: [
				"auto",
				"start",
				"end",
				"center",
				"top",
				"bottom",
				"left",
				"right",
			],
			name: "scroll-start-block",
		},
		{
			keywords: [
				"auto",
				"start",
				"end",
				"center",
				"top",
				"bottom",
				"left",
				"right",
			],
			name: "scroll-start-inline",
		},
		{
			longhands: ["scroll-start-target-block", "scroll-start-target-inline"],
			name: "scroll-start-target",
		},
		{ keywords: ["none", "auto"], name: "scroll-start-target-block" },
		{ keywords: ["none", "auto"], name: "scroll-start-target-inline" },
		{ keywords: ["none", "auto"], name: "scroll-start-target-x" },
		{ keywords: ["none", "auto"], name: "scroll-start-target-y" },
		{ name: "scroll-start-x" },
		{ name: "scroll-start-y" },
		{
			longhands: ["scroll-timeline-name", "scroll-timeline-axis"],
			name: "scroll-timeline",
		},
		{ name: "scroll-timeline-axis" },
		{ name: "scroll-timeline-name" },
		{ inherited: !0, keywords: ["auto"], name: "scrollbar-color" },
		{
			inherited: !1,
			keywords: ["auto", "stable", "both-edges"],
			name: "scrollbar-gutter",
		},
		{
			inherited: !1,
			keywords: ["auto", "thin", "none"],
			name: "scrollbar-width",
		},
		{ name: "shape-image-threshold" },
		{ keywords: ["none"], name: "shape-margin" },
		{ keywords: ["none"], name: "shape-outside" },
		{
			inherited: !0,
			keywords: ["auto", "optimizespeed", "crispedges", "geometricprecision"],
			name: "shape-rendering",
		},
		{ name: "size" },
		{ name: "size-adjust" },
		{
			inherited: !0,
			keywords: [
				"none",
				"normal",
				"spell-out",
				"digits",
				"literal-punctuation",
				"no-punctuation",
			],
			name: "speak",
		},
		{ name: "speak-as" },
		{ name: "src" },
		{ keywords: ["currentcolor"], name: "stop-color" },
		{ name: "stop-opacity" },
		{ inherited: !0, name: "stroke" },
		{ inherited: !0, keywords: ["none"], name: "stroke-dasharray" },
		{ inherited: !0, name: "stroke-dashoffset" },
		{
			inherited: !0,
			keywords: ["butt", "round", "square"],
			name: "stroke-linecap",
		},
		{
			inherited: !0,
			keywords: ["miter", "bevel", "round"],
			name: "stroke-linejoin",
		},
		{ inherited: !0, name: "stroke-miterlimit" },
		{ inherited: !0, name: "stroke-opacity" },
		{ inherited: !0, name: "stroke-width" },
		{ name: "suffix" },
		{ name: "symbols" },
		{ name: "syntax" },
		{ name: "system" },
		{ inherited: !0, name: "tab-size" },
		{ keywords: ["auto", "fixed"], name: "table-layout" },
		{
			inherited: !0,
			keywords: [
				"left",
				"right",
				"center",
				"justify",
				"-webkit-left",
				"-webkit-right",
				"-webkit-center",
				"start",
				"end",
			],
			name: "text-align",
		},
		{
			inherited: !0,
			keywords: ["auto", "start", "end", "left", "right", "center", "justify"],
			name: "text-align-last",
		},
		{
			inherited: !0,
			keywords: ["start", "middle", "end"],
			name: "text-anchor",
		},
		{
			inherited: !0,
			keywords: ["normal", "no-autospace"],
			name: "text-autospace",
		},
		{ keywords: ["none", "start", "end", "both"], name: "text-box-trim" },
		{ inherited: !0, keywords: ["none", "all"], name: "text-combine-upright" },
		{
			longhands: [
				"text-decoration-line",
				"text-decoration-thickness",
				"text-decoration-style",
				"text-decoration-color",
			],
			name: "text-decoration",
		},
		{ keywords: ["currentcolor"], name: "text-decoration-color" },
		{
			keywords: [
				"none",
				"underline",
				"overline",
				"line-through",
				"blink",
				"spelling-error",
				"grammar-error",
			],
			name: "text-decoration-line",
		},
		{
			inherited: !0,
			keywords: ["none", "auto"],
			name: "text-decoration-skip-ink",
		},
		{
			keywords: ["solid", "double", "dotted", "dashed", "wavy"],
			name: "text-decoration-style",
		},
		{
			inherited: !1,
			keywords: ["auto", "from-font"],
			name: "text-decoration-thickness",
		},
		{
			inherited: !0,
			longhands: ["text-emphasis-style", "text-emphasis-color"],
			name: "text-emphasis",
		},
		{ inherited: !0, keywords: ["currentcolor"], name: "text-emphasis-color" },
		{ inherited: !0, name: "text-emphasis-position" },
		{ inherited: !0, name: "text-emphasis-style" },
		{ inherited: !0, name: "text-indent" },
		{
			inherited: !0,
			keywords: ["sideways", "mixed", "upright"],
			name: "text-orientation",
		},
		{ keywords: ["clip", "ellipsis"], name: "text-overflow" },
		{
			inherited: !0,
			keywords: [
				"auto",
				"optimizespeed",
				"optimizelegibility",
				"geometricprecision",
			],
			name: "text-rendering",
		},
		{ inherited: !0, keywords: ["none"], name: "text-shadow" },
		{ inherited: !0, keywords: ["none", "auto"], name: "text-size-adjust" },
		{
			inherited: !0,
			longhands: ["text-autospace", "text-spacing-trim"],
			name: "text-spacing",
		},
		{
			inherited: !0,
			keywords: ["space-first", "space-all"],
			name: "text-spacing-trim",
		},
		{
			inherited: !0,
			keywords: ["capitalize", "uppercase", "lowercase", "none", "math-auto"],
			name: "text-transform",
		},
		{ inherited: !0, keywords: ["auto"], name: "text-underline-offset" },
		{
			inherited: !0,
			keywords: ["auto", "from-font", "under", "left", "right"],
			name: "text-underline-position",
		},
		{
			inherited: !0,
			keywords: ["wrap", "nowrap", "balance", "pretty"],
			name: "text-wrap",
		},
		{ name: "timeline-scope" },
		{ keywords: ["auto"], name: "top" },
		{
			keywords: [
				"auto",
				"none",
				"pan-x",
				"pan-left",
				"pan-right",
				"pan-y",
				"pan-up",
				"pan-down",
				"pinch-zoom",
				"manipulation",
			],
			name: "touch-action",
		},
		{ keywords: ["none"], name: "transform" },
		{
			keywords: [
				"content-box",
				"border-box",
				"fill-box",
				"stroke-box",
				"view-box",
			],
			name: "transform-box",
		},
		{ name: "transform-origin" },
		{ keywords: ["flat", "preserve-3d"], name: "transform-style" },
		{
			longhands: [
				"transition-property",
				"transition-duration",
				"transition-timing-function",
				"transition-delay",
				"transition-behavior",
			],
			name: "transition",
		},
		{ name: "transition-behavior" },
		{ name: "transition-delay" },
		{ name: "transition-duration" },
		{ keywords: ["none"], name: "transition-property" },
		{
			keywords: [
				"linear",
				"ease",
				"ease-in",
				"ease-out",
				"ease-in-out",
				"jump-both",
				"jump-end",
				"jump-none",
				"jump-start",
				"step-start",
				"step-end",
			],
			name: "transition-timing-function",
		},
		{ name: "translate" },
		{
			keywords: [
				"normal",
				"embed",
				"bidi-override",
				"isolate",
				"plaintext",
				"isolate-override",
			],
			name: "unicode-bidi",
		},
		{ name: "unicode-range" },
		{
			inherited: !0,
			keywords: ["auto", "none", "text", "all", "contain"],
			name: "user-select",
		},
		{ keywords: ["none", "non-scaling-stroke"], name: "vector-effect" },
		{
			keywords: [
				"baseline",
				"sub",
				"super",
				"text-top",
				"text-bottom",
				"middle",
			],
			name: "vertical-align",
		},
		{
			longhands: ["view-timeline-name", "view-timeline-axis"],
			name: "view-timeline",
		},
		{ name: "view-timeline-axis" },
		{ name: "view-timeline-inset" },
		{ name: "view-timeline-name" },
		{ keywords: ["none"], name: "view-transition-name" },
		{
			inherited: !0,
			keywords: ["visible", "hidden", "collapse"],
			name: "visibility",
		},
		{
			inherited: !0,
			longhands: ["white-space-collapse", "text-wrap"],
			name: "white-space",
		},
		{
			inherited: !0,
			keywords: ["collapse", "preserve", "preserve-breaks", "break-spaces"],
			name: "white-space-collapse",
		},
		{ inherited: !0, name: "widows" },
		{
			keywords: ["auto", "fit-content", "min-content", "max-content"],
			name: "width",
		},
		{ keywords: ["auto"], name: "will-change" },
		{
			inherited: !0,
			keywords: [
				"normal",
				"break-all",
				"keep-all",
				"break-word",
				"auto-phrase",
			],
			name: "word-break",
		},
		{ inherited: !0, keywords: ["normal"], name: "word-spacing" },
		{
			inherited: !0,
			keywords: ["horizontal-tb", "vertical-rl", "vertical-lr"],
			name: "writing-mode",
		},
		{ name: "x" },
		{ name: "y" },
		{ keywords: ["auto"], name: "z-index" },
		{ name: "zoom" },
	],
	g = {
		"-webkit-box-align": {
			values: ["stretch", "start", "center", "end", "baseline"],
		},
		"-webkit-box-decoration-break": { values: ["slice", "clone"] },
		"-webkit-box-direction": { values: ["normal", "reverse"] },
		"-webkit-box-orient": { values: ["horizontal", "vertical"] },
		"-webkit-box-pack": { values: ["start", "center", "end", "justify"] },
		"-webkit-line-break": {
			values: [
				"auto",
				"loose",
				"normal",
				"strict",
				"after-white-space",
				"anywhere",
			],
		},
		"-webkit-print-color-adjust": { values: ["economy", "exact"] },
		"-webkit-rtl-ordering": { values: ["logical", "visual"] },
		"-webkit-ruby-position": { values: ["before", "after"] },
		"-webkit-text-security": { values: ["none", "disc", "circle", "square"] },
		"-webkit-user-drag": { values: ["auto", "none", "element"] },
		"-webkit-user-modify": {
			values: ["read-only", "read-write", "read-write-plaintext-only"],
		},
		"accent-color": { values: ["auto", "currentcolor"] },
		"alignment-baseline": {
			values: [
				"auto",
				"baseline",
				"alphabetic",
				"ideographic",
				"middle",
				"central",
				"mathematical",
				"before-edge",
				"text-before-edge",
				"after-edge",
				"text-after-edge",
				"hanging",
			],
		},
		"anchor-default": { values: ["none"] },
		"anchor-name": { values: ["none"] },
		"animation-composition": { values: ["replace", "add", "accumulate"] },
		"animation-direction": {
			values: ["normal", "reverse", "alternate", "alternate-reverse"],
		},
		"animation-fill-mode": {
			values: ["none", "forwards", "backwards", "both"],
		},
		"animation-iteration-count": { values: ["infinite"] },
		"animation-name": { values: ["none"] },
		"animation-play-state": { values: ["running", "paused"] },
		"animation-timeline": { values: ["none", "auto"] },
		"animation-timing-function": {
			values: [
				"linear",
				"ease",
				"ease-in",
				"ease-out",
				"ease-in-out",
				"jump-both",
				"jump-end",
				"jump-none",
				"jump-start",
				"step-start",
				"step-end",
			],
		},
		"app-region": { values: ["none", "drag", "no-drag"] },
		"aspect-ratio": { values: ["auto"] },
		"backdrop-filter": { values: ["none"] },
		"backface-visibility": { values: ["visible", "hidden"] },
		"background-attachment": { values: ["scroll", "fixed", "local"] },
		"background-blend-mode": {
			values: [
				"normal",
				"multiply",
				"screen",
				"overlay",
				"darken",
				"lighten",
				"color-dodge",
				"color-burn",
				"hard-light",
				"soft-light",
				"difference",
				"exclusion",
				"hue",
				"saturation",
				"color",
				"luminosity",
			],
		},
		"background-clip": {
			values: ["border-box", "padding-box", "content-box", "text"],
		},
		"background-color": { values: ["currentcolor"] },
		"background-image": { values: ["auto", "none"] },
		"background-origin": {
			values: ["border-box", "padding-box", "content-box"],
		},
		"background-size": { values: ["auto", "cover", "contain"] },
		"baseline-shift": { values: ["baseline", "sub", "super"] },
		"baseline-source": { values: ["auto", "first", "last"] },
		"block-size": { values: ["auto"] },
		"border-bottom-color": { values: ["currentcolor"] },
		"border-bottom-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"border-bottom-width": { values: ["thin", "medium", "thick"] },
		"border-collapse": { values: ["separate", "collapse"] },
		"border-image-repeat": { values: ["stretch", "repeat", "round", "space"] },
		"border-image-source": { values: ["none"] },
		"border-image-width": { values: ["auto"] },
		"border-left-color": { values: ["currentcolor"] },
		"border-left-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"border-left-width": { values: ["thin", "medium", "thick"] },
		"border-right-color": { values: ["currentcolor"] },
		"border-right-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"border-right-width": { values: ["thin", "medium", "thick"] },
		"border-style": { values: ["none"] },
		"border-top-color": { values: ["currentcolor"] },
		"border-top-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"border-top-width": { values: ["thin", "medium", "thick"] },
		bottom: { values: ["auto"] },
		"box-shadow": { values: ["none"] },
		"box-sizing": { values: ["content-box", "border-box"] },
		"break-after": {
			values: [
				"auto",
				"avoid",
				"avoid-column",
				"avoid-page",
				"column",
				"left",
				"page",
				"recto",
				"right",
				"verso",
			],
		},
		"break-before": {
			values: [
				"auto",
				"avoid",
				"avoid-column",
				"avoid-page",
				"column",
				"left",
				"page",
				"recto",
				"right",
				"verso",
			],
		},
		"break-inside": { values: ["auto", "avoid", "avoid-column", "avoid-page"] },
		"buffered-rendering": { values: ["auto", "dynamic", "static"] },
		"caption-side": { values: ["top", "bottom"] },
		"caret-color": { values: ["auto", "currentcolor"] },
		clear: {
			values: ["none", "left", "right", "both", "inline-start", "inline-end"],
		},
		clip: { values: ["auto"] },
		"clip-path": {
			values: [
				"border-box",
				"padding-box",
				"content-box",
				"margin-box",
				"fill-box",
				"stroke-box",
				"view-box",
				"none",
			],
		},
		"clip-rule": { values: ["nonzero", "evenodd"] },
		color: { values: ["currentcolor"] },
		"color-interpolation": { values: ["auto", "srgb", "linearrgb"] },
		"color-interpolation-filters": { values: ["auto", "srgb", "linearrgb"] },
		"color-rendering": { values: ["auto", "optimizespeed", "optimizequality"] },
		"column-count": { values: ["auto"] },
		"column-fill": { values: ["balance", "auto"] },
		"column-gap": { values: ["normal"] },
		"column-rule-color": { values: ["currentcolor"] },
		"column-rule-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"column-rule-width": { values: ["thin", "medium", "thick"] },
		"column-span": { values: ["none", "all"] },
		"column-width": { values: ["auto"] },
		contain: {
			values: [
				"none",
				"strict",
				"content",
				"size",
				"layout",
				"style",
				"paint",
				"inline-size",
				"block-size",
			],
		},
		"contain-intrinsic-height": { values: ["none"] },
		"contain-intrinsic-width": { values: ["none"] },
		"container-name": { values: ["none"] },
		"container-type": {
			values: ["normal", "inline-size", "size", "scroll-state"],
		},
		"content-visibility": { values: ["visible", "auto", "hidden"] },
		"counter-increment": { values: ["none"] },
		"counter-reset": { values: ["none"] },
		"counter-set": { values: ["none"] },
		cursor: {
			values: [
				"auto",
				"default",
				"none",
				"context-menu",
				"help",
				"pointer",
				"progress",
				"wait",
				"cell",
				"crosshair",
				"text",
				"vertical-text",
				"alias",
				"copy",
				"move",
				"no-drop",
				"not-allowed",
				"e-resize",
				"n-resize",
				"ne-resize",
				"nw-resize",
				"s-resize",
				"se-resize",
				"sw-resize",
				"w-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"col-resize",
				"row-resize",
				"all-scroll",
				"zoom-in",
				"zoom-out",
				"grab",
				"grabbing",
			],
		},
		d: { values: ["none"] },
		direction: { values: ["ltr", "rtl"] },
		display: {
			values: [
				"inline",
				"block",
				"list-item",
				"inline-block",
				"table",
				"inline-table",
				"table-row-group",
				"table-header-group",
				"table-footer-group",
				"table-row",
				"table-column-group",
				"table-column",
				"table-cell",
				"table-caption",
				"-webkit-box",
				"-webkit-inline-box",
				"flex",
				"inline-flex",
				"grid",
				"inline-grid",
				"contents",
				"flow-root",
				"none",
				"flow",
				"math",
				"ruby",
				"ruby-text",
			],
		},
		"dominant-baseline": {
			values: [
				"auto",
				"alphabetic",
				"ideographic",
				"middle",
				"central",
				"mathematical",
				"hanging",
				"use-script",
				"no-change",
				"reset-size",
				"text-after-edge",
				"text-before-edge",
			],
		},
		"dynamic-range-limit": { values: ["standard", "high", "constrained-high"] },
		"empty-cells": { values: ["show", "hide"] },
		"field-sizing": { values: ["fixed", "content"] },
		"fill-rule": { values: ["nonzero", "evenodd"] },
		filter: { values: ["none"] },
		"flex-basis": {
			values: ["auto", "fit-content", "min-content", "max-content", "content"],
		},
		"flex-direction": {
			values: ["row", "row-reverse", "column", "column-reverse"],
		},
		"flex-wrap": { values: ["nowrap", "wrap", "wrap-reverse"] },
		float: { values: ["none", "left", "right", "inline-start", "inline-end"] },
		"flood-color": { values: ["currentcolor"] },
		"font-feature-settings": { values: ["normal"] },
		"font-kerning": { values: ["auto", "normal", "none"] },
		"font-optical-sizing": { values: ["auto", "none"] },
		"font-palette": { values: ["normal", "light", "dark"] },
		"font-size": {
			values: [
				"xx-small",
				"x-small",
				"small",
				"medium",
				"large",
				"x-large",
				"xx-large",
				"xxx-large",
				"larger",
				"smaller",
				"-webkit-xxx-large",
			],
		},
		"font-size-adjust": {
			values: [
				"none",
				"ex-height",
				"cap-height",
				"ch-width",
				"ic-width",
				"from-font",
			],
		},
		"font-stretch": {
			values: [
				"normal",
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
			],
		},
		"font-style": { values: ["normal", "italic", "oblique"] },
		"font-synthesis-small-caps": { values: ["auto", "none"] },
		"font-synthesis-style": { values: ["auto", "none"] },
		"font-synthesis-weight": { values: ["auto", "none"] },
		"font-variant-alternates": { values: ["normal"] },
		"font-variant-caps": {
			values: [
				"normal",
				"small-caps",
				"all-small-caps",
				"petite-caps",
				"all-petite-caps",
				"unicase",
				"titling-caps",
			],
		},
		"font-variant-east-asian": {
			values: [
				"normal",
				"jis78",
				"jis83",
				"jis90",
				"jis04",
				"simplified",
				"traditional",
				"full-width",
				"proportional-width",
				"ruby",
			],
		},
		"font-variant-ligatures": {
			values: [
				"normal",
				"none",
				"common-ligatures",
				"no-common-ligatures",
				"discretionary-ligatures",
				"no-discretionary-ligatures",
				"historical-ligatures",
				"no-historical-ligatures",
				"contextual",
				"no-contextual",
			],
		},
		"font-variant-numeric": {
			values: [
				"normal",
				"lining-nums",
				"oldstyle-nums",
				"proportional-nums",
				"tabular-nums",
				"diagonal-fractions",
				"stacked-fractions",
				"ordinal",
				"slashed-zero",
			],
		},
		"font-variant-position": { values: ["normal", "sub", "super"] },
		"font-variation-settings": { values: ["normal"] },
		"font-weight": { values: ["normal", "bold", "bolder", "lighter"] },
		"forced-color-adjust": {
			values: ["auto", "none", "preserve-parent-color"],
		},
		"grid-auto-columns": { values: ["auto", "min-content", "max-content"] },
		"grid-auto-flow": { values: ["row", "column"] },
		"grid-auto-rows": { values: ["auto", "min-content", "max-content"] },
		"grid-column-end": { values: ["auto"] },
		"grid-column-start": { values: ["auto"] },
		"grid-row-end": { values: ["auto"] },
		"grid-row-start": { values: ["auto"] },
		"grid-template-areas": { values: ["none"] },
		"grid-template-columns": { values: ["none"] },
		"grid-template-rows": { values: ["none"] },
		height: { values: ["auto", "fit-content", "min-content", "max-content"] },
		"hyphenate-limit-chars": { values: ["auto"] },
		hyphens: { values: ["none", "manual", "auto"] },
		"image-rendering": {
			values: [
				"auto",
				"optimizespeed",
				"optimizequality",
				"-webkit-optimize-contrast",
				"pixelated",
			],
		},
		"initial-letter": { values: ["drop", "normal", "raise"] },
		"inline-size": { values: ["auto"] },
		"inset-area": {
			values: [
				"none",
				"top",
				"bottom",
				"center",
				"left",
				"right",
				"x-start",
				"x-end",
				"y-start",
				"y-end",
				"start",
				"end",
				"self-start",
				"self-end",
				"all",
			],
		},
		isolation: { values: ["auto", "isolate"] },
		left: { values: ["auto"] },
		"letter-spacing": { values: ["normal"] },
		"lighting-color": { values: ["currentcolor"] },
		"line-break": { values: ["auto", "loose", "normal", "strict", "anywhere"] },
		"line-height": { values: ["normal"] },
		"list-style-image": { values: ["none"] },
		"list-style-position": { values: ["outside", "inside"] },
		"list-style-type": {
			values: [
				"disc",
				"circle",
				"square",
				"disclosure-open",
				"disclosure-closed",
				"decimal",
				"none",
			],
		},
		"margin-block-end": { values: ["auto"] },
		"margin-block-start": { values: ["auto"] },
		"margin-bottom": { values: ["auto"] },
		"margin-inline-end": { values: ["auto"] },
		"margin-inline-start": { values: ["auto"] },
		"margin-left": { values: ["auto"] },
		"margin-right": { values: ["auto"] },
		"margin-top": { values: ["auto"] },
		"marker-end": { values: ["none"] },
		"marker-mid": { values: ["none"] },
		"marker-start": { values: ["none"] },
		"mask-type": { values: ["luminance", "alpha"] },
		"math-shift": { values: ["normal", "compact"] },
		"math-style": { values: ["normal", "compact"] },
		"max-block-size": { values: ["none"] },
		"max-height": { values: ["none"] },
		"max-inline-size": { values: ["none"] },
		"max-width": { values: ["none"] },
		"mix-blend-mode": {
			values: [
				"normal",
				"multiply",
				"screen",
				"overlay",
				"darken",
				"lighten",
				"color-dodge",
				"color-burn",
				"hard-light",
				"soft-light",
				"difference",
				"exclusion",
				"hue",
				"saturation",
				"color",
				"luminosity",
				"plus-lighter",
			],
		},
		"object-fit": {
			values: ["fill", "contain", "cover", "none", "scale-down"],
		},
		"object-view-box": { values: ["none"] },
		"offset-anchor": { values: ["auto"] },
		"offset-path": { values: ["none"] },
		"offset-position": { values: ["auto", "normal"] },
		"offset-rotate": { values: ["auto", "reverse"] },
		"origin-trial-test-property": { values: ["normal", "none"] },
		"outline-color": { values: ["currentcolor"] },
		"outline-style": {
			values: [
				"none",
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"outline-width": { values: ["thin", "medium", "thick"] },
		"overflow-anchor": { values: ["visible", "none", "auto"] },
		"overflow-clip-margin": {
			values: ["border-box", "content-box", "padding-box"],
		},
		"overflow-wrap": { values: ["normal", "break-word", "anywhere"] },
		"overflow-x": {
			values: ["visible", "hidden", "scroll", "auto", "overlay", "clip"],
		},
		"overflow-y": {
			values: ["visible", "hidden", "scroll", "auto", "overlay", "clip"],
		},
		overlay: { values: ["none", "auto"] },
		"overscroll-behavior-x": { values: ["auto", "contain", "none"] },
		"overscroll-behavior-y": { values: ["auto", "contain", "none"] },
		page: { values: ["auto"] },
		"paint-order": { values: ["normal", "fill", "stroke", "markers"] },
		perspective: { values: ["none"] },
		"pointer-events": {
			values: [
				"none",
				"auto",
				"stroke",
				"fill",
				"painted",
				"visible",
				"visiblestroke",
				"visiblefill",
				"visiblepainted",
				"bounding-box",
				"all",
			],
		},
		position: { values: ["static", "relative", "absolute", "fixed", "sticky"] },
		"position-fallback": { values: ["none"] },
		"position-fallback-bounds": { values: ["normal"] },
		quotes: { values: ["auto", "none"] },
		resize: {
			values: ["none", "both", "horizontal", "vertical", "block", "inline"],
		},
		right: { values: ["auto"] },
		"row-gap": { values: ["normal"] },
		rx: { values: ["auto"] },
		ry: { values: ["auto"] },
		"scroll-behavior": { values: ["auto", "smooth"] },
		"scroll-padding-block-end": { values: ["auto"] },
		"scroll-padding-block-start": { values: ["auto"] },
		"scroll-padding-bottom": { values: ["auto"] },
		"scroll-padding-inline-end": { values: ["auto"] },
		"scroll-padding-inline-start": { values: ["auto"] },
		"scroll-padding-left": { values: ["auto"] },
		"scroll-padding-right": { values: ["auto"] },
		"scroll-padding-top": { values: ["auto"] },
		"scroll-snap-align": { values: ["none", "start", "end", "center"] },
		"scroll-snap-stop": { values: ["normal", "always"] },
		"scroll-snap-type": {
			values: [
				"none",
				"x",
				"y",
				"block",
				"inline",
				"both",
				"mandatory",
				"proximity",
			],
		},
		"scroll-start-block": {
			values: [
				"auto",
				"start",
				"end",
				"center",
				"top",
				"bottom",
				"left",
				"right",
			],
		},
		"scroll-start-inline": {
			values: [
				"auto",
				"start",
				"end",
				"center",
				"top",
				"bottom",
				"left",
				"right",
			],
		},
		"scroll-start-target-block": { values: ["none", "auto"] },
		"scroll-start-target-inline": { values: ["none", "auto"] },
		"scroll-start-target-x": { values: ["none", "auto"] },
		"scroll-start-target-y": { values: ["none", "auto"] },
		"scrollbar-color": { values: ["auto"] },
		"scrollbar-gutter": { values: ["auto", "stable", "both-edges"] },
		"scrollbar-width": { values: ["auto", "thin", "none"] },
		"shape-margin": { values: ["none"] },
		"shape-outside": { values: ["none"] },
		"shape-rendering": {
			values: ["auto", "optimizespeed", "crispedges", "geometricprecision"],
		},
		speak: {
			values: [
				"none",
				"normal",
				"spell-out",
				"digits",
				"literal-punctuation",
				"no-punctuation",
			],
		},
		"stop-color": { values: ["currentcolor"] },
		"stroke-dasharray": { values: ["none"] },
		"stroke-linecap": { values: ["butt", "round", "square"] },
		"stroke-linejoin": { values: ["miter", "bevel", "round"] },
		"table-layout": { values: ["auto", "fixed"] },
		"text-align": {
			values: [
				"left",
				"right",
				"center",
				"justify",
				"-webkit-left",
				"-webkit-right",
				"-webkit-center",
				"start",
				"end",
			],
		},
		"text-align-last": {
			values: ["auto", "start", "end", "left", "right", "center", "justify"],
		},
		"text-anchor": { values: ["start", "middle", "end"] },
		"text-autospace": { values: ["normal", "no-autospace"] },
		"text-box-trim": { values: ["none", "start", "end", "both"] },
		"text-combine-upright": { values: ["none", "all"] },
		"text-decoration-color": { values: ["currentcolor"] },
		"text-decoration-line": {
			values: [
				"none",
				"underline",
				"overline",
				"line-through",
				"blink",
				"spelling-error",
				"grammar-error",
			],
		},
		"text-decoration-skip-ink": { values: ["none", "auto"] },
		"text-decoration-style": {
			values: ["solid", "double", "dotted", "dashed", "wavy"],
		},
		"text-decoration-thickness": { values: ["auto", "from-font"] },
		"text-emphasis-color": { values: ["currentcolor"] },
		"text-orientation": { values: ["sideways", "mixed", "upright"] },
		"text-overflow": { values: ["clip", "ellipsis"] },
		"text-rendering": {
			values: [
				"auto",
				"optimizespeed",
				"optimizelegibility",
				"geometricprecision",
			],
		},
		"text-shadow": { values: ["none"] },
		"text-size-adjust": { values: ["none", "auto"] },
		"text-spacing-trim": { values: ["space-first", "space-all"] },
		"text-transform": {
			values: ["capitalize", "uppercase", "lowercase", "none", "math-auto"],
		},
		"text-underline-offset": { values: ["auto"] },
		"text-underline-position": {
			values: ["auto", "from-font", "under", "left", "right"],
		},
		"text-wrap": { values: ["wrap", "nowrap", "balance", "pretty"] },
		top: { values: ["auto"] },
		"touch-action": {
			values: [
				"auto",
				"none",
				"pan-x",
				"pan-left",
				"pan-right",
				"pan-y",
				"pan-up",
				"pan-down",
				"pinch-zoom",
				"manipulation",
			],
		},
		transform: { values: ["none"] },
		"transform-box": {
			values: [
				"content-box",
				"border-box",
				"fill-box",
				"stroke-box",
				"view-box",
			],
		},
		"transform-style": { values: ["flat", "preserve-3d"] },
		"transition-property": { values: ["none"] },
		"transition-timing-function": {
			values: [
				"linear",
				"ease",
				"ease-in",
				"ease-out",
				"ease-in-out",
				"jump-both",
				"jump-end",
				"jump-none",
				"jump-start",
				"step-start",
				"step-end",
			],
		},
		"unicode-bidi": {
			values: [
				"normal",
				"embed",
				"bidi-override",
				"isolate",
				"plaintext",
				"isolate-override",
			],
		},
		"user-select": { values: ["auto", "none", "text", "all", "contain"] },
		"vector-effect": { values: ["none", "non-scaling-stroke"] },
		"vertical-align": {
			values: ["baseline", "sub", "super", "text-top", "text-bottom", "middle"],
		},
		"view-transition-name": { values: ["none"] },
		visibility: { values: ["visible", "hidden", "collapse"] },
		"white-space-collapse": {
			values: ["collapse", "preserve", "preserve-breaks", "break-spaces"],
		},
		width: { values: ["auto", "fit-content", "min-content", "max-content"] },
		"will-change": { values: ["auto"] },
		"word-break": {
			values: ["normal", "break-all", "keep-all", "break-word", "auto-phrase"],
		},
		"word-spacing": { values: ["normal"] },
		"writing-mode": { values: ["horizontal-tb", "vertical-rl", "vertical-lr"] },
		"z-index": { values: ["auto"] },
	},
	p = new Map([
		["-epub-caption-side", "caption-side"],
		["-epub-text-combine", "-webkit-text-combine"],
		["-epub-text-emphasis", "text-emphasis"],
		["-epub-text-emphasis-color", "text-emphasis-color"],
		["-epub-text-emphasis-style", "text-emphasis-style"],
		["-epub-text-orientation", "-webkit-text-orientation"],
		["-epub-text-transform", "text-transform"],
		["-epub-word-break", "word-break"],
		["-epub-writing-mode", "-webkit-writing-mode"],
		["-webkit-align-content", "align-content"],
		["-webkit-align-items", "align-items"],
		["-webkit-align-self", "align-self"],
		["-webkit-alternative-animation-delay", "-alternative-animation-delay"],
		[
			"-webkit-alternative-animation-with-delay-start-end",
			"-alternative-animation-with-delay-start-end",
		],
		[
			"-webkit-alternative-animation-with-timeline",
			"-alternative-animation-with-timeline",
		],
		["-webkit-alternative-mask", "-alternative-mask"],
		["-webkit-alternative-mask-clip", "mask-clip"],
		["-webkit-alternative-mask-composite", "mask-composite"],
		["-webkit-alternative-mask-image", "mask-image"],
		["-webkit-alternative-mask-origin", "mask-origin"],
		["-webkit-alternative-mask-position", "mask-position"],
		["-webkit-alternative-mask-repeat", "mask-repeat"],
		["-webkit-alternative-mask-size", "mask-size"],
		["-webkit-animation", "animation"],
		["-webkit-animation-delay", "animation-delay"],
		["-webkit-animation-direction", "animation-direction"],
		["-webkit-animation-duration", "animation-duration"],
		["-webkit-animation-fill-mode", "animation-fill-mode"],
		["-webkit-animation-iteration-count", "animation-iteration-count"],
		["-webkit-animation-name", "animation-name"],
		["-webkit-animation-play-state", "animation-play-state"],
		["-webkit-animation-timing-function", "animation-timing-function"],
		["-webkit-app-region", "app-region"],
		["-webkit-appearance", "appearance"],
		["-webkit-backface-visibility", "backface-visibility"],
		["-webkit-background-clip", "background-clip"],
		["-webkit-background-origin", "background-origin"],
		["-webkit-background-size", "background-size"],
		["-webkit-border-after", "border-block-end"],
		["-webkit-border-after-color", "border-block-end-color"],
		["-webkit-border-after-style", "border-block-end-style"],
		["-webkit-border-after-width", "border-block-end-width"],
		["-webkit-border-before", "border-block-start"],
		["-webkit-border-before-color", "border-block-start-color"],
		["-webkit-border-before-style", "border-block-start-style"],
		["-webkit-border-before-width", "border-block-start-width"],
		["-webkit-border-bottom-left-radius", "border-bottom-left-radius"],
		["-webkit-border-bottom-right-radius", "border-bottom-right-radius"],
		["-webkit-border-end", "border-inline-end"],
		["-webkit-border-end-color", "border-inline-end-color"],
		["-webkit-border-end-style", "border-inline-end-style"],
		["-webkit-border-end-width", "border-inline-end-width"],
		["-webkit-border-radius", "border-radius"],
		["-webkit-border-start", "border-inline-start"],
		["-webkit-border-start-color", "border-inline-start-color"],
		["-webkit-border-start-style", "border-inline-start-style"],
		["-webkit-border-start-width", "border-inline-start-width"],
		["-webkit-border-top-left-radius", "border-top-left-radius"],
		["-webkit-border-top-right-radius", "border-top-right-radius"],
		["-webkit-box-shadow", "box-shadow"],
		["-webkit-box-sizing", "box-sizing"],
		["-webkit-clip-path", "clip-path"],
		["-webkit-column-count", "column-count"],
		["-webkit-column-gap", "column-gap"],
		["-webkit-column-rule", "column-rule"],
		["-webkit-column-rule-color", "column-rule-color"],
		["-webkit-column-rule-style", "column-rule-style"],
		["-webkit-column-rule-width", "column-rule-width"],
		["-webkit-column-span", "column-span"],
		["-webkit-column-width", "column-width"],
		["-webkit-columns", "columns"],
		["-webkit-filter", "filter"],
		["-webkit-flex", "flex"],
		["-webkit-flex-basis", "flex-basis"],
		["-webkit-flex-direction", "flex-direction"],
		["-webkit-flex-flow", "flex-flow"],
		["-webkit-flex-grow", "flex-grow"],
		["-webkit-flex-shrink", "flex-shrink"],
		["-webkit-flex-wrap", "flex-wrap"],
		["-webkit-font-feature-settings", "font-feature-settings"],
		["-webkit-hyphenate-character", "hyphenate-character"],
		["-webkit-justify-content", "justify-content"],
		["-webkit-logical-height", "block-size"],
		["-webkit-logical-width", "inline-size"],
		["-webkit-margin-after", "margin-block-end"],
		["-webkit-margin-before", "margin-block-start"],
		["-webkit-margin-end", "margin-inline-end"],
		["-webkit-margin-start", "margin-inline-start"],
		["-webkit-max-logical-height", "max-block-size"],
		["-webkit-max-logical-width", "max-inline-size"],
		["-webkit-min-logical-height", "min-block-size"],
		["-webkit-min-logical-width", "min-inline-size"],
		["-webkit-opacity", "opacity"],
		["-webkit-order", "order"],
		["-webkit-padding-after", "padding-block-end"],
		["-webkit-padding-before", "padding-block-start"],
		["-webkit-padding-end", "padding-inline-end"],
		["-webkit-padding-start", "padding-inline-start"],
		["-webkit-perspective", "perspective"],
		["-webkit-perspective-origin", "perspective-origin"],
		["-webkit-shape-image-threshold", "shape-image-threshold"],
		["-webkit-shape-margin", "shape-margin"],
		["-webkit-shape-outside", "shape-outside"],
		["-webkit-text-emphasis", "text-emphasis"],
		["-webkit-text-emphasis-color", "text-emphasis-color"],
		["-webkit-text-emphasis-position", "text-emphasis-position"],
		["-webkit-text-emphasis-style", "text-emphasis-style"],
		["-webkit-text-size-adjust", "text-size-adjust"],
		["-webkit-transform", "transform"],
		["-webkit-transform-origin", "transform-origin"],
		["-webkit-transform-style", "transform-style"],
		["-webkit-transition", "transition"],
		["-webkit-transition-delay", "transition-delay"],
		["-webkit-transition-duration", "transition-duration"],
		["-webkit-transition-property", "transition-property"],
		["-webkit-transition-timing-function", "transition-timing-function"],
		["-webkit-user-select", "user-select"],
		["word-wrap", "overflow-wrap"],
	]);
class m {
	#t;
	#n;
	#r;
	#s;
	#i;
	#a;
	#o;
	#l;
	#d;
	#c;
	constructor(e, n) {
		((this.#t = []),
			(this.#n = new Map()),
			(this.#r = new Map()),
			(this.#s = new Set()),
			(this.#i = new Set()),
			(this.#a = new Map()),
			(this.#o = n));
		for (let t = 0; t < e.length; ++t) {
			const n = e[t],
				r = n.name;
			if (!CSS.supports(r, "initial")) continue;
			(this.#t.push(r), n.inherited && this.#s.add(r), n.svg && this.#i.add(r));
			const s = e[t].longhands;
			if (s) {
				this.#n.set(r, s);
				for (let e = 0; e < s.length; ++e) {
					const t = s[e];
					let n = this.#r.get(t);
					(n || ((n = []), this.#r.set(t, n)), n.push(r));
				}
			}
		}
		(this.#t.sort(m.sortPrefixesAndCSSWideKeywordsToEnd),
			(this.#l = new Set(this.#t)));
		const r = new Map();
		for (const [e, t] of Object.entries(g)) r.set(e, new Set(t.values));
		for (const [e, n] of Object.entries(P)) {
			const s = r.get(e);
			s ? t.SetUtilities.addAll(s, n.values) : r.set(e, new Set(n.values));
		}
		for (const [e, t] of r) {
			for (const n of E) !t.has(n) && CSS.supports(e, n) && t.add(n);
			this.#a.set(e, [...t]);
		}
		((this.#d = []), (this.#c = []));
		for (const e of this.#l) {
			const t = this.specificPropertyValues(e)
				.filter((t) => CSS.supports(e, t))
				.sort(m.sortPrefixesAndCSSWideKeywordsToEnd)
				.map((t) => `${e}: ${t}`);
			(this.isSVGProperty(e) || this.#d.push(...t), this.#c.push(...t));
		}
	}
	static sortPrefixesAndCSSWideKeywordsToEnd(e, t) {
		const n = f.includes(e),
			r = f.includes(t);
		if (n && !r) return 1;
		if (!n && r) return -1;
		const s = e.startsWith("-webkit-"),
			i = t.startsWith("-webkit-");
		return s && !i ? 1 : (!s && i) || e < t ? -1 : e > t ? 1 : 0;
	}
	allProperties() {
		return this.#t;
	}
	aliasesFor() {
		return this.#o;
	}
	nameValuePresets(e) {
		return e ? this.#c : this.#d;
	}
	isSVGProperty(e) {
		return ((e = e.toLowerCase()), this.#i.has(e));
	}
	getLonghands(e) {
		return this.#n.get(e) || null;
	}
	getShorthands(e) {
		return this.#r.get(e) || null;
	}
	isColorAwareProperty(e) {
		return x.has(e.toLowerCase()) || this.isCustomProperty(e.toLowerCase());
	}
	isFontFamilyProperty(e) {
		return "font-family" === e.toLowerCase();
	}
	isAngleAwareProperty(e) {
		const t = e.toLowerCase();
		return x.has(t) || M.has(t);
	}
	isGridAreaDefiningProperty(e) {
		return (
			"grid" === (e = e.toLowerCase()) ||
			"grid-template" === e ||
			"grid-template-areas" === e
		);
	}
	isLengthProperty(e) {
		return (
			"line-height" !== (e = e.toLowerCase()) &&
			(C.has(e) ||
				e.startsWith("margin") ||
				e.startsWith("padding") ||
				-1 !== e.indexOf("width") ||
				-1 !== e.indexOf("height"))
		);
	}
	isBezierAwareProperty(e) {
		return ((e = e.toLowerCase()), R.has(e) || this.isCustomProperty(e));
	}
	isFontAwareProperty(e) {
		return ((e = e.toLowerCase()), T.has(e) || this.isCustomProperty(e));
	}
	isCustomProperty(e) {
		return e.startsWith("--");
	}
	isShadowProperty(e) {
		return (
			"box-shadow" === (e = e.toLowerCase()) ||
			"text-shadow" === e ||
			"-webkit-box-shadow" === e
		);
	}
	isStringProperty(e) {
		return "content" === (e = e.toLowerCase());
	}
	canonicalPropertyName(e) {
		if (this.isCustomProperty(e)) return e;
		e = e.toLowerCase();
		const t = this.#o.get(e);
		if (t) return t;
		if (!e || e.length < 9 || "-" !== e.charAt(0)) return e;
		const n = e.match(/(?:-webkit-)(.+)/);
		return n && this.#l.has(n[1]) ? n[1] : e;
	}
	isCSSPropertyName(e) {
		return (
			!!(
				((e = e.toLowerCase()).startsWith("--") && e.length > 2) ||
				e.startsWith("-moz-") ||
				e.startsWith("-ms-") ||
				e.startsWith("-o-") ||
				e.startsWith("-webkit-")
			) || this.#l.has(e)
		);
	}
	isPropertyInherited(e) {
		return (
			(e = e.toLowerCase()).startsWith("--") ||
			this.#s.has(this.canonicalPropertyName(e)) ||
			this.#s.has(e)
		);
	}
	specificPropertyValues(e) {
		const t = e.replace(/^-webkit-/, ""),
			n = this.#a;
		let r = n.get(e) || n.get(t);
		if (!r) {
			r = [];
			for (const t of E) CSS.supports(e, t) && r.push(t);
			n.set(e, r);
		}
		return r;
	}
	getPropertyValues(t) {
		t = t.toLowerCase();
		const n = [...this.specificPropertyValues(t), ...f];
		if (this.isColorAwareProperty(t)) {
			n.push("currentColor");
			for (const t of e.Color.Nicknames.keys()) n.push(t);
		}
		return n.sort(m.sortPrefixesAndCSSWideKeywordsToEnd);
	}
	propertyUsageWeight(e) {
		return L.get(e) || L.get(this.canonicalPropertyName(e)) || 0;
	}
	getValuePreset(e, t) {
		const n = w.get(e);
		let r = n ? n.get(t) : null;
		if (!r) return null;
		let s = r.length,
			i = r.length;
		return (
			r &&
				((s = r.indexOf("|")),
				(i = r.lastIndexOf("|")),
				(i = s === i ? i : i - 1),
				(r = r.replace(/\|/g, ""))),
			{ text: r, startColumn: s, endColumn: i }
		);
	}
	isHighlightPseudoType(e) {
		return (
			"highlight" === e ||
			"selection" === e ||
			"target-text" === e ||
			"grammar-error" === e ||
			"spelling-error" === e
		);
	}
}
const f = ["inherit", "initial", "revert", "revert-layer", "unset"],
	b = /(var\(\s*--.*?\))/gs,
	y = /((?:\[[\w\- ]+\]\s*)*(?:"[^"]+"|'[^']+'))[^'"\[]*\[?[^'"\[]*/;
let v = null;
function I() {
	if (!v) {
		v = new m(u, p);
	}
	return v;
}
const k = new Map([
		["linear-gradient", "linear-gradient(|45deg, black, transparent|)"],
		["radial-gradient", "radial-gradient(|black, transparent|)"],
		[
			"repeating-linear-gradient",
			"repeating-linear-gradient(|45deg, black, transparent 100px|)",
		],
		[
			"repeating-radial-gradient",
			"repeating-radial-gradient(|black, transparent 100px|)",
		],
		["url", "url(||)"],
	]),
	S = new Map([
		["blur", "blur(|1px|)"],
		["brightness", "brightness(|0.5|)"],
		["contrast", "contrast(|0.5|)"],
		["drop-shadow", "drop-shadow(|2px 4px 6px black|)"],
		["grayscale", "grayscale(|1|)"],
		["hue-rotate", "hue-rotate(|45deg|)"],
		["invert", "invert(|1|)"],
		["opacity", "opacity(|0.5|)"],
		["saturate", "saturate(|0.5|)"],
		["sepia", "sepia(|1|)"],
		["url", "url(||)"],
	]),
	w = new Map([
		["filter", S],
		["backdrop-filter", S],
		["background", k],
		["background-image", k],
		["-webkit-mask-image", k],
		[
			"transform",
			new Map([
				["scale", "scale(|1.5|)"],
				["scaleX", "scaleX(|1.5|)"],
				["scaleY", "scaleY(|1.5|)"],
				["scale3d", "scale3d(|1.5, 1.5, 1.5|)"],
				["rotate", "rotate(|45deg|)"],
				["rotateX", "rotateX(|45deg|)"],
				["rotateY", "rotateY(|45deg|)"],
				["rotateZ", "rotateZ(|45deg|)"],
				["rotate3d", "rotate3d(|1, 1, 1, 45deg|)"],
				["skew", "skew(|10deg, 10deg|)"],
				["skewX", "skewX(|10deg|)"],
				["skewY", "skewY(|10deg|)"],
				["translate", "translate(|10px, 10px|)"],
				["translateX", "translateX(|10px|)"],
				["translateY", "translateY(|10px|)"],
				["translateZ", "translateZ(|10px|)"],
				["translate3d", "translate3d(|10px, 10px, 10px|)"],
				["matrix", "matrix(|1, 0, 0, 1, 0, 0|)"],
				[
					"matrix3d",
					"matrix3d(|1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1|)",
				],
				["perspective", "perspective(|10px|)"],
			]),
		],
	]),
	C = new Set([
		"background-position",
		"border-spacing",
		"bottom",
		"font-size",
		"height",
		"left",
		"letter-spacing",
		"max-height",
		"max-width",
		"min-height",
		"min-width",
		"right",
		"text-indent",
		"top",
		"width",
		"word-spacing",
		"grid-row-gap",
		"grid-column-gap",
		"row-gap",
	]),
	R = new Set([
		"animation",
		"animation-timing-function",
		"transition",
		"transition-timing-function",
		"-webkit-animation",
		"-webkit-animation-timing-function",
		"-webkit-transition",
		"-webkit-transition-timing-function",
	]),
	T = new Set([
		"font-size",
		"line-height",
		"font-weight",
		"font-family",
		"letter-spacing",
	]),
	x = new Set([
		"accent-color",
		"background",
		"background-color",
		"background-image",
		"border",
		"border-color",
		"border-image",
		"border-image-source",
		"border-bottom",
		"border-bottom-color",
		"border-left",
		"border-left-color",
		"border-right",
		"border-right-color",
		"border-top",
		"border-top-color",
		"box-shadow",
		"caret-color",
		"color",
		"column-rule",
		"column-rule-color",
		"content",
		"fill",
		"list-style-image",
		"outline",
		"outline-color",
		"scrollbar-color",
		"stop-color",
		"stroke",
		"text-decoration-color",
		"text-shadow",
		"-webkit-border-after",
		"-webkit-border-after-color",
		"-webkit-border-before",
		"-webkit-border-before-color",
		"-webkit-border-end",
		"-webkit-border-end-color",
		"-webkit-border-start",
		"-webkit-border-start-color",
		"-webkit-box-reflect",
		"-webkit-box-shadow",
		"-webkit-column-rule-color",
		"-webkit-mask",
		"-webkit-mask-box-image",
		"-webkit-mask-box-image-source",
		"-webkit-mask-image",
		"-webkit-tap-highlight-color",
		"-webkit-text-emphasis",
		"-webkit-text-emphasis-color",
		"-webkit-text-fill-color",
		"-webkit-text-stroke",
		"-webkit-text-stroke-color",
	]),
	M = new Set([
		"-webkit-border-image",
		"transform",
		"-webkit-transform",
		"rotate",
		"filter",
		"-webkit-filter",
		"backdrop-filter",
		"offset",
		"offset-rotate",
		"font-style",
	]),
	P = {
		"background-repeat": {
			values: ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"],
		},
		content: {
			values: [
				"normal",
				"close-quote",
				"no-close-quote",
				"no-open-quote",
				"open-quote",
			],
		},
		"baseline-shift": { values: ["baseline"] },
		"max-height": {
			values: [
				"min-content",
				"max-content",
				"-webkit-fill-available",
				"fit-content",
			],
		},
		color: { values: ["black"] },
		"background-color": { values: ["white"] },
		"box-shadow": { values: ["inset"] },
		"text-shadow": { values: ["0 0 black"] },
		"-webkit-writing-mode": {
			values: ["horizontal-tb", "vertical-rl", "vertical-lr"],
		},
		"writing-mode": { values: ["lr", "rl", "tb", "lr-tb", "rl-tb", "tb-rl"] },
		"page-break-inside": { values: ["avoid"] },
		cursor: {
			values: [
				"-webkit-zoom-in",
				"-webkit-zoom-out",
				"-webkit-grab",
				"-webkit-grabbing",
			],
		},
		"border-width": { values: ["medium", "thick", "thin"] },
		"border-style": {
			values: [
				"hidden",
				"inset",
				"groove",
				"ridge",
				"outset",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		size: {
			values: [
				"a3",
				"a4",
				"a5",
				"b4",
				"b5",
				"landscape",
				"ledger",
				"legal",
				"letter",
				"portrait",
			],
		},
		overflow: { values: ["hidden", "visible", "overlay", "scroll"] },
		"overscroll-behavior": { values: ["contain"] },
		"text-rendering": {
			values: ["optimizeSpeed", "optimizeLegibility", "geometricPrecision"],
		},
		"text-align": { values: ["-webkit-auto", "-webkit-match-parent"] },
		"clip-path": { values: ["circle", "ellipse", "inset", "polygon", "url"] },
		"color-interpolation": { values: ["sRGB", "linearRGB"] },
		"word-wrap": { values: ["normal", "break-word"] },
		"font-weight": {
			values: ["100", "200", "300", "400", "500", "600", "700", "800", "900"],
		},
		"-webkit-text-emphasis": {
			values: [
				"circle",
				"filled",
				"open",
				"dot",
				"double-circle",
				"triangle",
				"sesame",
			],
		},
		"color-rendering": { values: ["optimizeSpeed", "optimizeQuality"] },
		"-webkit-text-combine": { values: ["horizontal"] },
		"text-orientation": { values: ["sideways-right"] },
		outline: {
			values: [
				"inset",
				"groove",
				"ridge",
				"outset",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		font: {
			values: [
				"caption",
				"icon",
				"menu",
				"message-box",
				"small-caption",
				"-webkit-mini-control",
				"-webkit-small-control",
				"-webkit-control",
				"status-bar",
			],
		},
		"dominant-baseline": {
			values: [
				"text-before-edge",
				"text-after-edge",
				"use-script",
				"no-change",
				"reset-size",
			],
		},
		"-webkit-text-emphasis-position": { values: ["over", "under"] },
		"alignment-baseline": {
			values: [
				"before-edge",
				"after-edge",
				"text-before-edge",
				"text-after-edge",
				"hanging",
			],
		},
		"page-break-before": { values: ["left", "right", "always", "avoid"] },
		"border-image": { values: ["repeat", "stretch", "space", "round"] },
		"text-decoration": {
			values: [
				"blink",
				"line-through",
				"overline",
				"underline",
				"wavy",
				"double",
				"solid",
				"dashed",
				"dotted",
			],
		},
		"font-family": {
			values: [
				"serif",
				"sans-serif",
				"cursive",
				"fantasy",
				"monospace",
				"system-ui",
				"emoji",
				"math",
				"fangsong",
				"ui-serif",
				"ui-sans-serif",
				"ui-monospace",
				"ui-rounded",
				"-webkit-body",
			],
		},
		zoom: { values: ["normal"] },
		"max-width": {
			values: [
				"min-content",
				"max-content",
				"-webkit-fill-available",
				"fit-content",
			],
		},
		"-webkit-font-smoothing": {
			values: ["antialiased", "subpixel-antialiased"],
		},
		border: {
			values: [
				"hidden",
				"inset",
				"groove",
				"ridge",
				"outset",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"font-variant": {
			values: [
				"small-caps",
				"normal",
				"common-ligatures",
				"no-common-ligatures",
				"discretionary-ligatures",
				"no-discretionary-ligatures",
				"historical-ligatures",
				"no-historical-ligatures",
				"contextual",
				"no-contextual",
				"all-small-caps",
				"petite-caps",
				"all-petite-caps",
				"unicase",
				"titling-caps",
				"lining-nums",
				"oldstyle-nums",
				"proportional-nums",
				"tabular-nums",
				"diagonal-fractions",
				"stacked-fractions",
				"ordinal",
				"slashed-zero",
				"jis78",
				"jis83",
				"jis90",
				"jis04",
				"simplified",
				"traditional",
				"full-width",
				"proportional-width",
				"ruby",
			],
		},
		"vertical-align": { values: ["top", "bottom", "-webkit-baseline-middle"] },
		"page-break-after": { values: ["left", "right", "always", "avoid"] },
		"-webkit-text-emphasis-style": {
			values: [
				"circle",
				"filled",
				"open",
				"dot",
				"double-circle",
				"triangle",
				"sesame",
			],
		},
		transform: {
			values: [
				"scale",
				"scaleX",
				"scaleY",
				"scale3d",
				"rotate",
				"rotateX",
				"rotateY",
				"rotateZ",
				"rotate3d",
				"skew",
				"skewX",
				"skewY",
				"translate",
				"translateX",
				"translateY",
				"translateZ",
				"translate3d",
				"matrix",
				"matrix3d",
				"perspective",
			],
		},
		"align-content": {
			values: [
				"normal",
				"baseline",
				"space-between",
				"space-around",
				"space-evenly",
				"stretch",
				"center",
				"start",
				"end",
				"flex-start",
				"flex-end",
			],
		},
		"justify-content": {
			values: [
				"normal",
				"space-between",
				"space-around",
				"space-evenly",
				"stretch",
				"center",
				"start",
				"end",
				"flex-start",
				"flex-end",
				"left",
				"right",
			],
		},
		"place-content": {
			values: [
				"normal",
				"space-between",
				"space-around",
				"space-evenly",
				"stretch",
				"center",
				"start",
				"end",
				"flex-start",
				"flex-end",
				"baseline",
			],
		},
		"align-items": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
			],
		},
		"justify-items": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
				"left",
				"right",
				"legacy",
			],
		},
		"place-items": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
			],
		},
		"align-self": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
			],
		},
		"justify-self": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
				"left",
				"right",
			],
		},
		"place-self": {
			values: [
				"normal",
				"stretch",
				"baseline",
				"center",
				"start",
				"end",
				"self-start",
				"self-end",
				"flex-start",
				"flex-end",
			],
		},
		"perspective-origin": {
			values: ["left", "center", "right", "top", "bottom"],
		},
		"transform-origin": {
			values: ["left", "center", "right", "top", "bottom"],
		},
		"transition-timing-function": { values: ["cubic-bezier", "steps"] },
		"animation-timing-function": { values: ["cubic-bezier", "steps"] },
		"-webkit-backface-visibility": { values: ["visible", "hidden"] },
		"-webkit-column-break-after": { values: ["always", "avoid"] },
		"-webkit-column-break-before": { values: ["always", "avoid"] },
		"-webkit-column-break-inside": { values: ["avoid"] },
		"-webkit-column-span": { values: ["all"] },
		"-webkit-column-gap": { values: ["normal"] },
		filter: {
			values: [
				"url",
				"blur",
				"brightness",
				"contrast",
				"drop-shadow",
				"grayscale",
				"hue-rotate",
				"invert",
				"opacity",
				"saturate",
				"sepia",
			],
		},
		"backdrop-filter": {
			values: [
				"url",
				"blur",
				"brightness",
				"contrast",
				"drop-shadow",
				"grayscale",
				"hue-rotate",
				"invert",
				"opacity",
				"saturate",
				"sepia",
			],
		},
		"grid-template-columns": { values: ["min-content", "max-content"] },
		"grid-template-rows": { values: ["min-content", "max-content"] },
		"grid-auto-flow": { values: ["dense"] },
		background: {
			values: [
				"repeat",
				"repeat-x",
				"repeat-y",
				"no-repeat",
				"top",
				"bottom",
				"left",
				"right",
				"center",
				"fixed",
				"local",
				"scroll",
				"space",
				"round",
				"border-box",
				"content-box",
				"padding-box",
				"linear-gradient",
				"radial-gradient",
				"repeating-linear-gradient",
				"repeating-radial-gradient",
				"url",
			],
		},
		"background-image": {
			values: [
				"linear-gradient",
				"radial-gradient",
				"repeating-linear-gradient",
				"repeating-radial-gradient",
				"url",
			],
		},
		"background-position": {
			values: ["top", "bottom", "left", "right", "center"],
		},
		"background-position-x": { values: ["left", "right", "center"] },
		"background-position-y": { values: ["top", "bottom", "center"] },
		"background-repeat-x": { values: ["repeat", "no-repeat"] },
		"background-repeat-y": { values: ["repeat", "no-repeat"] },
		"border-bottom": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"border-left": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"border-right": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"border-top": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"buffered-rendering": { values: ["static", "dynamic"] },
		"color-interpolation-filters": { values: ["srgb", "linearrgb"] },
		"column-rule": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"flex-flow": {
			values: [
				"nowrap",
				"row",
				"row-reverse",
				"column",
				"column-reverse",
				"wrap",
				"wrap-reverse",
			],
		},
		height: { values: ["-webkit-fill-available"] },
		"inline-size": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"list-style": {
			values: [
				"outside",
				"inside",
				"disc",
				"circle",
				"square",
				"decimal",
				"decimal-leading-zero",
				"arabic-indic",
				"bengali",
				"cambodian",
				"khmer",
				"devanagari",
				"gujarati",
				"gurmukhi",
				"kannada",
				"lao",
				"malayalam",
				"mongolian",
				"myanmar",
				"oriya",
				"persian",
				"urdu",
				"telugu",
				"tibetan",
				"thai",
				"lower-roman",
				"upper-roman",
				"lower-greek",
				"lower-alpha",
				"lower-latin",
				"upper-alpha",
				"upper-latin",
				"cjk-earthly-branch",
				"cjk-heavenly-stem",
				"ethiopic-halehame",
				"ethiopic-halehame-am",
				"ethiopic-halehame-ti-er",
				"ethiopic-halehame-ti-et",
				"hangul",
				"hangul-consonant",
				"korean-hangul-formal",
				"korean-hanja-formal",
				"korean-hanja-informal",
				"hebrew",
				"armenian",
				"lower-armenian",
				"upper-armenian",
				"georgian",
				"cjk-ideographic",
				"simp-chinese-formal",
				"simp-chinese-informal",
				"trad-chinese-formal",
				"trad-chinese-informal",
				"hiragana",
				"katakana",
				"hiragana-iroha",
				"katakana-iroha",
			],
		},
		"max-block-size": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"max-inline-size": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"min-block-size": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"min-height": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"min-inline-size": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"min-width": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"object-position": { values: ["top", "bottom", "left", "right", "center"] },
		"shape-outside": {
			values: ["border-box", "content-box", "padding-box", "margin-box"],
		},
		"-webkit-appearance": {
			values: [
				"checkbox",
				"radio",
				"push-button",
				"square-button",
				"button",
				"inner-spin-button",
				"listbox",
				"media-slider",
				"media-sliderthumb",
				"media-volume-slider",
				"media-volume-sliderthumb",
				"menulist",
				"menulist-button",
				"meter",
				"progress-bar",
				"slider-horizontal",
				"slider-vertical",
				"sliderthumb-horizontal",
				"sliderthumb-vertical",
				"searchfield",
				"searchfield-cancel-button",
				"textfield",
				"textarea",
			],
		},
		"-webkit-border-after": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"-webkit-border-after-style": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"-webkit-border-after-width": { values: ["medium", "thick", "thin"] },
		"-webkit-border-before": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"-webkit-border-before-style": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"-webkit-border-before-width": { values: ["medium", "thick", "thin"] },
		"-webkit-border-end": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"-webkit-border-end-style": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"-webkit-border-end-width": { values: ["medium", "thick", "thin"] },
		"-webkit-border-start": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
				"medium",
				"thick",
				"thin",
			],
		},
		"-webkit-border-start-style": {
			values: [
				"hidden",
				"inset",
				"groove",
				"outset",
				"ridge",
				"dotted",
				"dashed",
				"solid",
				"double",
			],
		},
		"-webkit-border-start-width": { values: ["medium", "thick", "thin"] },
		"-webkit-logical-height": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-logical-width": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-mask-box-image": {
			values: ["repeat", "stretch", "space", "round"],
		},
		"-webkit-mask-box-image-repeat": {
			values: ["repeat", "stretch", "space", "round"],
		},
		"-webkit-mask-clip": {
			values: [
				"text",
				"border",
				"border-box",
				"content",
				"content-box",
				"padding",
				"padding-box",
			],
		},
		"-webkit-mask-composite": {
			values: [
				"clear",
				"copy",
				"source-over",
				"source-in",
				"source-out",
				"source-atop",
				"destination-over",
				"destination-in",
				"destination-out",
				"destination-atop",
				"xor",
				"plus-lighter",
			],
		},
		"-webkit-mask-image": {
			values: [
				"linear-gradient",
				"radial-gradient",
				"repeating-linear-gradient",
				"repeating-radial-gradient",
				"url",
			],
		},
		"-webkit-mask-origin": {
			values: [
				"border",
				"border-box",
				"content",
				"content-box",
				"padding",
				"padding-box",
			],
		},
		"-webkit-mask-position": {
			values: ["top", "bottom", "left", "right", "center"],
		},
		"-webkit-mask-position-x": { values: ["left", "right", "center"] },
		"-webkit-mask-position-y": { values: ["top", "bottom", "center"] },
		"-webkit-mask-repeat": {
			values: ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"],
		},
		"-webkit-mask-size": { values: ["contain", "cover"] },
		"-webkit-max-logical-height": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-max-logical-width": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-min-logical-height": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-min-logical-width": {
			values: [
				"-webkit-fill-available",
				"min-content",
				"max-content",
				"fit-content",
			],
		},
		"-webkit-perspective-origin-x": { values: ["left", "right", "center"] },
		"-webkit-perspective-origin-y": { values: ["top", "bottom", "center"] },
		"-webkit-text-decorations-in-effect": {
			values: ["blink", "line-through", "overline", "underline"],
		},
		"-webkit-text-stroke": { values: ["medium", "thick", "thin"] },
		"-webkit-text-stroke-width": { values: ["medium", "thick", "thin"] },
		"-webkit-transform-origin-x": { values: ["left", "right", "center"] },
		"-webkit-transform-origin-y": { values: ["top", "bottom", "center"] },
		width: { values: ["-webkit-fill-available"] },
		"contain-intrinsic-width": { values: ["auto none", "auto 100px"] },
		"contain-intrinsic-height": { values: ["auto none", "auto 100px"] },
		"contain-intrinsic-size": { values: ["auto none", "auto 100px"] },
		"contain-intrinsic-inline-size": { values: ["auto none", "auto 100px"] },
		"contain-intrinsic-block-size": { values: ["auto none", "auto 100px"] },
		"white-space": {
			values: [
				"normal",
				"pre",
				"pre-wrap",
				"pre-line",
				"nowrap",
				"break-spaces",
			],
		},
	},
	L = new Map([
		["align-content", 57],
		["align-items", 129],
		["align-self", 55],
		["animation", 175],
		["animation-delay", 114],
		["animation-direction", 113],
		["animation-duration", 137],
		["animation-fill-mode", 132],
		["animation-iteration-count", 124],
		["animation-name", 139],
		["animation-play-state", 104],
		["animation-timing-function", 141],
		["backface-visibility", 123],
		["background", 260],
		["background-attachment", 119],
		["background-clip", 165],
		["background-color", 259],
		["background-image", 246],
		["background-origin", 107],
		["background-position", 237],
		["background-position-x", 108],
		["background-position-y", 93],
		["background-repeat", 234],
		["background-size", 203],
		["border", 263],
		["border-bottom", 233],
		["border-bottom-color", 190],
		["border-bottom-left-radius", 186],
		["border-bottom-right-radius", 185],
		["border-bottom-style", 150],
		["border-bottom-width", 179],
		["border-collapse", 209],
		["border-color", 226],
		["border-image", 89],
		["border-image-outset", 50],
		["border-image-repeat", 49],
		["border-image-slice", 58],
		["border-image-source", 32],
		["border-image-width", 52],
		["border-left", 221],
		["border-left-color", 174],
		["border-left-style", 142],
		["border-left-width", 172],
		["border-radius", 224],
		["border-right", 223],
		["border-right-color", 182],
		["border-right-style", 130],
		["border-right-width", 178],
		["border-spacing", 198],
		["border-style", 206],
		["border-top", 231],
		["border-top-color", 192],
		["border-top-left-radius", 187],
		["border-top-right-radius", 189],
		["border-top-style", 152],
		["border-top-width", 180],
		["border-width", 214],
		["bottom", 227],
		["box-shadow", 213],
		["box-sizing", 216],
		["caption-side", 96],
		["clear", 229],
		["clip", 173],
		["clip-rule", 5],
		["color", 256],
		["content", 219],
		["counter-increment", 111],
		["counter-reset", 110],
		["cursor", 250],
		["direction", 176],
		["display", 262],
		["empty-cells", 99],
		["fill", 140],
		["fill-opacity", 82],
		["fill-rule", 22],
		["filter", 160],
		["flex", 133],
		["flex-basis", 66],
		["flex-direction", 85],
		["flex-flow", 94],
		["flex-grow", 112],
		["flex-shrink", 61],
		["flex-wrap", 68],
		["float", 252],
		["font", 211],
		["font-family", 254],
		["font-kerning", 18],
		["font-size", 264],
		["font-stretch", 77],
		["font-style", 220],
		["font-variant", 161],
		["font-weight", 257],
		["height", 266],
		["image-rendering", 90],
		["justify-content", 127],
		["left", 248],
		["letter-spacing", 188],
		["line-height", 244],
		["list-style", 215],
		["list-style-image", 145],
		["list-style-position", 149],
		["list-style-type", 199],
		["margin", 267],
		["margin-bottom", 241],
		["margin-left", 243],
		["margin-right", 238],
		["margin-top", 253],
		["mask", 20],
		["max-height", 205],
		["max-width", 225],
		["min-height", 217],
		["min-width", 218],
		["object-fit", 33],
		["opacity", 251],
		["order", 117],
		["orphans", 146],
		["outline", 222],
		["outline-color", 153],
		["outline-offset", 147],
		["outline-style", 151],
		["outline-width", 148],
		["overflow", 255],
		["overflow-wrap", 105],
		["overflow-x", 184],
		["overflow-y", 196],
		["padding", 265],
		["padding-bottom", 230],
		["padding-left", 235],
		["padding-right", 232],
		["padding-top", 240],
		["page", 8],
		["page-break-after", 120],
		["page-break-before", 69],
		["page-break-inside", 121],
		["perspective", 92],
		["perspective-origin", 103],
		["pointer-events", 183],
		["position", 261],
		["quotes", 158],
		["resize", 168],
		["right", 245],
		["shape-rendering", 38],
		["size", 64],
		["speak", 118],
		["src", 170],
		["stop-color", 42],
		["stop-opacity", 31],
		["stroke", 98],
		["stroke-dasharray", 36],
		["stroke-dashoffset", 3],
		["stroke-linecap", 30],
		["stroke-linejoin", 21],
		["stroke-miterlimit", 12],
		["stroke-opacity", 34],
		["stroke-width", 87],
		["table-layout", 171],
		["tab-size", 46],
		["text-align", 260],
		["text-anchor", 35],
		["text-decoration", 247],
		["text-indent", 207],
		["text-overflow", 204],
		["text-rendering", 155],
		["text-shadow", 208],
		["text-transform", 202],
		["top", 258],
		["touch-action", 80],
		["transform", 181],
		["transform-origin", 162],
		["transform-style", 86],
		["transition", 193],
		["transition-delay", 134],
		["transition-duration", 135],
		["transition-property", 131],
		["transition-timing-function", 122],
		["unicode-bidi", 156],
		["unicode-range", 136],
		["vertical-align", 236],
		["visibility", 242],
		["-webkit-appearance", 191],
		["-webkit-backface-visibility", 154],
		["-webkit-background-clip", 164],
		["-webkit-background-origin", 40],
		["-webkit-background-size", 163],
		["-webkit-border-end", 9],
		["-webkit-border-horizontal-spacing", 81],
		["-webkit-border-image", 75],
		["-webkit-border-radius", 212],
		["-webkit-border-start", 10],
		["-webkit-border-start-color", 16],
		["-webkit-border-start-width", 13],
		["-webkit-border-vertical-spacing", 43],
		["-webkit-box-align", 101],
		["-webkit-box-direction", 51],
		["-webkit-box-flex", 128],
		["-webkit-box-ordinal-group", 91],
		["-webkit-box-orient", 144],
		["-webkit-box-pack", 106],
		["-webkit-box-reflect", 39],
		["-webkit-box-shadow", 210],
		["-webkit-column-break-inside", 60],
		["-webkit-column-count", 84],
		["-webkit-column-gap", 76],
		["-webkit-column-rule", 25],
		["-webkit-column-rule-color", 23],
		["-webkit-columns", 44],
		["-webkit-column-span", 29],
		["-webkit-column-width", 47],
		["-webkit-filter", 159],
		["-webkit-font-feature-settings", 59],
		["-webkit-font-smoothing", 177],
		["-webkit-line-break", 45],
		["-webkit-line-clamp", 126],
		["-webkit-margin-after", 67],
		["-webkit-margin-before", 70],
		["-webkit-margin-collapse", 14],
		["-webkit-margin-end", 65],
		["-webkit-margin-start", 100],
		["-webkit-mask", 19],
		["-webkit-mask-box-image", 72],
		["-webkit-mask-image", 88],
		["-webkit-mask-position", 54],
		["-webkit-mask-repeat", 63],
		["-webkit-mask-size", 79],
		["-webkit-padding-after", 15],
		["-webkit-padding-before", 28],
		["-webkit-padding-end", 48],
		["-webkit-padding-start", 73],
		["-webkit-print-color-adjust", 83],
		["-webkit-rtl-ordering", 7],
		["-webkit-tap-highlight-color", 169],
		["-webkit-text-emphasis-color", 11],
		["-webkit-text-fill-color", 71],
		["-webkit-text-security", 17],
		["-webkit-text-stroke", 56],
		["-webkit-text-stroke-color", 37],
		["-webkit-text-stroke-width", 53],
		["-webkit-user-drag", 95],
		["-webkit-user-modify", 62],
		["-webkit-user-select", 194],
		["-webkit-writing-mode", 4],
		["white-space", 228],
		["widows", 115],
		["width", 268],
		["will-change", 74],
		["word-break", 166],
		["word-spacing", 157],
		["word-wrap", 197],
		["writing-mode", 41],
		["z-index", 239],
		["zoom", 200],
	]),
	E = ["auto", "none"];
var O = Object.freeze({
	__proto__: null,
	CSSMetadata: m,
	CSSWideKeywords: f,
	VariableNameRegex: /(\s*--.*?)/gs,
	VariableRegex: b,
	CustomVariableRegex: /(var\(*--[\w\d]+-([\w]+-[\w]+)\))/g,
	URLRegex: /url\(\s*('.+?'|".+?"|[^)]+)\s*\)/g,
	GridAreaRowRegex: y,
	cssMetadata: I,
});
class A extends r.ProfileTreeModel.ProfileTreeModel {}
var N = Object.freeze({ __proto__: null, ProfileTreeModel: A });
class D {
	resourceType;
	mimeType;
	#h;
	#u;
	#g;
	constructor(e, t, n, r, s) {
		((this.resourceType = n),
			(this.mimeType = r),
			(this.#h = s),
			t ? (this.#u = e) : (this.#g = e));
	}
	get base64() {
		if (void 0 === this.#u)
			throw new Error("Encoding text content as base64 is not supported");
		return this.#u;
	}
	get text() {
		if (void 0 !== this.#g) return this.#g;
		if (!this.resourceType.isTextType())
			throw new Error("Cannot interpret binary data as text");
		const e = this.#h ?? "utf-8",
			t = window.atob(this.#u),
			n = Uint8Array.from(t, (e) => e.codePointAt(0));
		return ((this.#g = new TextDecoder(e).decode(n)), this.#g);
	}
	asDataUrl() {
		return void 0 !== this.#u
			? s.ContentProvider.contentAsDataURL(
					this.#u,
					this.mimeType ?? "",
					!0,
					this.#h ?? null
				)
			: s.ContentProvider.contentAsDataURL(this.text, this.mimeType ?? "", !1);
	}
	asDeferedContent() {
		return void 0 !== this.#u
			? { content: this.#u, isEncoded: !0 }
			: { content: this.text, isEncoded: !1 };
	}
	asLegacyContentData() {
		return void 0 !== this.#u
			? { error: null, content: this.#u, encoded: !0 }
			: { error: null, content: this.text, encoded: !1 };
	}
	static isError(e) {
		return "error" in e;
	}
	static asDeferredContent(e) {
		return D.isError(e)
			? { error: e.error, content: null, isEncoded: !1 }
			: e.asDeferedContent();
	}
	static asLegacyContentData(e) {
		return D.isError(e)
			? { error: e.error, content: null, encoded: !1 }
			: e.asLegacyContentData();
	}
}
var F = Object.freeze({ __proto__: null, ContentData: D });
const B = "<opaque>";
class U {
	#p;
	#m;
	#f;
	#b;
	#y;
	#v;
	#I;
	constructor(e, t, n, r) {
		((this.#p = e),
			(this.#m = t),
			(this.#f = n),
			(this.#b = {}),
			(this.#y = 0),
			(this.#v = r || "Medium"),
			(this.#I = null));
	}
	static fromProtocolCookie(e) {
		const t = new U(e.name, e.value, null, e.priority);
		return (
			t.addAttribute("domain", e.domain),
			t.addAttribute("path", e.path),
			e.expires && t.addAttribute("expires", 1e3 * e.expires),
			e.httpOnly && t.addAttribute("httpOnly"),
			e.secure && t.addAttribute("secure"),
			e.sameSite && t.addAttribute("sameSite", e.sameSite),
			"sourcePort" in e && t.addAttribute("sourcePort", e.sourcePort),
			"sourceScheme" in e && t.addAttribute("sourceScheme", e.sourceScheme),
			"partitionKey" in e && t.addAttribute("partitionKey", e.partitionKey),
			"partitionKeyOpaque" in e &&
				e.partitionKeyOpaque &&
				t.addAttribute("partitionKey", B),
			t.setSize(e.size),
			t
		);
	}
	key() {
		return (
			(this.domain() || "-") +
			" " +
			this.name() +
			" " +
			(this.path() || "-") +
			" " +
			(this.partitionKey() || "-")
		);
	}
	name() {
		return this.#p;
	}
	value() {
		return this.#m;
	}
	type() {
		return this.#f;
	}
	httpOnly() {
		return "httponly" in this.#b;
	}
	secure() {
		return "secure" in this.#b;
	}
	sameSite() {
		return this.#b.samesite;
	}
	partitionKey() {
		return this.#b.partitionkey;
	}
	setPartitionKey(e) {
		this.addAttribute("partitionKey", e);
	}
	partitionKeyOpaque() {
		return this.#b.partitionkey === B;
	}
	setPartitionKeyOpaque() {
		this.addAttribute("partitionKey", B);
	}
	priority() {
		return this.#v;
	}
	session() {
		return !("expires" in this.#b || "max-age" in this.#b);
	}
	path() {
		return this.#b.path;
	}
	domain() {
		return this.#b.domain;
	}
	expires() {
		return this.#b.expires;
	}
	maxAge() {
		return this.#b["max-age"];
	}
	sourcePort() {
		return this.#b.sourceport;
	}
	sourceScheme() {
		return this.#b.sourcescheme;
	}
	size() {
		return this.#y;
	}
	url() {
		if (!this.domain() || !this.path()) return null;
		let e = "";
		const t = this.sourcePort();
		return (
			t && 80 !== t && 443 !== t && (e = `:${this.sourcePort()}`),
			(this.secure() ? "https://" : "http://") + this.domain() + e + this.path()
		);
	}
	setSize(e) {
		this.#y = e;
	}
	expiresDate(e) {
		return this.maxAge()
			? new Date(e.getTime() + 1e3 * this.maxAge())
			: this.expires()
				? new Date(this.expires())
				: null;
	}
	addAttribute(e, t) {
		const n = e.toLowerCase();
		if ("priority" === n) this.#v = t;
		else this.#b[n] = t;
	}
	setCookieLine(e) {
		this.#I = e;
	}
	getCookieLine() {
		return this.#I;
	}
	matchesSecurityOrigin(e) {
		const t = new URL(e).hostname;
		return U.isDomainMatch(this.domain(), t);
	}
	static isDomainMatch(e, t) {
		return (
			t === e ||
			(!(!e || "." !== e[0]) &&
				(e.substr(1) === t || (t.length > e.length && t.endsWith(e))))
		);
	}
}
var H, q;
(!(function (e) {
	((e[(e.Request = 0)] = "Request"), (e[(e.Response = 1)] = "Response"));
})(H || (H = {})),
	(function (e) {
		((e.Name = "name"),
			(e.Value = "value"),
			(e.Size = "size"),
			(e.Domain = "domain"),
			(e.Path = "path"),
			(e.Expires = "expires"),
			(e.HttpOnly = "httpOnly"),
			(e.Secure = "secure"),
			(e.SameSite = "sameSite"),
			(e.SourceScheme = "sourceScheme"),
			(e.SourcePort = "sourcePort"),
			(e.Priority = "priority"),
			(e.PartitionKey = "partitionKey"));
	})(q || (q = {})));
var _ = Object.freeze({
	__proto__: null,
	Cookie: U,
	get Type() {
		return H;
	},
	get Attributes() {
		return q;
	},
});
class z {
	#k;
	#S;
	#w;
	#C;
	#R;
	constructor(e) {
		((this.#k = e.fontFamily),
			(this.#S = e.fontVariationAxes || []),
			(this.#w = new Map()),
			(this.#C = e.src),
			(this.#R = e.fontDisplay));
		for (const e of this.#S) this.#w.set(e.tag, e);
	}
	getFontFamily() {
		return this.#k;
	}
	getSrc() {
		return this.#C;
	}
	getFontDisplay() {
		return this.#R;
	}
	getVariationAxisByTag(e) {
		return this.#w.get(e);
	}
}
var j = Object.freeze({ __proto__: null, CSSFontFace: z });
class W {
	text = "";
	range;
	styleSheetId;
	cssModel;
	constructor(e) {
		this.cssModel = e;
	}
	rebase(e) {
		this.styleSheetId === e.styleSheetId &&
			this.range &&
			(e.oldRange.equal(this.range)
				? this.reinitialize(e.payload)
				: (this.range = this.range.rebaseAfterTextEdit(
						e.oldRange,
						e.newRange
					)));
	}
	equal(e) {
		return (
			!!(this.styleSheetId && this.range && e.range) &&
			this.styleSheetId === e.styleSheetId &&
			this.range.equal(e.range)
		);
	}
	lineNumberInSource() {
		if (this.range)
			return this.header()?.lineNumberInSource(this.range.startLine);
	}
	columnNumberInSource() {
		if (this.range)
			return this.header()?.columnNumberInSource(
				this.range.startLine,
				this.range.startColumn
			);
	}
	header() {
		return this.styleSheetId
			? this.cssModel.styleSheetHeaderForId(this.styleSheetId)
			: null;
	}
	rawLocation() {
		const e = this.header();
		if (!e || void 0 === this.lineNumberInSource()) return null;
		const t = Number(this.lineNumberInSource());
		return new an(e, t, this.columnNumberInSource());
	}
}
var V = Object.freeze({ __proto__: null, CSSQuery: W });
class G extends W {
	name;
	physicalAxes;
	logicalAxes;
	static parseContainerQueriesPayload(e, t) {
		return t.map((t) => new G(e, t));
	}
	constructor(e, t) {
		(super(e), this.reinitialize(t));
	}
	reinitialize(e) {
		((this.text = e.text),
			(this.range = e.range ? s.TextRange.TextRange.fromObject(e.range) : null),
			(this.styleSheetId = e.styleSheetId),
			(this.name = e.name),
			(this.physicalAxes = e.physicalAxes),
			(this.logicalAxes = e.logicalAxes));
	}
	active() {
		return !0;
	}
	async getContainerForNode(e) {
		const t = await this.cssModel
			.domModel()
			.getContainerForNode(e, this.name, this.physicalAxes, this.logicalAxes);
		if (t) return new K(t);
	}
}
class K {
	containerNode;
	constructor(e) {
		this.containerNode = e;
	}
	async getContainerSizeDetails() {
		const e = await this.containerNode
			.domModel()
			.cssModel()
			.getComputedStyle(this.containerNode.id);
		if (!e) return;
		const t = e.get("container-type"),
			n = e.get("contain"),
			r = e.get("writing-mode");
		if (!t || !n || !r) return;
		const s = Q(`${t} ${n}`),
			i = $(s, r);
		let a, o;
		return (
			("Both" !== i && "Horizontal" !== i) || (a = e.get("width")),
			("Both" !== i && "Vertical" !== i) || (o = e.get("height")),
			{ queryAxis: s, physicalAxis: i, width: a, height: o }
		);
	}
}
const Q = (e) => {
		const t = e.split(" ");
		let n = !1,
			r = !1;
		for (const e of t) {
			if ("size" === e) return "size";
			((n = n || "inline-size" === e), (r = r || "block-size" === e));
		}
		return n && r ? "size" : n ? "inline-size" : r ? "block-size" : "";
	},
	$ = (e, t) => {
		const n = t.startsWith("vertical");
		switch (e) {
			case "":
				return "";
			case "size":
				return "Both";
			case "inline-size":
				return n ? "Vertical" : "Horizontal";
			case "block-size":
				return n ? "Horizontal" : "Vertical";
		}
	};
var X = Object.freeze({
	__proto__: null,
	CSSContainerQuery: G,
	CSSContainerQueryContainer: K,
	getQueryAxis: Q,
	getPhysicalAxisFromQueryAxis: $,
});
class J extends W {
	static parseLayerPayload(e, t) {
		return t.map((t) => new J(e, t));
	}
	constructor(e, t) {
		(super(e), this.reinitialize(t));
	}
	reinitialize(e) {
		((this.text = e.text),
			(this.range = e.range ? s.TextRange.TextRange.fromObject(e.range) : null),
			(this.styleSheetId = e.styleSheetId));
	}
	active() {
		return !0;
	}
}
var Y = Object.freeze({ __proto__: null, CSSLayer: J });
class Z {
	#T;
	#x;
	constructor(e) {
		((this.#T = e.active), (this.#x = []));
		for (let t = 0; t < e.expressions.length; ++t)
			this.#x.push(ee.parsePayload(e.expressions[t]));
	}
	static parsePayload(e) {
		return new Z(e);
	}
	active() {
		return this.#T;
	}
	expressions() {
		return this.#x;
	}
}
class ee {
	#m;
	#M;
	#P;
	#L;
	#E;
	constructor(e) {
		((this.#m = e.value),
			(this.#M = e.unit),
			(this.#P = e.feature),
			(this.#L = e.valueRange
				? s.TextRange.TextRange.fromObject(e.valueRange)
				: null),
			(this.#E = e.computedLength || null));
	}
	static parsePayload(e) {
		return new ee(e);
	}
	value() {
		return this.#m;
	}
	unit() {
		return this.#M;
	}
	feature() {
		return this.#P;
	}
	valueRange() {
		return this.#L;
	}
	computedLength() {
		return this.#E;
	}
}
class te extends W {
	source;
	sourceURL;
	mediaList;
	static parseMediaArrayPayload(e, t) {
		return t.map((t) => new te(e, t));
	}
	constructor(e, t) {
		(super(e), this.reinitialize(t));
	}
	reinitialize(e) {
		if (
			((this.text = e.text),
			(this.source = e.source),
			(this.sourceURL = e.sourceURL || ""),
			(this.range = e.range ? s.TextRange.TextRange.fromObject(e.range) : null),
			(this.styleSheetId = e.styleSheetId),
			(this.mediaList = null),
			e.mediaList)
		) {
			this.mediaList = [];
			for (let t = 0; t < e.mediaList.length; ++t)
				this.mediaList.push(Z.parsePayload(e.mediaList[t]));
		}
	}
	active() {
		if (!this.mediaList) return !0;
		for (let e = 0; e < this.mediaList.length; ++e)
			if (this.mediaList[e].active()) return !0;
		return !1;
	}
}
var ne = Object.freeze({
	__proto__: null,
	CSSMediaQuery: Z,
	CSSMediaQueryExpression: ee,
	CSSMedia: te,
	Source: {
		LINKED_SHEET: "linkedSheet",
		INLINE_SHEET: "inlineSheet",
		MEDIA_RULE: "mediaRule",
		IMPORT_RULE: "importRule",
	},
});
class re extends W {
	static parseScopesPayload(e, t) {
		return t.map((t) => new re(e, t));
	}
	constructor(e, t) {
		(super(e), this.reinitialize(t));
	}
	reinitialize(e) {
		((this.text = e.text),
			(this.range = e.range ? s.TextRange.TextRange.fromObject(e.range) : null),
			(this.styleSheetId = e.styleSheetId));
	}
	active() {
		return !0;
	}
}
var se = Object.freeze({ __proto__: null, CSSScope: re });
const ie = new Set(["inherit", "initial", "unset"]),
	ae = /[\x20-\x7E]{4}/,
	oe = new RegExp(
		`(?:'(${ae.source})')|(?:"(${ae.source})")\\s+(${/[+-]?(?:\d*\.)?\d+(?:[eE]\d+)?/.source})`
	);
const le = /^"(.+)"|'(.+)'$/;
function de(e) {
	return e.split(",").map((e) => e.trim());
}
function ce(e) {
	return e.replaceAll(/(\/\*(?:.|\s)*?\*\/)/g, "");
}
var he = Object.freeze({
	__proto__: null,
	parseFontVariationSettings: function (e) {
		if (ie.has(e.trim()) || "normal" === e.trim()) return [];
		const t = [];
		for (const n of de(ce(e))) {
			const e = n.match(oe);
			e && t.push({ tag: e[1] || e[2], value: parseFloat(e[3]) });
		}
		return t;
	},
	parseFontFamily: function (e) {
		if (ie.has(e.trim())) return [];
		const t = [];
		for (const n of de(ce(e))) {
			const e = n.match(le);
			e ? t.push(e[1] || e[2]) : t.push(n);
		}
		return t;
	},
	splitByComma: de,
	stripComments: ce,
});
class ue {
	ownerStyle;
	index;
	name;
	value;
	important;
	disabled;
	parsedOk;
	implicit;
	text;
	range;
	#O;
	#A;
	#L;
	#N;
	#D = [];
	constructor(e, t, n, r, i, a, o, l, d, c, h) {
		if (
			((this.ownerStyle = e),
			(this.index = t),
			(this.name = n),
			(this.value = r),
			(this.important = i),
			(this.disabled = a),
			(this.parsedOk = o),
			(this.implicit = l),
			(this.text = d),
			(this.range = c ? s.TextRange.TextRange.fromObject(c) : null),
			(this.#O = !0),
			(this.#A = null),
			(this.#L = null),
			h && h.length > 0)
		)
			for (const n of h)
				this.#D.push(new ue(e, ++t, n.name, n.value, i, a, o, !0));
		else {
			const r = I().getLonghands(n);
			for (const n of r || []) this.#D.push(new ue(e, ++t, n, "", i, a, o, !0));
		}
	}
	static parsePayload(e, t, n) {
		return new ue(
			e,
			t,
			n.name,
			n.value,
			n.important || !1,
			n.disabled || !1,
			!("parsedOk" in n) || Boolean(n.parsedOk),
			Boolean(n.implicit),
			n.text,
			n.range,
			n.longhandProperties
		);
	}
	ensureRanges() {
		if (this.#A && this.#L) return;
		const e = this.range,
			t = this.text ? new s.Text.Text(this.text) : null;
		if (!e || !t) return;
		const n = t.value().indexOf(this.name),
			r = t.value().lastIndexOf(this.value);
		if (-1 === n || -1 === r || n > r) return;
		const i = new s.TextRange.SourceRange(n, this.name.length),
			a = new s.TextRange.SourceRange(r, this.value.length);
		function o(e, t, n) {
			return (
				0 === e.startLine && ((e.startColumn += n), (e.endColumn += n)),
				(e.startLine += t),
				(e.endLine += t),
				e
			);
		}
		((this.#A = o(t.toTextRange(i), e.startLine, e.startColumn)),
			(this.#L = o(t.toTextRange(a), e.startLine, e.startColumn)));
	}
	nameRange() {
		return (this.ensureRanges(), this.#A);
	}
	valueRange() {
		return (this.ensureRanges(), this.#L);
	}
	rebase(e) {
		this.ownerStyle.styleSheetId === e.styleSheetId &&
			this.range &&
			(this.range = this.range.rebaseAfterTextEdit(e.oldRange, e.newRange));
	}
	setActive(e) {
		this.#O = e;
	}
	get propertyText() {
		return void 0 !== this.text
			? this.text
			: "" === this.name
				? ""
				: this.name +
					": " +
					this.value +
					(this.important ? " !important" : "") +
					";";
	}
	activeInStyle() {
		return this.#O;
	}
	trimmedValueWithoutImportant() {
		const e = "!important";
		return this.value.endsWith(e)
			? this.value.slice(0, -10).trim()
			: this.value.trim();
	}
	async setText(n, r, i) {
		if (!this.ownerStyle) throw new Error("No ownerStyle for property");
		if (!this.ownerStyle.styleSheetId) throw new Error("No owner style id");
		if (!this.range || !this.ownerStyle.range)
			throw new Error("Style not editable");
		if (
			(r &&
				(o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited),
				this.ownerStyle.parentRule?.isKeyframeRule() &&
					o.userMetrics.actionTaken(
						o.UserMetrics.Action.StylePropertyInsideKeyframeEdited
					),
				this.name.startsWith("--") &&
					o.userMetrics.actionTaken(o.UserMetrics.Action.CustomPropertyEdited)),
			i && n === this.propertyText)
		)
			return (this.ownerStyle.cssModel().domModel().markUndoableState(!r), !0);
		const a = this.range.relativeTo(
				this.ownerStyle.range.startLine,
				this.ownerStyle.range.startColumn
			),
			l = this.ownerStyle.cssText
				? this.detectIndentation(this.ownerStyle.cssText)
				: e.Settings.Settings.instance()
						.moduleSetting("textEditorIndent")
						.get(),
			d = this.ownerStyle.cssText
				? l.substring(0, this.ownerStyle.range.endColumn)
				: "",
			c = new s.Text.Text(this.ownerStyle.cssText || "").replaceRange(
				a,
				t.StringUtilities.sprintf(";%s;", n)
			),
			h = await ue.formatStyle(c, l, d);
		return this.ownerStyle.setText(h, r);
	}
	static async formatStyle(e, t, n) {
		const r = t.substring(n.length) + t;
		t && (t = "\n" + t);
		let i = "",
			a = "",
			o = "",
			l = !1,
			d = !1;
		const c = s.CodeMirrorUtils.createCssTokenizer();
		return (
			await c("*{" + e + "}", function (e, n) {
				if (!l) {
					const r =
							n?.includes("comment") &&
							(function (e) {
								const t = e.indexOf(":");
								if (-1 === t) return !1;
								const n = e.substring(2, t).trim();
								return I().isCSSPropertyName(n);
							})(e),
						s =
							n?.includes("string") ||
							n?.includes("meta") ||
							n?.includes("property") ||
							(n?.includes("variableName") && "variableName.function" !== n);
					return (
						r
							? (i = i.trimEnd() + t + e)
							: s
								? ((l = !0), (o = e))
								: (";" !== e || d) &&
									((i += e),
									e.trim() && !n?.includes("comment") && (d = ";" !== e)),
						void ("{" !== e || n || (d = !1))
					);
				}
				if ("}" === e || ";" === e) {
					const n = o.trim();
					return (
						(i = i.trimEnd() + t + n + (n.endsWith(":") ? " " : "") + e),
						(d = !1),
						(l = !1),
						void (a = "")
					);
				}
				if (I().isGridAreaDefiningProperty(a)) {
					const t = y.exec(e);
					t &&
						0 === t.index &&
						!o.trimEnd().endsWith("]") &&
						(o = o.trimEnd() + "\n" + r);
				}
				a || ":" !== e || (a = o);
				o += e;
			}),
			l && (i += o),
			(i = i.substring(2, i.length - 1).trimEnd()),
			i + (t ? "\n" + n : "")
		);
	}
	detectIndentation(e) {
		const t = e.split("\n");
		return t.length < 2 ? "" : s.TextUtils.Utils.lineIndent(t[1]);
	}
	setValue(e, t, n, r) {
		const s =
			this.name + ": " + e + (this.important ? " !important" : "") + ";";
		this.setText(s, t, n).then(r);
	}
	async setDisabled(e) {
		if (!this.ownerStyle) return !1;
		if (e === this.disabled) return !0;
		if (!this.text) return !0;
		const t = this.text.trim(),
			n = (e) => e + (e.endsWith(";") ? "" : ";");
		let r;
		return (
			(r = e
				? "/* " + n(ce(t)) + " */"
				: n(this.text.substring(2, t.length - 2).trim())),
			this.setText(r, !0, !0)
		);
	}
	setDisplayedStringForInvalidProperty(e) {
		this.#N = e;
	}
	getInvalidStringForInvalidProperty() {
		return this.#N;
	}
	getLonghandProperties() {
		return this.#D;
	}
}
var ge,
	pe = Object.freeze({ __proto__: null, CSSProperty: ue });
class me {
	#F;
	parentRule;
	#B;
	styleSheetId;
	range;
	cssText;
	#U;
	#H;
	#q;
	#_;
	type;
	constructor(e, t, n, r) {
		((this.#F = e), (this.parentRule = t), this.#z(n), (this.type = r));
	}
	rebase(e) {
		if (this.styleSheetId === e.styleSheetId && this.range)
			if (e.oldRange.equal(this.range)) this.#z(e.payload);
			else {
				this.range = this.range.rebaseAfterTextEdit(e.oldRange, e.newRange);
				for (let t = 0; t < this.#B.length; ++t) this.#B[t].rebase(e);
			}
	}
	#z(e) {
		((this.styleSheetId = e.styleSheetId),
			(this.range = e.range
				? s.TextRange.TextRange.fromObject(e.range)
				: null));
		const t = e.shorthandEntries;
		((this.#U = new Map()), (this.#H = new Set()));
		for (let e = 0; e < t.length; ++e)
			(this.#U.set(t[e].name, t[e].value),
				t[e].important && this.#H.add(t[e].name));
		if (((this.#B = []), e.cssText && this.range)) {
			const t = [];
			for (const n of e.cssProperties) {
				if (!n.range) continue;
				const e = ue.parsePayload(this, this.#B.length, n);
				this.#B.push(e);
				for (const n of e.getLonghandProperties()) t.push(n);
			}
			for (const e of t) ((e.index = this.#B.length), this.#B.push(e));
		} else
			for (const t of e.cssProperties)
				this.#B.push(ue.parsePayload(this, this.#B.length, t));
		(this.#j(), this.#W(), (this.#q = new Map()));
		for (const e of this.#B) e.activeInStyle() && this.#q.set(e.name, e);
		((this.cssText = e.cssText), (this.#_ = null));
	}
	#j() {
		if (this.range) return;
		if (!this.#U.size) return;
		const e = new Set();
		for (const t of this.#B) e.add(t.name);
		const t = [];
		for (const n of this.#B) {
			const r = I().getShorthands(n.name) || [];
			for (const n of r) {
				if (e.has(n)) continue;
				const r = this.#U.get(n);
				if (!r) continue;
				const s = Boolean(this.#H.has(n)),
					i = new ue(this, this.allProperties().length, n, r, s, !1, !0, !1);
				(t.push(i), e.add(n));
			}
		}
		this.#B = this.#B.concat(t);
	}
	#V() {
		if (this.range)
			return this.#B.filter(function (e) {
				return Boolean(e.range);
			});
		const e = [];
		for (const t of this.#B) {
			const n = I().getShorthands(t.name) || [];
			let r = !1;
			for (const e of n)
				if (this.#U.get(e)) {
					r = !0;
					break;
				}
			r || e.push(t);
		}
		return e;
	}
	leadingProperties() {
		return (this.#_ || (this.#_ = this.#V()), this.#_);
	}
	target() {
		return this.#F.target();
	}
	cssModel() {
		return this.#F;
	}
	#W() {
		const e = new Map(),
			t = new Set();
		for (const n of this.#B) {
			if (n.disabled || !n.parsedOk) {
				n.setActive(!1);
				continue;
			}
			if (t.has(n)) continue;
			const r = I().canonicalPropertyName(n.name);
			for (const r of n.getLonghandProperties()) {
				const n = e.get(r.name);
				(n
					? !n.important || r.important
						? (n.setActive(!1), e.set(r.name, r))
						: r.setActive(!1)
					: e.set(r.name, r),
					t.add(r));
			}
			const s = e.get(r);
			s
				? !s.important || n.important
					? (s.setActive(!1), e.set(r, n))
					: n.setActive(!1)
				: e.set(r, n);
		}
	}
	allProperties() {
		return this.#B;
	}
	hasActiveProperty(e) {
		return this.#q.has(e);
	}
	getPropertyValue(e) {
		const t = this.#q.get(e);
		return t ? t.value : "";
	}
	isPropertyImplicit(e) {
		const t = this.#q.get(e);
		return !!t && t.implicit;
	}
	propertyAt(e) {
		return e < this.allProperties().length ? this.allProperties()[e] : null;
	}
	pastLastSourcePropertyIndex() {
		for (let e = this.allProperties().length - 1; e >= 0; --e)
			if (this.allProperties()[e].range) return e + 1;
		return 0;
	}
	#G(e) {
		const t = this.propertyAt(e);
		if (t && t.range) return t.range.collapseToStart();
		if (!this.range) throw new Error("CSSStyleDeclaration.range is null");
		return this.range.collapseToEnd();
	}
	newBlankProperty(e) {
		e = void 0 === e ? this.pastLastSourcePropertyIndex() : e;
		return new ue(this, e, "", "", !1, !1, !0, !1, "", this.#G(e));
	}
	setText(e, t) {
		return this.range && this.styleSheetId
			? this.#F.setStyleText(this.styleSheetId, this.range, e, t)
			: Promise.resolve(!1);
	}
	insertPropertyAt(e, t, n, r) {
		this.newBlankProperty(e)
			.setText(t + ": " + n + ";", !1, !0)
			.then(r);
	}
	appendProperty(e, t, n) {
		this.insertPropertyAt(this.allProperties().length, e, t, n);
	}
}
!(function (e) {
	((e.Regular = "Regular"),
		(e.Inline = "Inline"),
		(e.Attributes = "Attributes"),
		(e.Pseudo = "Pseudo"));
})(ge || (ge = {}));
var fe = Object.freeze({
	__proto__: null,
	CSSStyleDeclaration: me,
	get Type() {
		return ge;
	},
});
class be extends W {
	static parseSupportsPayload(e, t) {
		return t.map((t) => new be(e, t));
	}
	#O = !0;
	constructor(e, t) {
		(super(e), this.reinitialize(t));
	}
	reinitialize(e) {
		((this.text = e.text),
			(this.range = e.range ? s.TextRange.TextRange.fromObject(e.range) : null),
			(this.styleSheetId = e.styleSheetId),
			(this.#O = e.active));
	}
	active() {
		return this.#O;
	}
}
var ye = Object.freeze({ __proto__: null, CSSSupports: be });
class ve {
	cssModelInternal;
	styleSheetId;
	sourceURL;
	origin;
	style;
	constructor(e, t) {
		if (
			((this.cssModelInternal = e),
			(this.styleSheetId = t.styleSheetId),
			this.styleSheetId)
		) {
			const e = this.getStyleSheetHeader(this.styleSheetId);
			this.sourceURL = e.sourceURL;
		}
		((this.origin = t.origin),
			(this.style = new me(this.cssModelInternal, this, t.style, ge.Regular)));
	}
	rebase(e) {
		this.styleSheetId === e.styleSheetId && this.style.rebase(e);
	}
	resourceURL() {
		if (!this.styleSheetId) return t.DevToolsPath.EmptyUrlString;
		return this.getStyleSheetHeader(this.styleSheetId).resourceURL();
	}
	isUserAgent() {
		return "user-agent" === this.origin;
	}
	isInjected() {
		return "injected" === this.origin;
	}
	isViaInspector() {
		return "inspector" === this.origin;
	}
	isRegular() {
		return "regular" === this.origin;
	}
	isKeyframeRule() {
		return !1;
	}
	cssModel() {
		return this.cssModelInternal;
	}
	getStyleSheetHeader(e) {
		const t = this.cssModelInternal.styleSheetHeaderForId(e);
		return (console.assert(null !== t), t);
	}
}
class Ie {
	text;
	range;
	specificity;
	constructor(e) {
		((this.text = e.text),
			e.range && (this.range = s.TextRange.TextRange.fromObject(e.range)),
			e.specificity && (this.specificity = e.specificity));
	}
	rebase(e) {
		this.range &&
			(this.range = this.range.rebaseAfterTextEdit(e.oldRange, e.newRange));
	}
}
class ke extends ve {
	selectors;
	nestingSelectors;
	media;
	containerQueries;
	supports;
	scopes;
	layers;
	ruleTypes;
	wasUsed;
	constructor(e, t, n) {
		(super(e, {
			origin: t.origin,
			style: t.style,
			styleSheetId: t.styleSheetId,
		}),
			this.reinitializeSelectors(t.selectorList),
			(this.nestingSelectors = t.nestingSelectors),
			(this.media = t.media ? te.parseMediaArrayPayload(e, t.media) : []),
			(this.containerQueries = t.containerQueries
				? G.parseContainerQueriesPayload(e, t.containerQueries)
				: []),
			(this.scopes = t.scopes ? re.parseScopesPayload(e, t.scopes) : []),
			(this.supports = t.supports
				? be.parseSupportsPayload(e, t.supports)
				: []),
			(this.layers = t.layers ? J.parseLayerPayload(e, t.layers) : []),
			(this.ruleTypes = t.ruleTypes || []),
			(this.wasUsed = n || !1));
	}
	static createDummyRule(e, t) {
		const n = {
			selectorList: { text: "", selectors: [{ text: t, value: void 0 }] },
			style: {
				styleSheetId: "0",
				range: new s.TextRange.TextRange(0, 0, 0, 0),
				shorthandEntries: [],
				cssProperties: [],
			},
			origin: "inspector",
		};
		return new ke(e, n);
	}
	reinitializeSelectors(e) {
		this.selectors = [];
		for (let t = 0; t < e.selectors.length; ++t)
			this.selectors.push(new Ie(e.selectors[t]));
	}
	setSelectorText(e) {
		const t = this.styleSheetId;
		if (!t) throw "No rule stylesheet id";
		const n = this.selectorRange();
		if (!n) throw "Rule selector is not editable";
		return this.cssModelInternal.setSelectorText(t, n, e);
	}
	selectorText() {
		return this.selectors.map((e) => e.text).join(", ");
	}
	selectorRange() {
		if (0 === this.selectors.length) return null;
		const e = this.selectors[0].range,
			t = this.selectors[this.selectors.length - 1].range;
		return e && t
			? new s.TextRange.TextRange(
					e.startLine,
					e.startColumn,
					t.endLine,
					t.endColumn
				)
			: null;
	}
	lineNumberInSource(e) {
		const t = this.selectors[e];
		if (!t || !t.range || !this.styleSheetId) return 0;
		return this.getStyleSheetHeader(this.styleSheetId).lineNumberInSource(
			t.range.startLine
		);
	}
	columnNumberInSource(e) {
		const t = this.selectors[e];
		if (!t || !t.range || !this.styleSheetId) return;
		return this.getStyleSheetHeader(this.styleSheetId).columnNumberInSource(
			t.range.startLine,
			t.range.startColumn
		);
	}
	rebase(e) {
		if (this.styleSheetId !== e.styleSheetId) return;
		const t = this.selectorRange();
		if (t && t.equal(e.oldRange)) this.reinitializeSelectors(e.payload);
		else
			for (let t = 0; t < this.selectors.length; ++t)
				this.selectors[t].rebase(e);
		(this.media.forEach((t) => t.rebase(e)),
			this.containerQueries.forEach((t) => t.rebase(e)),
			this.scopes.forEach((t) => t.rebase(e)),
			this.supports.forEach((t) => t.rebase(e)),
			super.rebase(e));
	}
}
class Se extends ve {
	#K;
	constructor(e, t) {
		(super(e, {
			origin: t.origin,
			style: t.style,
			styleSheetId: t.styleSheetId,
		}),
			(this.#K = new Ie(t.propertyName)));
	}
	propertyName() {
		return this.#K;
	}
	initialValue() {
		return this.style.hasActiveProperty("initial-value")
			? this.style.getPropertyValue("initial-value")
			: null;
	}
	syntax() {
		return this.style.getPropertyValue("syntax");
	}
	inherits() {
		return "true" === this.style.getPropertyValue("inherits");
	}
	setPropertyName(e) {
		const t = this.styleSheetId;
		if (!t) throw new Error("No rule stylesheet id");
		const n = this.#K.range;
		if (!n) throw new Error("Property name is not editable");
		return this.cssModelInternal.setPropertyRulePropertyName(t, n, e);
	}
}
class we extends ve {
	#Q;
	constructor(e, t) {
		(super(e, {
			origin: t.origin,
			style: t.style,
			styleSheetId: t.styleSheetId,
		}),
			(this.#Q = new Ie(t.fontPaletteName)));
	}
	name() {
		return this.#Q;
	}
}
class Ce {
	#$;
	#X;
	constructor(e, t) {
		((this.#$ = new Ie(t.animationName)),
			(this.#X = t.keyframes.map((t) => new Re(e, t))));
	}
	name() {
		return this.#$;
	}
	keyframes() {
		return this.#X;
	}
}
class Re extends ve {
	#J;
	constructor(e, t) {
		(super(e, {
			origin: t.origin,
			style: t.style,
			styleSheetId: t.styleSheetId,
		}),
			this.reinitializeKey(t.keyText));
	}
	key() {
		return this.#J;
	}
	reinitializeKey(e) {
		this.#J = new Ie(e);
	}
	rebase(e) {
		this.styleSheetId === e.styleSheetId &&
			this.#J.range &&
			(e.oldRange.equal(this.#J.range)
				? this.reinitializeKey(e.payload)
				: this.#J.rebase(e),
			super.rebase(e));
	}
	isKeyframeRule() {
		return !0;
	}
	setKeyText(e) {
		const t = this.styleSheetId;
		if (!t) throw "No rule stylesheet id";
		const n = this.#J.range;
		if (!n) throw "Keyframe key is not editable";
		return this.cssModelInternal.setKeyframeKey(t, n, e);
	}
}
class Te {
	#K;
	#Y;
	constructor(e, t) {
		((this.#K = new Ie(t.name)),
			(this.#Y = t.tryRules.map(
				(t) =>
					new ve(e, {
						origin: t.origin,
						style: t.style,
						styleSheetId: t.styleSheetId,
					})
			)));
	}
	name() {
		return this.#K;
	}
	tryRules() {
		return this.#Y;
	}
}
var xe,
	Me = Object.freeze({
		__proto__: null,
		CSSRule: ve,
		CSSStyleRule: ke,
		CSSPropertyRule: Se,
		CSSFontPaletteValuesRule: we,
		CSSKeyframesRule: Ce,
		CSSKeyframeRule: Re,
		CSSPositionFallbackRule: Te,
	});
function Pe(e) {
	const t = e.match(/var\(\s*(--(?:[\s\w\P{ASCII}-]|\\.)+),?\s*(.*)\s*\)/u);
	return { variableName: t && t[1].trim(), fallback: t && t[2] };
}
function Le(e, t) {
	if (!t.styleSheetId || !t.range) return !1;
	for (const n of e)
		if (t.styleSheetId === n.styleSheetId && n.range && t.range.equal(n.range))
			return !0;
	return !1;
}
function Ee(e) {
	const t = e.allProperties();
	for (let e = 0; e < t.length; ++e) {
		const n = t[e];
		if (n.activeInStyle() && I().isPropertyInherited(n.name)) return !0;
	}
	return !1;
}
function Oe(e) {
	for (const t of e) s(t);
	const t = [];
	for (const s of e) {
		const e = t[t.length - 1];
		e &&
		"user-agent" === s.rule.origin &&
		"user-agent" === e.rule.origin &&
		s.rule.selectorList.text === e.rule.selectorList.text &&
		r(s) === r(e)
			? n(s, e)
			: t.push(s);
	}
	return t;
	function n(e, t) {
		const n = new Map(),
			r = new Map();
		for (const e of t.rule.style.shorthandEntries) n.set(e.name, e.value);
		for (const e of t.rule.style.cssProperties) r.set(e.name, e.value);
		for (const t of e.rule.style.shorthandEntries) n.set(t.name, t.value);
		for (const t of e.rule.style.cssProperties) r.set(t.name, t.value);
		((t.rule.style.shorthandEntries = [...n.entries()].map(([e, t]) => ({
			name: e,
			value: t,
		}))),
			(t.rule.style.cssProperties = [...r.entries()].map(([e, t]) => ({
				name: e,
				value: t,
			}))));
	}
	function r(e) {
		return e.rule.media ? e.rule.media.map((e) => e.text).join(", ") : null;
	}
	function s(e) {
		const { matchingSelectors: t, rule: n } = e;
		"user-agent" === n.origin &&
			t.length &&
			((n.selectorList.selectors = n.selectorList.selectors.filter((e, n) =>
				t.includes(n)
			)),
			(n.selectorList.text = n.selectorList.selectors
				.map((e) => e.text)
				.join(", ")),
			(e.matchingSelectors = t.map((e, t) => t)));
	}
}
function Ae(e) {
	const t = new Map();
	for (let n = 0; n < e.matchingSelectors.length; n++) {
		const r = e.matchingSelectors[n],
			s = e.rule.selectorList.selectors[r].text.match(/::highlight\((.*)\)/);
		if (s) {
			const e = s[1],
				n = t.get(e);
			n ? n.push(r) : t.set(e, [r]);
		}
	}
	return t;
}
class Ne {
	#Z;
	#ee;
	#te;
	constructor(e, t) {
		((this.#ee = e), (this.#Z = t));
	}
	isAtProperty() {
		return this.#Z instanceof Se;
	}
	propertyName() {
		return this.#Z instanceof Se
			? this.#Z.propertyName().text
			: this.#Z.propertyName;
	}
	initialValue() {
		return this.#Z instanceof Se
			? this.#Z.initialValue()
			: (this.#Z.initialValue?.text ?? null);
	}
	inherits() {
		return this.#Z instanceof Se ? this.#Z.inherits() : this.#Z.inherits;
	}
	syntax() {
		return this.#Z instanceof Se ? this.#Z.syntax() : `"${this.#Z.syntax}"`;
	}
	#ne() {
		if (this.#Z instanceof Se) return [];
		const { inherits: e, initialValue: t, syntax: n } = this.#Z,
			r = [
				{ name: "inherits", value: `${e}` },
				{ name: "syntax", value: `"${n}"` },
			];
		return (
			void 0 !== t && r.push({ name: "initial-value", value: t.text }),
			r
		);
	}
	style() {
		return (
			this.#te ||
				(this.#te =
					this.#Z instanceof Se
						? this.#Z.style
						: new me(
								this.#ee,
								null,
								{ cssProperties: this.#ne(), shorthandEntries: [] },
								ge.Pseudo
							)),
			this.#te
		);
	}
}
class De {
	#F;
	#re;
	#se;
	#ie;
	#X;
	#ae;
	#oe = new Map();
	#le;
	#de;
	#ce;
	#he;
	#ue;
	#ge;
	#pe;
	#me;
	#fe;
	static async create(e) {
		const t = new De(e);
		return (await t.init(e), t);
	}
	constructor({
		cssModel: e,
		node: t,
		animationsPayload: n,
		parentLayoutNodeId: r,
		positionFallbackRules: s,
		propertyRules: i,
		cssPropertyRegistrations: a,
		fontPaletteValuesRule: o,
	}) {
		((this.#F = e),
			(this.#re = t),
			(this.#se = new Map()),
			(this.#ie = new Map()),
			(this.#ae = [...i.map((t) => new Se(e, t)), ...a].map(
				(t) => new Ne(e, t)
			)),
			(this.#X = []),
			n && (this.#X = n.map((t) => new Ce(e, t))),
			(this.#ue = s.map((t) => new Te(e, t))),
			(this.#he = r),
			(this.#fe = o ? new we(e, o) : void 0),
			(this.#le = new Map()),
			(this.#de = new Set()),
			(this.#ce = new Map()),
			(this.#oe = new Map()));
	}
	async init({
		matchedPayload: e,
		inheritedPayload: t,
		inlinePayload: n,
		attributesPayload: r,
		pseudoPayload: s,
		inheritedPseudoPayload: i,
	}) {
		e = Oe(e);
		for (const e of t) e.matchedCSSRules = Oe(e.matchedCSSRules);
		((this.#ge = await this.buildMainCascade(n, r, e, t)),
			([this.#pe, this.#me] = this.buildPseudoCascades(s, i)));
		for (const e of Array.from(this.#me.values())
			.concat(Array.from(this.#pe.values()))
			.concat(this.#ge))
			for (const t of e.styles()) this.#ce.set(t, e);
		for (const e of this.#ae) this.#oe.set(e.propertyName(), e);
	}
	async buildMainCascade(e, t, n, r) {
		const s = [],
			i = [];
		function a() {
			if (!t) return;
			const e = new me(this.#F, null, t, ge.Attributes);
			(this.#le.set(e, this.#re), i.push(e));
		}
		if (e && this.#re.nodeType() === Node.ELEMENT_NODE) {
			const t = new me(this.#F, null, e, ge.Inline);
			(this.#le.set(t, this.#re), i.push(t));
		}
		let o;
		for (let e = n.length - 1; e >= 0; --e) {
			const t = new ke(this.#F, n[e].rule);
			((!t.isInjected() && !t.isUserAgent()) || o || ((o = !0), a.call(this)),
				this.#le.set(t.style, this.#re),
				i.push(t.style),
				this.addMatchingSelectors(this.#re, t, n[e].matchingSelectors));
		}
		(o || a.call(this), s.push(new Fe(this, i, !1)));
		let l = this.#re.parentNode;
		const d = async (e) =>
			e.hasAssignedSlot()
				? ((await e.assignedSlot?.deferredNode.resolvePromise()) ?? null)
				: e.parentNode;
		for (let e = 0; l && r && e < r.length; ++e) {
			const t = [],
				n = r[e],
				a = n.inlineStyle
					? new me(this.#F, null, n.inlineStyle, ge.Inline)
					: null;
			a && Ee(a) && (this.#le.set(a, l), t.push(a), this.#de.add(a));
			const o = n.matchedCSSRules || [];
			for (let e = o.length - 1; e >= 0; --e) {
				const n = new ke(this.#F, o[e].rule);
				(this.addMatchingSelectors(l, n, o[e].matchingSelectors),
					Ee(n.style) &&
						(Le(i, n.style) ||
							Le(this.#de, n.style) ||
							(this.#le.set(n.style, l),
							t.push(n.style),
							this.#de.add(n.style))));
			}
			((l = await d(l)), s.push(new Fe(this, t, !0)));
		}
		return new Be(s, this.#ae);
	}
	buildSplitCustomHighlightCascades(e, t, n, r) {
		const s = new Map();
		for (let r = e.length - 1; r >= 0; --r) {
			const i = Ae(e[r]);
			for (const [a, o] of i) {
				const i = new ke(this.#F, e[r].rule);
				(this.#le.set(i.style, t),
					n && this.#de.add(i.style),
					this.addMatchingSelectors(t, i, o));
				const l = s.get(a);
				l ? l.push(i.style) : s.set(a, [i.style]);
			}
		}
		for (const [e, t] of s) {
			const s = new Fe(this, t, n, !0),
				i = r.get(e);
			i ? i.push(s) : r.set(e, [s]);
		}
	}
	buildPseudoCascades(e, t) {
		const n = new Map(),
			r = new Map();
		if (!e) return [n, r];
		const s = new Map(),
			i = new Map();
		for (let t = 0; t < e.length; ++t) {
			const n = e[t],
				r = this.#re.pseudoElements().get(n.pseudoType)?.at(-1) || null,
				a = [],
				o = n.matches || [];
			if ("highlight" === n.pseudoType)
				this.buildSplitCustomHighlightCascades(o, this.#re, !1, i);
			else {
				for (let e = o.length - 1; e >= 0; --e) {
					const t = new ke(this.#F, o[e].rule);
					a.push(t.style);
					const s = I().isHighlightPseudoType(n.pseudoType) ? this.#re : r;
					(this.#le.set(t.style, s),
						s && this.addMatchingSelectors(s, t, o[e].matchingSelectors));
				}
				const e = I().isHighlightPseudoType(n.pseudoType),
					t = new Fe(this, a, !1, e);
				s.set(n.pseudoType, [t]);
			}
		}
		if (t) {
			let e = this.#re.parentNode;
			for (let n = 0; e && n < t.length; ++n) {
				const r = t[n].pseudoElements;
				for (let t = 0; t < r.length; ++t) {
					const n = r[t],
						a = n.matches || [];
					if ("highlight" === n.pseudoType)
						this.buildSplitCustomHighlightCascades(a, e, !0, i);
					else {
						const t = [];
						for (let n = a.length - 1; n >= 0; --n) {
							const r = new ke(this.#F, a[n].rule);
							(t.push(r.style),
								this.#le.set(r.style, e),
								this.#de.add(r.style),
								this.addMatchingSelectors(e, r, a[n].matchingSelectors));
						}
						const r = I().isHighlightPseudoType(n.pseudoType),
							i = new Fe(this, t, !0, r),
							o = s.get(n.pseudoType);
						o ? o.push(i) : s.set(n.pseudoType, [i]);
					}
				}
				e = e.parentNode;
			}
		}
		for (const [e, t] of s.entries()) n.set(e, new Be(t, this.#ae));
		for (const [e, t] of i.entries()) r.set(e, new Be(t, this.#ae));
		return [n, r];
	}
	addMatchingSelectors(e, t, n) {
		for (const r of n) {
			const n = t.selectors[r];
			n && this.setSelectorMatches(e, n.text, !0);
		}
	}
	node() {
		return this.#re;
	}
	cssModel() {
		return this.#F;
	}
	hasMatchingSelectors(e) {
		return (
			this.getMatchingSelectors(e).length > 0 &&
			(function (e) {
				if (!e.parentRule) return !0;
				const t = e.parentRule,
					n = [...t.media, ...t.containerQueries, ...t.supports, ...t.scopes];
				for (const e of n) if (!e.active()) return !1;
				return !0;
			})(e.style)
		);
	}
	getParentLayoutNodeId() {
		return this.#he;
	}
	getMatchingSelectors(e) {
		const t = this.nodeForStyle(e.style);
		if (!t || "number" != typeof t.id) return [];
		const n = this.#ie.get(t.id);
		if (!n) return [];
		const r = [];
		for (let t = 0; t < e.selectors.length; ++t)
			n.get(e.selectors[t].text) && r.push(t);
		return r;
	}
	async recomputeMatchingSelectors(e) {
		const t = this.nodeForStyle(e.style);
		if (!t) return;
		const n = [];
		for (const s of e.selectors) n.push(r.call(this, t, s.text));
		async function r(e, t) {
			const n = e.ownerDocument;
			if (!n) return;
			if ("number" == typeof e.id) {
				const n = this.#ie.get(e.id);
				if (n && n.has(t)) return;
			}
			if ("number" != typeof n.id) return;
			const r = await this.#re.domModel().querySelectorAll(n.id, t);
			r &&
				("number" == typeof e.id
					? this.setSelectorMatches(e, t, -1 !== r.indexOf(e.id))
					: this.setSelectorMatches(e, t, !1));
		}
		await Promise.all(n);
	}
	addNewRule(e, t) {
		return (this.#se.set(e.style, t), this.recomputeMatchingSelectors(e));
	}
	setSelectorMatches(e, t, n) {
		if ("number" != typeof e.id) return;
		let r = this.#ie.get(e.id);
		(r || ((r = new Map()), this.#ie.set(e.id, r)), r.set(t, n));
	}
	nodeStyles() {
		return (t.assertNotNullOrUndefined(this.#ge), this.#ge.styles());
	}
	registeredProperties() {
		return this.#ae;
	}
	getRegisteredProperty(e) {
		return this.#oe.get(e);
	}
	fontPaletteValuesRule() {
		return this.#fe;
	}
	keyframes() {
		return this.#X;
	}
	positionFallbackRules() {
		return this.#ue;
	}
	pseudoStyles(e) {
		t.assertNotNullOrUndefined(this.#pe);
		const n = this.#pe.get(e);
		return n ? n.styles() : [];
	}
	pseudoTypes() {
		return (t.assertNotNullOrUndefined(this.#pe), new Set(this.#pe.keys()));
	}
	customHighlightPseudoStyles(e) {
		t.assertNotNullOrUndefined(this.#me);
		const n = this.#me.get(e);
		return n ? n.styles() : [];
	}
	customHighlightPseudoNames() {
		return (t.assertNotNullOrUndefined(this.#me), new Set(this.#me.keys()));
	}
	nodeForStyle(e) {
		return this.#se.get(e) || this.#le.get(e) || null;
	}
	availableCSSVariables(e) {
		const t = this.#ce.get(e) || null;
		return t ? t.findAvailableCSSVariables(e) : [];
	}
	computeCSSVariable(e, t) {
		const n = this.#ce.get(e) || null;
		return n ? n.computeCSSVariable(e, t) : null;
	}
	computeValue(e, t) {
		const n = this.#ce.get(e) || null;
		return n ? n.computeValue(e, t) : null;
	}
	computeSingleVariableValue(e, t) {
		const n = this.#ce.get(e) || null;
		return n ? n.computeSingleVariableValue(e, t) : null;
	}
	isInherited(e) {
		return this.#de.has(e);
	}
	propertyState(e) {
		const t = this.#ce.get(e.ownerStyle);
		return t ? t.propertyState(e) : null;
	}
	resetActiveProperties() {
		(t.assertNotNullOrUndefined(this.#ge),
			t.assertNotNullOrUndefined(this.#pe),
			t.assertNotNullOrUndefined(this.#me),
			this.#ge.reset());
		for (const e of this.#pe.values()) e.reset();
		for (const e of this.#me.values()) e.reset();
	}
}
class Fe {
	#be;
	styles;
	#ye;
	#ve;
	propertiesState;
	activeProperties;
	constructor(e, t, n, r = !1) {
		((this.#be = e),
			(this.styles = t),
			(this.#ye = n),
			(this.#ve = r),
			(this.propertiesState = new Map()),
			(this.activeProperties = new Map()));
	}
	computeActiveProperties() {
		(this.propertiesState.clear(), this.activeProperties.clear());
		for (let e = this.styles.length - 1; e >= 0; e--) {
			const t = this.styles[e],
				n = t.parentRule;
			if ((!n || n instanceof ke) && (!n || this.#be.hasMatchingSelectors(n)))
				for (const e of t.allProperties()) {
					const n = I();
					if (this.#ye && !this.#ve && !n.isPropertyInherited(e.name)) continue;
					if (t.range && !e.range) continue;
					if (!e.activeInStyle()) {
						this.propertiesState.set(e, xe.Overloaded);
						continue;
					}
					if (this.#ye) {
						const t = this.#be.getRegisteredProperty(e.name);
						if (t && !t.inherits()) {
							this.propertiesState.set(e, xe.Overloaded);
							continue;
						}
					}
					const r = n.canonicalPropertyName(e.name);
					this.updatePropertyState(e, r);
					for (const t of e.getLonghandProperties())
						n.isCSSPropertyName(t.name) && this.updatePropertyState(t, t.name);
				}
		}
	}
	updatePropertyState(e, t) {
		const n = this.activeProperties.get(t);
		!n?.important || e.important
			? (n && this.propertiesState.set(n, xe.Overloaded),
				this.propertiesState.set(e, xe.Active),
				this.activeProperties.set(t, e))
			: this.propertiesState.set(e, xe.Overloaded);
	}
}
class Be {
	#Ie;
	#ke;
	#Se;
	#we;
	#Ce;
	#Re;
	#ae;
	constructor(e, t) {
		((this.#Ie = e),
			(this.#ke = new Map()),
			(this.#Se = new Map()),
			(this.#we = new Map()),
			(this.#Ce = !1),
			(this.#ae = t),
			(this.#Re = new Map()));
		for (const t of e) for (const e of t.styles) this.#Re.set(e, t);
	}
	findAvailableCSSVariables(e) {
		const t = this.#Re.get(e);
		if (!t) return [];
		this.ensureInitialized();
		const n = this.#Se.get(t);
		return n ? Array.from(n.keys()) : [];
	}
	computeCSSVariable(e, t) {
		const n = this.#Re.get(e);
		if (!n) return null;
		this.ensureInitialized();
		const r = this.#Se.get(n),
			s = this.#we.get(n);
		return r && s ? this.innerComputeCSSVariable(r, s, t) : null;
	}
	computeValue(e, t) {
		const n = this.#Re.get(e);
		if (!n) return null;
		this.ensureInitialized();
		const r = this.#Se.get(n),
			s = this.#we.get(n);
		return r && s ? this.innerComputeValue(r, s, t) : null;
	}
	computeSingleVariableValue(e, t) {
		const n = this.#Re.get(e);
		if (!n) return null;
		this.ensureInitialized();
		const r = this.#Se.get(n),
			s = this.#we.get(n);
		if (!r || !s) return null;
		const i = this.innerComputeValue(r, s, t),
			{ variableName: a } = Pe(t);
		return { computedValue: i, fromFallback: null !== a && !r.has(a) };
	}
	innerComputeCSSVariable(e, t, n) {
		if (!e.has(n)) return null;
		if (t.has(n)) return t.get(n) || null;
		t.set(n, null);
		const r = e.get(n);
		if (null == r) return null;
		const s = this.innerComputeValue(e, t, r.value),
			i = s ? { value: s, declaration: r.declaration } : null;
		return (t.set(n, i), i);
	}
	innerComputeValue(e, t, n) {
		const r = s.TextUtils.Utils.splitStringByRegexes(n, [b]),
			i = [];
		for (const n of r) {
			if (-1 === n.regexIndex) {
				i.push(n.value);
				continue;
			}
			const { variableName: r, fallback: s } = Pe(n.value);
			if (!r) return null;
			const a = this.innerComputeCSSVariable(e, t, r);
			if (null === a && !s) return null;
			null === a ? i.push(s) : i.push(a.value);
		}
		return i.map((e) => (e ? e.trim() : "")).join(" ");
	}
	styles() {
		return Array.from(this.#Re.keys());
	}
	propertyState(e) {
		return (this.ensureInitialized(), this.#ke.get(e) || null);
	}
	reset() {
		((this.#Ce = !1), this.#ke.clear(), this.#Se.clear(), this.#we.clear());
	}
	ensureInitialized() {
		if (this.#Ce) return;
		this.#Ce = !0;
		const e = new Map();
		for (const t of this.#Ie) {
			t.computeActiveProperties();
			for (const [n, r] of t.propertiesState) {
				if (r === xe.Overloaded) {
					this.#ke.set(n, xe.Overloaded);
					continue;
				}
				const t = I().canonicalPropertyName(n.name);
				e.has(t)
					? this.#ke.set(n, xe.Overloaded)
					: (e.set(t, n), this.#ke.set(n, xe.Active));
			}
		}
		for (const [t, n] of e) {
			const r = n.ownerStyle,
				s = n.getLonghandProperties();
			if (!s.length) continue;
			let i = !1;
			for (const t of s) {
				const n = I().canonicalPropertyName(t.name),
					s = e.get(n);
				if (s && s.ownerStyle === r) {
					i = !0;
					break;
				}
			}
			i || (e.delete(t), this.#ke.set(n, xe.Overloaded));
		}
		const t = new Map();
		for (const e of this.#ae) {
			const n = e.initialValue();
			t.set(e.propertyName(), n ? { value: n, declaration: e } : null);
		}
		for (let e = this.#Ie.length - 1; e >= 0; --e) {
			const n = this.#Ie[e],
				r = [];
			for (const e of n.activeProperties.entries()) {
				const n = e[0],
					s = e[1];
				n.startsWith("--") &&
					(t.set(n, { value: s.value, declaration: s }), r.push(n));
			}
			const s = new Map(t),
				i = new Map();
			(this.#Se.set(n, s), this.#we.set(n, i));
			for (const e of r) {
				const n = t.get(e);
				t.delete(e);
				const r = this.innerComputeCSSVariable(s, i, e);
				(n && r?.value === n.value && (r.declaration = n.declaration),
					t.set(e, r));
			}
		}
	}
}
!(function (e) {
	((e.Active = "Active"), (e.Overloaded = "Overloaded"));
})(xe || (xe = {}));
var Ue = Object.freeze({
	__proto__: null,
	parseCSSVariableNameAndFallback: Pe,
	CSSRegisteredProperty: Ne,
	CSSMatchedStyles: De,
	get PropertyState() {
		return xe;
	},
});
const He = {
		couldNotFindTheOriginalStyle: "Could not find the original style sheet.",
		thereWasAnErrorRetrievingThe:
			"There was an error retrieving the source styles.",
	},
	qe = i.i18n.registerUIStrings("core/sdk/CSSStyleSheetHeader.ts", He),
	_e = i.i18n.getLocalizedString.bind(void 0, qe);
class ze {
	#F;
	id;
	frameId;
	sourceURL;
	hasSourceURL;
	origin;
	title;
	disabled;
	isInline;
	isMutable;
	isConstructed;
	startLine;
	startColumn;
	endLine;
	endColumn;
	contentLength;
	ownerNode;
	sourceMapURL;
	loadingFailed;
	#Te;
	constructor(e, t) {
		((this.#F = e),
			(this.id = t.styleSheetId),
			(this.frameId = t.frameId),
			(this.sourceURL = t.sourceURL),
			(this.hasSourceURL = Boolean(t.hasSourceURL)),
			(this.origin = t.origin),
			(this.title = t.title),
			(this.disabled = t.disabled),
			(this.isInline = t.isInline),
			(this.isMutable = t.isMutable),
			(this.isConstructed = t.isConstructed),
			(this.startLine = t.startLine),
			(this.startColumn = t.startColumn),
			(this.endLine = t.endLine),
			(this.endColumn = t.endColumn),
			(this.contentLength = t.length),
			t.ownerNode && (this.ownerNode = new ur(e.target(), t.ownerNode)),
			(this.sourceMapURL = t.sourceMapURL),
			(this.loadingFailed = t.loadingFailed ?? !1),
			(this.#Te = null));
	}
	originalContentProvider() {
		if (!this.#Te) {
			const e = async () => {
				const e = await this.#F.originalStyleSheetText(this);
				return null === e
					? {
							content: null,
							error: _e(He.couldNotFindTheOriginalStyle),
							isEncoded: !1,
						}
					: { content: e, isEncoded: !1 };
			};
			this.#Te = new s.StaticContentProvider.StaticContentProvider(
				this.contentURL(),
				this.contentType(),
				e
			);
		}
		return this.#Te;
	}
	setSourceMapURL(e) {
		this.sourceMapURL = e;
	}
	cssModel() {
		return this.#F;
	}
	isAnonymousInlineStyleSheet() {
		return (
			!this.resourceURL() &&
			!this.#F.sourceMapManager().sourceMapForClient(this)
		);
	}
	isConstructedByNew() {
		return this.isConstructed && 0 === this.sourceURL.length;
	}
	resourceURL() {
		const e = this.isViaInspector()
			? this.viaInspectorResourceURL()
			: this.sourceURL;
		return !e &&
			a.Runtime.experiments.isEnabled(
				a.Runtime.ExperimentName.STYLES_PANE_CSS_CHANGES
			)
			? this.dynamicStyleURL()
			: e;
	}
	getFrameURLPath() {
		const t = this.#F.target().model(Pr);
		if ((console.assert(Boolean(t)), !t)) return "";
		const n = t.frameForId(this.frameId);
		if (!n) return "";
		console.assert(Boolean(n));
		const r = new e.ParsedURL.ParsedURL(n.url);
		let s = r.host + r.folderPathComponents;
		return (s.endsWith("/") || (s += "/"), s);
	}
	viaInspectorResourceURL() {
		return `inspector://${this.getFrameURLPath()}inspector-stylesheet`;
	}
	dynamicStyleURL() {
		return `stylesheet://${this.getFrameURLPath()}style#${this.id}`;
	}
	lineNumberInSource(e) {
		return this.startLine + e;
	}
	columnNumberInSource(e, t) {
		return (e ? 0 : this.startColumn) + t;
	}
	containsLocation(e, t) {
		const n =
				(e === this.startLine && t >= this.startColumn) || e > this.startLine,
			r = e < this.endLine || (e === this.endLine && t <= this.endColumn);
		return n && r;
	}
	contentURL() {
		return this.resourceURL();
	}
	contentType() {
		return e.ResourceType.resourceTypes.Stylesheet;
	}
	async requestContent() {
		try {
			return {
				content: await this.#F.getStyleSheetText(this.id),
				isEncoded: !1,
			};
		} catch (e) {
			return {
				content: null,
				error: _e(He.thereWasAnErrorRetrievingThe),
				isEncoded: !1,
			};
		}
	}
	async searchInContent(e, t, n) {
		const r = await this.requestContent();
		return null === r.content
			? []
			: s.TextUtils.performSearchInContent(r.content, e, t, n);
	}
	isViaInspector() {
		return "inspector" === this.origin;
	}
	createPageResourceLoadInitiator() {
		return {
			target: this.#F.target(),
			frameId: this.frameId,
			initiatorUrl: this.hasSourceURL
				? t.DevToolsPath.EmptyUrlString
				: this.sourceURL,
		};
	}
}
var je,
	We,
	Ve = Object.freeze({ __proto__: null, CSSStyleSheetHeader: ze });
class Ge extends l.InspectorBackend.TargetBase {
	#xe;
	#p;
	#Me;
	#Pe;
	#Le;
	#f;
	#Ee;
	#Oe;
	#Ae;
	#Ne;
	#De;
	#Fe;
	constructor(n, r, s, i, a, o, l, d, c) {
		switch (
			(super(i === je.Node, a, o, d),
			(this.#xe = n),
			(this.#p = s),
			(this.#Me = t.DevToolsPath.EmptyUrlString),
			(this.#Pe = ""),
			(this.#Le = 0),
			i)
		) {
			case je.Frame:
				((this.#Le =
					We.Browser |
					We.Storage |
					We.DOM |
					We.JS |
					We.Log |
					We.Network |
					We.Target |
					We.Tracing |
					We.Emulation |
					We.Input |
					We.Inspector |
					We.Audits |
					We.WebAuthn |
					We.IO |
					We.Media |
					We.EventBreakpoints),
					a?.type() !== je.Frame &&
						((this.#Le |=
							We.DeviceEmulation |
							We.ScreenCapture |
							We.Security |
							We.ServiceWorker),
						e.ParsedURL.schemeIs(c?.url, "chrome-extension:") &&
							(this.#Le &= ~We.Security)));
				break;
			case je.ServiceWorker:
				((this.#Le =
					We.JS |
					We.Log |
					We.Network |
					We.Target |
					We.Inspector |
					We.IO |
					We.EventBreakpoints),
					a?.type() !== je.Frame && (this.#Le |= We.Browser));
				break;
			case je.SharedWorker:
				this.#Le =
					We.JS |
					We.Log |
					We.Network |
					We.Target |
					We.IO |
					We.Media |
					We.Inspector |
					We.EventBreakpoints;
				break;
			case je.SharedStorageWorklet:
				this.#Le = We.JS | We.Log | We.Inspector | We.EventBreakpoints;
				break;
			case je.Worker:
				this.#Le =
					We.JS |
					We.Log |
					We.Network |
					We.Target |
					We.IO |
					We.Media |
					We.Emulation |
					We.EventBreakpoints;
				break;
			case je.Node:
				this.#Le = We.JS;
				break;
			case je.AuctionWorklet:
				this.#Le = We.JS | We.EventBreakpoints;
				break;
			case je.Browser:
				this.#Le = We.Target | We.IO;
				break;
			case je.Tab:
				this.#Le = We.Target | We.Tracing;
		}
		((this.#f = i),
			(this.#Ee = a),
			(this.#Oe = r),
			(this.#Ae = new Map()),
			(this.#Ne = l),
			(this.#De = c));
	}
	createModels(e) {
		this.#Fe = !0;
		const t = Array.from(c.registeredModels.entries());
		for (const [e, n] of t) n.early && this.model(e);
		for (const [n, r] of t) (r.autostart || e.has(n)) && this.model(n);
		this.#Fe = !1;
	}
	id() {
		return this.#Oe;
	}
	name() {
		return this.#p || this.#Pe;
	}
	setName(e) {
		this.#p !== e && ((this.#p = e), this.#xe.onNameChange(this));
	}
	type() {
		return this.#f;
	}
	markAsNodeJSForTest() {
		(super.markAsNodeJSForTest(), (this.#f = je.Node));
	}
	targetManager() {
		return this.#xe;
	}
	hasAllCapabilities(e) {
		return (this.#Le & e) === e;
	}
	decorateLabel(e) {
		return this.#f === je.Worker || this.#f === je.ServiceWorker
			? " " + e
			: e;
	}
	parentTarget() {
		return this.#Ee;
	}
	outermostTarget() {
		let e = null,
			t = this;
		do {
			(t.type() !== je.Tab && t.type() !== je.Browser && (e = t),
				(t = t.parentTarget()));
		} while (t);
		return e;
	}
	dispose(e) {
		(super.dispose(e), this.#xe.removeTarget(this));
		for (const e of this.#Ae.values()) e.dispose();
	}
	model(e) {
		if (!this.#Ae.get(e)) {
			const t = c.registeredModels.get(e);
			if (void 0 === t)
				throw "Model class is not registered @" + new Error().stack;
			if ((this.#Le & t.capabilities) === t.capabilities) {
				const t = new e(this);
				(this.#Ae.set(e, t),
					this.#Fe ||
						this.#xe.modelAdded(this, e, t, this.#xe.isInScope(this)));
			}
		}
		return this.#Ae.get(e) || null;
	}
	models() {
		return this.#Ae;
	}
	inspectedURL() {
		return this.#Me;
	}
	setInspectedURL(t) {
		this.#Me = t;
		const n = e.ParsedURL.ParsedURL.fromString(t);
		((this.#Pe = n ? n.lastPathComponentWithFragment() : "#" + this.#Oe),
			this.#xe.onInspectedURLChange(this),
			this.#p || this.#xe.onNameChange(this));
	}
	async suspend(e) {
		this.#Ne ||
			((this.#Ne = !0),
			await Promise.all(
				Array.from(this.models().values(), (t) => t.preSuspendModel(e))
			),
			await Promise.all(
				Array.from(this.models().values(), (t) => t.suspendModel(e))
			));
	}
	async resume() {
		this.#Ne &&
			((this.#Ne = !1),
			await Promise.all(
				Array.from(this.models().values(), (e) => e.resumeModel())
			),
			await Promise.all(
				Array.from(this.models().values(), (e) => e.postResumeModel())
			));
	}
	suspended() {
		return this.#Ne;
	}
	updateTargetInfo(e) {
		this.#De = e;
	}
	targetInfo() {
		return this.#De;
	}
}
(!(function (e) {
	((e.Frame = "frame"),
		(e.ServiceWorker = "service-worker"),
		(e.Worker = "worker"),
		(e.SharedWorker = "shared-worker"),
		(e.SharedStorageWorklet = "shared-storage-worklet"),
		(e.Node = "node"),
		(e.Browser = "browser"),
		(e.AuctionWorklet = "auction-worklet"),
		(e.Tab = "tab"));
})(je || (je = {})),
	(function (e) {
		((e[(e.Browser = 1)] = "Browser"),
			(e[(e.DOM = 2)] = "DOM"),
			(e[(e.JS = 4)] = "JS"),
			(e[(e.Log = 8)] = "Log"),
			(e[(e.Network = 16)] = "Network"),
			(e[(e.Target = 32)] = "Target"),
			(e[(e.ScreenCapture = 64)] = "ScreenCapture"),
			(e[(e.Tracing = 128)] = "Tracing"),
			(e[(e.Emulation = 256)] = "Emulation"),
			(e[(e.Security = 512)] = "Security"),
			(e[(e.Input = 1024)] = "Input"),
			(e[(e.Inspector = 2048)] = "Inspector"),
			(e[(e.DeviceEmulation = 4096)] = "DeviceEmulation"),
			(e[(e.Storage = 8192)] = "Storage"),
			(e[(e.ServiceWorker = 16384)] = "ServiceWorker"),
			(e[(e.Audits = 32768)] = "Audits"),
			(e[(e.WebAuthn = 65536)] = "WebAuthn"),
			(e[(e.IO = 131072)] = "IO"),
			(e[(e.Media = 262144)] = "Media"),
			(e[(e.EventBreakpoints = 524288)] = "EventBreakpoints"),
			(e[(e.None = 0)] = "None"));
	})(We || (We = {})));
var Ke = Object.freeze({
	__proto__: null,
	Target: Ge,
	get Type() {
		return je;
	},
	get Capability() {
		return We;
	},
});
let Qe;
class $e extends e.ObjectWrapper.ObjectWrapper {
	#Be;
	#Ue;
	#He;
	#qe;
	#_e;
	#Ne;
	#ze;
	#je;
	#We;
	#Ve;
	constructor() {
		(super(),
			(this.#Be = new Set()),
			(this.#Ue = new Set()),
			(this.#He = new t.MapUtilities.Multimap()),
			(this.#qe = new t.MapUtilities.Multimap()),
			(this.#Ne = !1),
			(this.#ze = null),
			(this.#je = null),
			(this.#_e = new WeakSet()),
			(this.#We = !1),
			(this.#Ve = new Set()));
	}
	static instance({ forceNew: e } = { forceNew: !1 }) {
		return ((Qe && !e) || (Qe = new $e()), Qe);
	}
	static removeInstance() {
		Qe = void 0;
	}
	onInspectedURLChange(e) {
		e === this.#je &&
			(o.InspectorFrontendHost.InspectorFrontendHostInstance.inspectedURLChanged(
				e.inspectedURL() || t.DevToolsPath.EmptyUrlString
			),
			this.dispatchEventToListeners(Xe.InspectedURLChanged, e));
	}
	onNameChange(e) {
		this.dispatchEventToListeners(Xe.NameChanged, e);
	}
	async suspendAllTargets(e) {
		if (this.#Ne) return;
		((this.#Ne = !0), this.dispatchEventToListeners(Xe.SuspendStateChanged));
		const t = Array.from(this.#Be.values(), (t) => t.suspend(e));
		await Promise.all(t);
	}
	async resumeAllTargets() {
		if (!this.#Ne) return;
		((this.#Ne = !1), this.dispatchEventToListeners(Xe.SuspendStateChanged));
		const e = Array.from(this.#Be.values(), (e) => e.resume());
		await Promise.all(e);
	}
	allTargetsSuspended() {
		return this.#Ne;
	}
	models(e, t) {
		const n = [];
		for (const r of this.#Be) {
			if (t?.scoped && !this.isInScope(r)) continue;
			const s = r.model(e);
			s && n.push(s);
		}
		return n;
	}
	inspectedURL() {
		const e = this.primaryPageTarget();
		return e ? e.inspectedURL() : "";
	}
	observeModels(e, t, n) {
		const r = this.models(e, n);
		(this.#qe.set(e, t), n?.scoped && this.#_e.add(t));
		for (const e of r) t.modelAdded(e);
	}
	unobserveModels(e, t) {
		(this.#qe.delete(e, t), this.#_e.delete(t));
	}
	modelAdded(e, t, n, r) {
		for (const e of this.#qe.get(t).values())
			(this.#_e.has(e) && !r) || e.modelAdded(n);
	}
	modelRemoved(e, t, n, r) {
		for (const e of this.#qe.get(t).values())
			(this.#_e.has(e) && !r) || e.modelRemoved(n);
	}
	addModelListener(e, t, n, r, s) {
		const i = (e) => {
			(s?.scoped && !this.isInScope(e)) || n.call(r, e);
		};
		for (const n of this.models(e)) n.addEventListener(t, i);
		this.#He.set(t, {
			modelClass: e,
			thisObject: r,
			listener: n,
			wrappedListener: i,
		});
	}
	removeModelListener(e, t, n, r) {
		if (!this.#He.has(t)) return;
		let s = null;
		for (const i of this.#He.get(t))
			i.modelClass === e &&
				i.listener === n &&
				i.thisObject === r &&
				((s = i.wrappedListener), this.#He.delete(t, i));
		if (s) for (const n of this.models(e)) n.removeEventListener(t, s);
	}
	observeTargets(e, t) {
		if (this.#Ue.has(e))
			throw new Error("Observer can only be registered once");
		t?.scoped && this.#_e.add(e);
		for (const n of this.#Be)
			(t?.scoped && !this.isInScope(n)) || e.targetAdded(n);
		this.#Ue.add(e);
	}
	unobserveTargets(e) {
		(this.#Ue.delete(e), this.#_e.delete(e));
	}
	createTarget(e, t, n, r, s, i, a, o) {
		const l = new Ge(this, e, t, n, r, s || "", this.#Ne, a || null, o);
		(i && l.pageAgent().invoke_waitForDebugger(),
			l.createModels(new Set(this.#qe.keysArray())),
			this.#Be.add(l));
		const d = this.isInScope(l);
		for (const e of [...this.#Ue]) (this.#_e.has(e) && !d) || e.targetAdded(l);
		for (const [e, t] of l.models().entries()) this.modelAdded(l, e, t, d);
		for (const e of this.#He.keysArray())
			for (const t of this.#He.get(e)) {
				const n = l.model(t.modelClass);
				n && n.addEventListener(e, t.wrappedListener);
			}
		return (
			l !== l.outermostTarget() ||
				(l.type() === je.Frame && l !== this.primaryPageTarget()) ||
				this.#We ||
				this.setScopeTarget(l),
			l
		);
	}
	removeTarget(e) {
		if (!this.#Be.has(e)) return;
		const t = this.isInScope(e);
		this.#Be.delete(e);
		for (const r of e.models().keys()) {
			const s = e.models().get(r);
			(n(s), this.modelRemoved(e, r, s, t));
		}
		for (const n of [...this.#Ue])
			(this.#_e.has(n) && !t) || n.targetRemoved(e);
		for (const t of this.#He.keysArray())
			for (const n of this.#He.get(t)) {
				const r = e.model(n.modelClass);
				r && r.removeEventListener(t, n.wrappedListener);
			}
	}
	targets() {
		return [...this.#Be];
	}
	targetById(e) {
		return this.targets().find((t) => t.id() === e) || null;
	}
	rootTarget() {
		return this.#Be.size ? this.#Be.values().next().value : null;
	}
	primaryPageTarget() {
		let e = this.rootTarget();
		return (
			e?.type() === je.Tab &&
				(e =
					this.targets().find(
						(t) =>
							t.parentTarget() === e &&
							t.type() === je.Frame &&
							!t.targetInfo()?.subtype?.length
					) || null),
			e
		);
	}
	browserTarget() {
		return this.#ze;
	}
	async maybeAttachInitialTarget() {
		if (!Boolean(a.Runtime.Runtime.queryParam("browserConnection"))) return !1;
		this.#ze ||
			((this.#ze = new Ge(
				this,
				"main",
				"browser",
				je.Browser,
				null,
				"",
				!1,
				null,
				void 0
			)),
			this.#ze.createModels(new Set(this.#qe.keysArray())));
		const e =
			await o.InspectorFrontendHost.InspectorFrontendHostInstance.initialTargetId();
		return (
			this.#ze
				.targetAgent()
				.invoke_autoAttachRelated({ targetId: e, waitForDebuggerOnStart: !0 }),
			!0
		);
	}
	clearAllTargetsForTest() {
		this.#Be.clear();
	}
	isInScope(e) {
		if (!e) return !1;
		for (
			(function (e) {
				return ("source" in e) && e.source instanceof c;
			})(e) && (e = e.source),
				e instanceof c && (e = e.target());
			e && e !== this.#je;

		)
			e = e.parentTarget();
		return Boolean(e) && e === this.#je;
	}
	setScopeTarget(e) {
		if (e !== this.#je) {
			for (const e of this.targets())
				if (this.isInScope(e)) {
					for (const t of this.#qe.keysArray()) {
						const n = e.models().get(t);
						if (n)
							for (const e of [...this.#qe.get(t)].filter((e) =>
								this.#_e.has(e)
							))
								e.modelRemoved(n);
					}
					for (const t of [...this.#Ue].filter((e) => this.#_e.has(e)))
						t.targetRemoved(e);
				}
			this.#je = e;
			for (const e of this.targets())
				if (this.isInScope(e)) {
					for (const t of [...this.#Ue].filter((e) => this.#_e.has(e)))
						t.targetAdded(e);
					for (const [t, n] of e.models().entries())
						for (const e of [...this.#qe.get(t)].filter((e) => this.#_e.has(e)))
							e.modelAdded(n);
				}
			for (const e of this.#Ve) e();
			e && e.inspectedURL() && this.onInspectedURLChange(e);
		}
	}
	addScopeChangeListener(e) {
		this.#Ve.add(e);
	}
	removeScopeChangeListener(e) {
		this.#Ve.delete(e);
	}
	scopeTarget() {
		return this.#je;
	}
}
var Xe;
!(function (e) {
	((e.AvailableTargetsChanged = "AvailableTargetsChanged"),
		(e.InspectedURLChanged = "InspectedURLChanged"),
		(e.NameChanged = "NameChanged"),
		(e.SuspendStateChanged = "SuspendStateChanged"));
})(Xe || (Xe = {}));
var Je = Object.freeze({
	__proto__: null,
	TargetManager: $e,
	get Events() {
		return Xe;
	},
	Observer: class {
		targetAdded(e) {}
		targetRemoved(e) {}
	},
	SDKModelObserver: class {
		modelAdded(e) {}
		modelRemoved(e) {}
	},
});
let Ye = null;
class Ze extends e.ObjectWrapper.ObjectWrapper {
	#Ge = new WeakMap();
	#Ke = new Map();
	#Qe = new Map();
	#$e = null;
	#Xe = new Map();
	#Je = new Map();
	constructor() {
		(super(), $e.instance().observeModels(Pr, this));
	}
	static instance({ forceNew: e } = { forceNew: !1 }) {
		return ((Ye && !e) || (Ye = new Ze()), Ye);
	}
	modelAdded(e) {
		const t = e.addEventListener(xr.FrameAdded, this.frameAdded, this),
			n = e.addEventListener(xr.FrameDetached, this.frameDetached, this),
			r = e.addEventListener(xr.FrameNavigated, this.frameNavigated, this),
			s = e.addEventListener(xr.ResourceAdded, this.resourceAdded, this);
		(this.#Ge.set(e, [t, n, r, s]), this.#Qe.set(e.target().id(), new Set()));
	}
	modelRemoved(t) {
		const n = this.#Ge.get(t);
		n && e.EventTarget.removeEventListeners(n);
		const r = this.#Qe.get(t.target().id());
		if (r) for (const e of r) this.decreaseOrRemoveFrame(e);
		this.#Qe.delete(t.target().id());
	}
	frameAdded(e) {
		const t = e.data,
			n = this.#Ke.get(t.id);
		if (n)
			(t.setCreationStackTrace(n.frame.getCreationStackTraceData()),
				this.#Ke.set(t.id, { frame: t, count: n.count + 1 }));
		else {
			const e = this.#Xe.get(t.id);
			(e?.creationStackTrace &&
				e?.creationStackTraceTarget &&
				t.setCreationStackTrace({
					creationStackTrace: e.creationStackTrace,
					creationStackTraceTarget: e.creationStackTraceTarget,
				}),
				this.#Ke.set(t.id, { frame: t, count: 1 }),
				this.#Xe.delete(t.id));
		}
		this.resetOutermostFrame();
		const r = this.#Qe.get(t.resourceTreeModel().target().id());
		(r && r.add(t.id),
			this.dispatchEventToListeners(et.FrameAddedToTarget, { frame: t }),
			this.resolveAwaitedFrame(t));
	}
	frameDetached(e) {
		const { frame: t, isSwap: n } = e.data;
		if ((this.decreaseOrRemoveFrame(t.id), n && !this.#Ke.get(t.id))) {
			const e = t.getCreationStackTraceData(),
				n = {
					...(e.creationStackTrace && {
						creationStackTrace: e.creationStackTrace,
					}),
					...(e.creationStackTrace && {
						creationStackTraceTarget: e.creationStackTraceTarget,
					}),
				};
			this.#Xe.set(t.id, n);
		}
		const r = this.#Qe.get(t.resourceTreeModel().target().id());
		r && r.delete(t.id);
	}
	frameNavigated(e) {
		const t = e.data;
		(this.dispatchEventToListeners(et.FrameNavigated, { frame: t }),
			t.isOutermostFrame() &&
				this.dispatchEventToListeners(et.OutermostFrameNavigated, {
					frame: t,
				}));
	}
	resourceAdded(e) {
		this.dispatchEventToListeners(et.ResourceAdded, { resource: e.data });
	}
	decreaseOrRemoveFrame(e) {
		const t = this.#Ke.get(e);
		t &&
			(1 === t.count
				? (this.#Ke.delete(e),
					this.resetOutermostFrame(),
					this.dispatchEventToListeners(et.FrameRemoved, { frameId: e }))
				: t.count--);
	}
	resetOutermostFrame() {
		const e = this.getAllFrames().filter((e) => e.isOutermostFrame());
		this.#$e = e.length > 0 ? e[0] : null;
	}
	getFrame(e) {
		const t = this.#Ke.get(e);
		return t ? t.frame : null;
	}
	getAllFrames() {
		return Array.from(this.#Ke.values(), (e) => e.frame);
	}
	getOutermostFrame() {
		return this.#$e;
	}
	async getOrWaitForFrame(e, t) {
		const n = this.getFrame(e);
		return !n || (t && t === n.resourceTreeModel().target())
			? new Promise((n) => {
					const r = this.#Je.get(e);
					r
						? r.push({ notInTarget: t, resolve: n })
						: this.#Je.set(e, [{ notInTarget: t, resolve: n }]);
				})
			: n;
	}
	resolveAwaitedFrame(e) {
		const t = this.#Je.get(e.id);
		if (!t) return;
		const n = t.filter(
			({ notInTarget: t, resolve: n }) =>
				!(!t || t !== e.resourceTreeModel().target()) || (n(e), !1)
		);
		n.length > 0 ? this.#Je.set(e.id, n) : this.#Je.delete(e.id);
	}
}
var et;
!(function (e) {
	((e.FrameAddedToTarget = "FrameAddedToTarget"),
		(e.FrameNavigated = "FrameNavigated"),
		(e.FrameRemoved = "FrameRemoved"),
		(e.ResourceAdded = "ResourceAdded"),
		(e.OutermostFrameNavigated = "OutermostFrameNavigated"));
})(et || (et = {}));
var tt = Object.freeze({
	__proto__: null,
	FrameManager: Ze,
	get Events() {
		return et;
	},
});
class nt {
	static fromLocalObject(e) {
		return new ot(e);
	}
	static type(e) {
		if (null === e) return "null";
		const t = typeof e;
		return "object" !== t && "function" !== t ? t : e.type;
	}
	static isNullOrUndefined(e) {
		if (void 0 === e) return !0;
		switch (e.type) {
			case "object":
				return "null" === e.subtype;
			case "undefined":
				return !0;
			default:
				return !1;
		}
	}
	static arrayNameFromDescription(e) {
		return e.replace(ct, "").replace(ht, "");
	}
	static arrayLength(e) {
		if ("array" !== e.subtype && "typedarray" !== e.subtype) return 0;
		const t = e.description && e.description.match(ct),
			n = e.description && e.description.match(ht);
		return t ? parseInt(t[1], 10) : n ? parseInt(n[1], 10) : 0;
	}
	static arrayBufferByteLength(e) {
		if ("arraybuffer" !== e.subtype) return 0;
		const t = e.description && e.description.match(ct);
		return t ? parseInt(t[1], 10) : 0;
	}
	static unserializableDescription(e) {
		const t = typeof e;
		if ("number" === t) {
			const t = String(e);
			if (0 === e && 1 / e < 0) return "-0";
			if ("NaN" === t || "Infinity" === t || "-Infinity" === t) return t;
		}
		return "bigint" === t ? e + "n" : null;
	}
	static toCallArgument(e) {
		const t = typeof e;
		if ("undefined" === t) return {};
		const n = nt.unserializableDescription(e);
		if ("number" === t)
			return null !== n ? { unserializableValue: n } : { value: e };
		if ("bigint" === t) return { unserializableValue: n };
		if ("string" === t || "boolean" === t) return { value: e };
		if (!e) return { value: null };
		const r = e;
		if (e instanceof nt) {
			const t = e.unserializableValue();
			if (void 0 !== t) return { unserializableValue: t };
		} else if (void 0 !== r.unserializableValue)
			return { unserializableValue: r.unserializableValue };
		return void 0 !== r.objectId
			? { objectId: r.objectId }
			: { value: r.value };
	}
	static async loadFromObjectPerProto(e, t, n = !1) {
		const r = await Promise.all([
				e.getAllProperties(!0, t, n),
				e.getOwnProperties(t, n),
			]),
			s = r[0].properties,
			i = r[1].properties,
			a = r[1].internalProperties;
		if (!i || !s) return { properties: null, internalProperties: null };
		const o = new Map(),
			l = [];
		for (let e = 0; e < s.length; e++) {
			const t = s[e];
			t.symbol
				? l.push(t)
				: (t.isOwn || "__proto__" !== t.name) && o.set(t.name, t);
		}
		for (let e = 0; e < i.length; e++) {
			const t = i[e];
			t.isAccessorProperty() ||
				(t.private || t.symbol ? l.push(t) : o.set(t.name, t));
		}
		return {
			properties: [...o.values()].concat(l),
			internalProperties: a || null,
		};
	}
	customPreview() {
		return null;
	}
	get objectId() {
		return "Not implemented";
	}
	get type() {
		throw "Not implemented";
	}
	get subtype() {
		throw "Not implemented";
	}
	get value() {
		throw "Not implemented";
	}
	unserializableValue() {
		throw "Not implemented";
	}
	get description() {
		throw "Not implemented";
	}
	set description(e) {
		throw "Not implemented";
	}
	get hasChildren() {
		throw "Not implemented";
	}
	get preview() {}
	get className() {
		return null;
	}
	arrayLength() {
		throw "Not implemented";
	}
	arrayBufferByteLength() {
		throw "Not implemented";
	}
	getOwnProperties(e, t) {
		throw "Not implemented";
	}
	getAllProperties(e, t, n) {
		throw "Not implemented";
	}
	async deleteProperty(e) {
		throw "Not implemented";
	}
	async setPropertyValue(e, t) {
		throw "Not implemented";
	}
	callFunction(e, t) {
		throw "Not implemented";
	}
	callFunctionJSON(e, t) {
		throw "Not implemented";
	}
	release() {}
	debuggerModel() {
		throw new Error("DebuggerModel-less object");
	}
	runtimeModel() {
		throw new Error("RuntimeModel-less object");
	}
	isNode() {
		return !1;
	}
	isLinearMemoryInspectable() {
		return !1;
	}
	webIdl;
}
class rt extends nt {
	runtimeModelInternal;
	#Ye;
	#f;
	#Ze;
	#et;
	#tt;
	hasChildrenInternal;
	#nt;
	#rt;
	#m;
	#st;
	#it;
	constructor(e, t, n, r, s, i, a, o, l, d) {
		(super(),
			(this.runtimeModelInternal = e),
			(this.#Ye = e.target().runtimeAgent()),
			(this.#f = n),
			(this.#Ze = r),
			t
				? ((this.#et = t),
					(this.#tt = a),
					(this.hasChildrenInternal = "symbol" !== n),
					(this.#nt = o))
				: ((this.#tt = a),
					!this.description && i && (this.#tt = i),
					this.#tt ||
						("object" == typeof s && null !== s) ||
						(this.#tt = String(s)),
					(this.hasChildrenInternal = !1),
					"string" == typeof i
						? ((this.#rt = i),
							"Infinity" === i || "-Infinity" === i || "-0" === i || "NaN" === i
								? (this.#m = Number(i))
								: "bigint" === n && i.endsWith("n")
									? (this.#m = BigInt(i.substring(0, i.length - 1)))
									: (this.#m = i))
						: (this.#m = s)),
			(this.#st = l || null),
			(this.#it = "string" == typeof d ? d : null));
	}
	customPreview() {
		return this.#st;
	}
	get objectId() {
		return this.#et;
	}
	get type() {
		return this.#f;
	}
	get subtype() {
		return this.#Ze;
	}
	get value() {
		return this.#m;
	}
	unserializableValue() {
		return this.#rt;
	}
	get description() {
		return this.#tt;
	}
	set description(e) {
		this.#tt = e;
	}
	get hasChildren() {
		return this.hasChildrenInternal;
	}
	get preview() {
		return this.#nt;
	}
	get className() {
		return this.#it;
	}
	getOwnProperties(e, t = !1) {
		return this.doGetProperties(!0, !1, t, e);
	}
	getAllProperties(e, t, n = !1) {
		return this.doGetProperties(!1, e, n, t);
	}
	async createRemoteObject(e) {
		return this.runtimeModelInternal.createRemoteObject(e);
	}
	async doGetProperties(e, t, n, r) {
		if (!this.#et) return { properties: null, internalProperties: null };
		const s = await this.#Ye.invoke_getProperties({
			objectId: this.#et,
			ownProperties: e,
			accessorPropertiesOnly: t,
			nonIndexedPropertiesOnly: n,
			generatePreview: r,
		});
		if (s.getError()) return { properties: null, internalProperties: null };
		if (s.exceptionDetails)
			return (
				this.runtimeModelInternal.exceptionThrown(
					Date.now(),
					s.exceptionDetails
				),
				{ properties: null, internalProperties: null }
			);
		const {
				result: i = [],
				internalProperties: a = [],
				privateProperties: o = [],
			} = s,
			l = [];
		for (const e of i) {
			const t = e.value ? await this.createRemoteObject(e.value) : null,
				n = e.symbol
					? this.runtimeModelInternal.createRemoteObject(e.symbol)
					: null,
				r = new at(
					e.name,
					t,
					Boolean(e.enumerable),
					Boolean(e.writable),
					Boolean(e.isOwn),
					Boolean(e.wasThrown),
					n
				);
			(void 0 === e.value &&
				(e.get &&
					"undefined" !== e.get.type &&
					(r.getter = this.runtimeModelInternal.createRemoteObject(e.get)),
				e.set &&
					"undefined" !== e.set.type &&
					(r.setter = this.runtimeModelInternal.createRemoteObject(e.set))),
				l.push(r));
		}
		for (const e of o) {
			const t = e.value
					? this.runtimeModelInternal.createRemoteObject(e.value)
					: null,
				n = new at(e.name, t, !0, !0, !0, !1, void 0, !1, void 0, !0);
			(void 0 === e.value &&
				(e.get &&
					"undefined" !== e.get.type &&
					(n.getter = this.runtimeModelInternal.createRemoteObject(e.get)),
				e.set &&
					"undefined" !== e.set.type &&
					(n.setter = this.runtimeModelInternal.createRemoteObject(e.set))),
				l.push(n));
		}
		const d = [];
		for (const e of a) {
			if (!e.value) continue;
			if ("[[StableObjectId]]" === e.name) continue;
			const t = this.runtimeModelInternal.createRemoteObject(e.value);
			d.push(new at(e.name, t, !0, !1, void 0, void 0, void 0, !0));
		}
		return { properties: l, internalProperties: d };
	}
	async setPropertyValue(e, t) {
		if (!this.#et) return "Cant set a property of non-object.";
		const n = await this.#Ye.invoke_evaluate({ expression: t, silent: !0 });
		if (n.getError() || n.exceptionDetails)
			return (
				n.getError() ||
				("string" !== n.result.type ? n.result.description : n.result.value)
			);
		"string" == typeof e && (e = nt.toCallArgument(e));
		const r = this.doSetObjectPropertyValue(n.result, e);
		return (
			n.result.objectId &&
				this.#Ye.invoke_releaseObject({ objectId: n.result.objectId }),
			r
		);
	}
	async doSetObjectPropertyValue(e, t) {
		const n = [t, nt.toCallArgument(e)],
			r = await this.#Ye.invoke_callFunctionOn({
				objectId: this.#et,
				functionDeclaration: "function(a, b) { this[a] = b; }",
				arguments: n,
				silent: !0,
			}),
			s = r.getError();
		return s || r.exceptionDetails ? s || r.result.description : void 0;
	}
	async deleteProperty(e) {
		if (!this.#et) return "Cant delete a property of non-object.";
		const t = await this.#Ye.invoke_callFunctionOn({
			objectId: this.#et,
			functionDeclaration:
				"function(a) { delete this[a]; return !(a in this); }",
			arguments: [e],
			silent: !0,
		});
		return t.getError() || t.exceptionDetails
			? t.getError() || t.result.description
			: t.result.value
				? void 0
				: "Failed to delete property.";
	}
	async callFunction(e, t) {
		const n = await this.#Ye.invoke_callFunctionOn({
			objectId: this.#et,
			functionDeclaration: e.toString(),
			arguments: t,
			silent: !0,
		});
		return n.getError()
			? { object: null, wasThrown: !1 }
			: {
					object: this.runtimeModelInternal.createRemoteObject(n.result),
					wasThrown: Boolean(n.exceptionDetails),
				};
	}
	async callFunctionJSON(e, t) {
		const n = await this.#Ye.invoke_callFunctionOn({
			objectId: this.#et,
			functionDeclaration: e.toString(),
			arguments: t,
			silent: !0,
			returnByValue: !0,
		});
		return n.getError() || n.exceptionDetails ? null : n.result.value;
	}
	release() {
		this.#et && this.#Ye.invoke_releaseObject({ objectId: this.#et });
	}
	arrayLength() {
		return nt.arrayLength(this);
	}
	arrayBufferByteLength() {
		return nt.arrayBufferByteLength(this);
	}
	debuggerModel() {
		return this.runtimeModelInternal.debuggerModel();
	}
	runtimeModel() {
		return this.runtimeModelInternal;
	}
	isNode() {
		return (
			Boolean(this.#et) && "object" === this.type && "node" === this.subtype
		);
	}
	isLinearMemoryInspectable() {
		return (
			"object" === this.type &&
			void 0 !== this.subtype &&
			["webassemblymemory", "typedarray", "dataview", "arraybuffer"].includes(
				this.subtype
			)
		);
	}
}
class st extends rt {
	#at;
	#ot;
	constructor(e, t, n, r, s, i, a, o, l) {
		(super(e, t, r, s, i, a, o, l), (this.#at = n), (this.#ot = void 0));
	}
	async doGetProperties(e, t, n) {
		if (t) return { properties: [], internalProperties: [] };
		if (this.#ot)
			return { properties: this.#ot.slice(), internalProperties: null };
		const r = await super.doGetProperties(e, t, !1, !0);
		if (
			this.#at &&
			Array.isArray(r.properties) &&
			((this.#ot = r.properties.slice()), !this.#at.callFrameId)
		)
			for (const e of this.#ot) e.writable = !1;
		return r;
	}
	async doSetObjectPropertyValue(e, t) {
		const n = t.value,
			r = await this.debuggerModel().setVariableValue(
				this.#at.number,
				n,
				nt.toCallArgument(e),
				this.#at.callFrameId
			);
		if (r) return r;
		if (this.#ot)
			for (const t of this.#ot)
				t.name === n && (t.value = this.runtimeModel().createRemoteObject(e));
	}
}
class it {
	number;
	callFrameId;
	constructor(e, t) {
		((this.number = e), (this.callFrameId = t));
	}
}
class at {
	name;
	value;
	enumerable;
	writable;
	isOwn;
	wasThrown;
	symbol;
	synthetic;
	syntheticSetter;
	private;
	getter;
	setter;
	webIdl;
	constructor(e, t, n, r, s, i, a, o, l, d) {
		((this.name = e),
			(this.value = null !== t ? t : void 0),
			(this.enumerable = void 0 === n || n));
		const c = !o || Boolean(l);
		((this.writable = void 0 !== r ? r : c),
			(this.isOwn = Boolean(s)),
			(this.wasThrown = Boolean(i)),
			a && (this.symbol = a),
			(this.synthetic = Boolean(o)),
			l && (this.syntheticSetter = l),
			(this.private = Boolean(d)));
	}
	async setSyntheticValue(e) {
		if (!this.syntheticSetter) return !1;
		const t = await this.syntheticSetter(e);
		return (t && (this.value = t), Boolean(t));
	}
	isAccessorProperty() {
		return Boolean(this.getter || this.setter);
	}
	match({ includeNullOrUndefinedValues: e, regex: t }) {
		return (
			!(
				null !== t &&
				!t.test(this.name) &&
				!t.test(this.value?.description ?? "")
			) &&
			!(!e && !this.isAccessorProperty() && nt.isNullOrUndefined(this.value))
		);
	}
	cloneWithNewName(e) {
		const t = new at(
			e,
			this.value ?? null,
			this.enumerable,
			this.writable,
			this.isOwn,
			this.wasThrown,
			this.symbol,
			this.synthetic,
			this.syntheticSetter,
			this.private
		);
		return ((t.getter = this.getter), (t.setter = this.setter), t);
	}
}
class ot extends nt {
	valueInternal;
	#lt;
	#dt;
	constructor(e) {
		(super(), (this.valueInternal = e));
	}
	get objectId() {}
	get value() {
		return this.valueInternal;
	}
	unserializableValue() {
		return nt.unserializableDescription(this.valueInternal) || void 0;
	}
	get description() {
		if (this.#lt) return this.#lt;
		if ("object" === this.type)
			switch (this.subtype) {
				case "array":
					this.#lt = this.concatenate(
						"[",
						"]",
						function (e) {
							return this.formatValue(e.value || null);
						}.bind(this)
					);
					break;
				case "date":
					this.#lt = String(this.valueInternal);
					break;
				case "null":
					this.#lt = "null";
					break;
				default:
					this.#lt = this.concatenate(
						"{",
						"}",
						function (e) {
							let t = e.name;
							return (
								/^\s|\s$|^$|\n/.test(t) &&
									(t = '"' + t.replace(/\n/g, "") + '"'),
								t + ": " + this.formatValue(e.value || null)
							);
						}.bind(this)
					);
			}
		else this.#lt = String(this.valueInternal);
		return this.#lt;
	}
	formatValue(e) {
		if (!e) return "undefined";
		const t = e.description || "";
		return "string" === e.type ? '"' + t.replace(/\n/g, "") + '"' : t;
	}
	concatenate(e, t, n) {
		let r = e;
		const s = this.children();
		for (let e = 0; e < s.length; ++e) {
			const t = n(s[e]);
			if (r.length + t.length > 100) {
				r += ",";
				break;
			}
			(e && (r += ", "), (r += t));
		}
		return ((r += t), r);
	}
	get type() {
		return typeof this.valueInternal;
	}
	get subtype() {
		return null === this.valueInternal
			? "null"
			: Array.isArray(this.valueInternal)
				? "array"
				: this.valueInternal instanceof Date
					? "date"
					: void 0;
	}
	get hasChildren() {
		return (
			"object" == typeof this.valueInternal &&
			null !== this.valueInternal &&
			Boolean(Object.keys(this.valueInternal).length)
		);
	}
	async getOwnProperties(e, t = !1) {
		let n = this.children();
		return (
			t &&
				(n = n.filter(
					(e) =>
						!(function (e) {
							const t = Number(e) >>> 0;
							return String(t) === e;
						})(e.name)
				)),
			{ properties: n, internalProperties: null }
		);
	}
	async getAllProperties(e, t, n = !1) {
		return e
			? { properties: [], internalProperties: null }
			: await this.getOwnProperties(t, n);
	}
	children() {
		if (!this.hasChildren) return [];
		const e = this.valueInternal;
		return (
			this.#dt ||
				(this.#dt = Object.keys(e).map(function (t) {
					let n = e[t];
					return (n instanceof nt || (n = nt.fromLocalObject(n)), new at(t, n));
				})),
			this.#dt
		);
	}
	arrayLength() {
		return Array.isArray(this.valueInternal) ? this.valueInternal.length : 0;
	}
	async callFunction(e, t) {
		const n = this.valueInternal,
			r = t ? t.map((e) => e.value) : [];
		let s,
			i = !1;
		try {
			s = e.apply(n, r);
		} catch (e) {
			i = !0;
		}
		return { object: nt.fromLocalObject(s), wasThrown: i };
	}
	async callFunctionJSON(e, t) {
		const n = this.valueInternal,
			r = t ? t.map((e) => e.value) : [];
		let s;
		try {
			s = e.apply(n, r);
		} catch (e) {
			s = null;
		}
		return s;
	}
}
class lt {
	#ct;
	constructor(e) {
		this.#ct = e;
	}
	static objectAsArray(e) {
		if (
			!e ||
			"object" !== e.type ||
			("array" !== e.subtype && "typedarray" !== e.subtype)
		)
			throw new Error("Object is empty or not an array");
		return new lt(e);
	}
	static createFromRemoteObjects(e) {
		if (!e.length) throw new Error("Input array is empty");
		const t = [];
		for (let n = 0; n < e.length; ++n) t.push(nt.toCallArgument(e[n]));
		return e[0]
			.callFunction(function () {
				if (arguments.length > 1) return new Array(arguments);
				return [arguments[0]];
			}, t)
			.then(function (e) {
				if (e.wasThrown || !e.object)
					throw new Error(
						"Call function throws exceptions or returns empty value"
					);
				return lt.objectAsArray(e.object);
			});
	}
	at(e) {
		if (e < 0 || e > this.#ct.arrayLength()) throw new Error("Out of range");
		return this.#ct
			.callFunction(
				function (e) {
					return this[e];
				},
				[nt.toCallArgument(e)]
			)
			.then(function (e) {
				if (e.wasThrown || !e.object)
					throw new Error("Exception in callFunction or result value is empty");
				return e.object;
			});
	}
	length() {
		return this.#ct.arrayLength();
	}
	map(e) {
		const t = [];
		for (let n = 0; n < this.length(); ++n) t.push(this.at(n).then(e));
		return Promise.all(t);
	}
	object() {
		return this.#ct;
	}
}
class dt {
	#ct;
	constructor(e) {
		this.#ct = e;
	}
	static objectAsFunction(e) {
		if (!e || "function" !== e.type)
			throw new Error("Object is empty or not a function");
		return new dt(e);
	}
	targetFunction() {
		return this.#ct.getOwnProperties(!1).then(
			function (e) {
				if (!e.internalProperties) return this.#ct;
				const t = e.internalProperties;
				for (const e of t) if ("[[TargetFunction]]" === e.name) return e.value;
				return this.#ct;
			}.bind(this)
		);
	}
	targetFunctionDetails() {
		return this.targetFunction().then(
			function (t) {
				const n = e.bind(null, this.#ct !== t ? t : null);
				return t.debuggerModel().functionDetailsPromise(t).then(n);
			}.bind(this)
		);
		function e(e, t) {
			return (e && e.release(), t);
		}
	}
	object() {
		return this.#ct;
	}
}
const ct = /\(([0-9]+)\)/,
	ht = /\[([0-9]+)\]/;
var ut = Object.freeze({
	__proto__: null,
	RemoteObject: nt,
	RemoteObjectImpl: rt,
	ScopeRemoteObject: st,
	ScopeRef: it,
	RemoteObjectProperty: at,
	LocalJSONObject: ot,
	RemoteArrayBuffer: class {
		#ct;
		constructor(e) {
			if ("object" !== e.type || "arraybuffer" !== e.subtype)
				throw new Error("Object is not an arraybuffer");
			this.#ct = e;
		}
		byteLength() {
			return this.#ct.arrayBufferByteLength();
		}
		async bytes(e = 0, t = this.byteLength()) {
			if (e < 0 || e >= this.byteLength())
				throw new RangeError("start is out of range");
			if (t < e || t > this.byteLength())
				throw new RangeError("end is out of range");
			return await this.#ct.callFunctionJSON(
				function (e, t) {
					return [...new Uint8Array(this, e, t)];
				},
				[{ value: e }, { value: t - e }]
			);
		}
		object() {
			return this.#ct;
		}
	},
	RemoteArray: lt,
	RemoteFunction: dt,
	LinearMemoryInspectable: class {
		object;
		expression;
		constructor(e, t) {
			if (!e.isLinearMemoryInspectable())
				throw new Error("object must be linear memory inspectable");
			((this.object = e), (this.expression = t));
		}
	},
});
class gt extends c {
	constructor(e) {
		super(e);
	}
	async read(t, n, r) {
		const s = await this.target()
			.ioAgent()
			.invoke_read({ handle: t, offset: r, size: n });
		if (s.getError()) throw new Error(s.getError());
		return s.eof ? null : s.base64Encoded ? e.Base64.decode(s.data) : s.data;
	}
	async close(e) {
		(await this.target().ioAgent().invoke_close({ handle: e })).getError() &&
			console.error("Could not close stream.");
	}
	async resolveBlob(e) {
		const t = e instanceof nt ? e.objectId : e;
		if (!t) throw new Error("Remote object has undefined objectId");
		const n = await this.target().ioAgent().invoke_resolveBlob({ objectId: t });
		if (n.getError()) throw new Error(n.getError());
		return `blob:${n.uuid}`;
	}
	async readToString(e) {
		const t = [],
			n = new TextDecoder();
		for (;;) {
			const r = await this.read(e, 1048576);
			if (null === r) {
				t.push(n.decode());
				break;
			}
			r instanceof ArrayBuffer
				? t.push(n.decode(r, { stream: !0 }))
				: t.push(r);
		}
		return t.join("");
	}
}
c.register(gt, { capabilities: We.IO, autostart: !0 });
var pt = Object.freeze({ __proto__: null, IOModel: gt });
const mt = {
		noContentForWebSocket: "Content for WebSockets is currently not supported",
		noContentForRedirect:
			"No content available because this request was redirected",
		noContentForPreflight: "No content available for preflight request",
		noThrottling: "No throttling",
		offline: "Offline",
		slowG: "Slow 3G",
		fastG: "Fast 3G",
		requestWasBlockedByDevtoolsS: 'Request was blocked by DevTools: "{PH1}"',
		sFailedLoadingSS: '{PH1} failed loading: {PH2} "{PH3}".',
		sFinishedLoadingSS: '{PH1} finished loading: {PH2} "{PH3}".',
	},
	ft = i.i18n.registerUIStrings("core/sdk/NetworkManager.ts", mt),
	bt = i.i18n.getLocalizedString.bind(void 0, ft),
	yt = i.i18n.getLazilyComputedLocalizedString.bind(void 0, ft),
	vt = new WeakMap(),
	It = new Map([
		["2g", "cellular2g"],
		["3g", "cellular3g"],
		["4g", "cellular4g"],
		["bluetooth", "bluetooth"],
		["wifi", "wifi"],
		["wimax", "wimax"],
	]);
class kt extends c {
	dispatcher;
	fetchDispatcher;
	#ht;
	#ut;
	constructor(t) {
		(super(t),
			(this.dispatcher = new Pt(this)),
			(this.fetchDispatcher = new Mt(t.fetchAgent(), this)),
			(this.#ht = t.networkAgent()),
			t.registerNetworkDispatcher(this.dispatcher),
			t.registerFetchDispatcher(this.fetchDispatcher),
			e.Settings.Settings.instance().moduleSetting("cacheDisabled").get() &&
				this.#ht.invoke_setCacheDisabled({ cacheDisabled: !0 }),
			this.#ht.invoke_enable({ maxPostDataSize: xt }),
			this.#ht.invoke_setAttachDebugStack({ enabled: !0 }),
			(this.#ut = e.Settings.Settings.instance().createSetting(
				"bypassServiceWorker",
				!1
			)),
			this.#ut.get() && this.bypassServiceWorkerChanged(),
			this.#ut.addChangeListener(this.bypassServiceWorkerChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("cacheDisabled")
				.addChangeListener(this.cacheDisabledSettingChanged, this));
	}
	static forRequest(e) {
		return vt.get(e) || null;
	}
	static canReplayRequest(t) {
		return (
			Boolean(vt.get(t)) &&
			Boolean(t.backendRequestId()) &&
			!t.isRedirect() &&
			t.resourceType() === e.ResourceType.resourceTypes.XHR
		);
	}
	static replayRequest(e) {
		const t = vt.get(e),
			n = e.backendRequestId();
		t && n && !e.isRedirect() && t.#ht.invoke_replayXHR({ requestId: n });
	}
	static async searchInRequest(e, t, n, r) {
		const i = kt.forRequest(e),
			a = e.backendRequestId();
		if (!i || !a || e.isRedirect()) return [];
		const o = await i.#ht.invoke_searchInResponseBody({
			requestId: a,
			query: t,
			caseSensitive: n,
			isRegex: r,
		});
		return s.TextUtils.performSearchInSearchMatches(o.result || [], t, n, r);
	}
	static async requestContentData(t) {
		if (t.resourceType() === e.ResourceType.resourceTypes.WebSocket)
			return { error: bt(mt.noContentForWebSocket) };
		if ((t.finished || (await t.once(Jr.FinishedLoading)), t.isRedirect()))
			return { error: bt(mt.noContentForRedirect) };
		if (t.isPreflightRequest()) return { error: bt(mt.noContentForPreflight) };
		const n = kt.forRequest(t);
		if (!n) return { error: "No network manager for request" };
		const r = t.backendRequestId();
		if (!r) return { error: "No backend request id for request" };
		const s = await n.#ht.invoke_getResponseBody({ requestId: r }),
			i = s.getError();
		return i
			? { error: i }
			: new D(
					s.body,
					s.base64Encoded,
					t.resourceType(),
					t.mimeType,
					t.charset() ?? void 0
				);
	}
	static async requestPostData(e) {
		const t = kt.forRequest(e);
		if (!t) return (console.error("No network manager for request"), null);
		const n = e.backendRequestId();
		if (!n) return (console.error("No backend request id for request"), null);
		try {
			const { postData: e } = await t.#ht.invoke_getRequestPostData({
				requestId: n,
			});
			return e;
		} catch (e) {
			return e.message;
		}
	}
	static connectionType(e) {
		if (!e.download && !e.upload) return "none";
		const t =
			"function" == typeof e.title
				? e.title().toLowerCase()
				: e.title.toLowerCase();
		for (const [e, n] of It) if (t.includes(e)) return n;
		return "other";
	}
	static lowercaseHeaders(e) {
		const t = {};
		for (const n in e) t[n.toLowerCase()] = e[n];
		return t;
	}
	requestForURL(e) {
		return this.dispatcher.requestForURL(e);
	}
	requestForId(e) {
		return this.dispatcher.requestForId(e);
	}
	requestForLoaderId(e) {
		return this.dispatcher.requestForLoaderId(e);
	}
	cacheDisabledSettingChanged({ data: e }) {
		this.#ht.invoke_setCacheDisabled({ cacheDisabled: e });
	}
	dispose() {
		e.Settings.Settings.instance()
			.moduleSetting("cacheDisabled")
			.removeChangeListener(this.cacheDisabledSettingChanged, this);
	}
	bypassServiceWorkerChanged() {
		this.#ht.invoke_setBypassServiceWorker({ bypass: this.#ut.get() });
	}
	async getSecurityIsolationStatus(e) {
		const t = await this.#ht.invoke_getSecurityIsolationStatus({
			frameId: e ?? void 0,
		});
		return t.getError() ? null : t.status;
	}
	async enableReportingApi(e = !0) {
		return this.#ht.invoke_enableReportingApi({ enable: e });
	}
	async loadNetworkResource(e, t, n) {
		const r = await this.#ht.invoke_loadNetworkResource({
			frameId: e ?? void 0,
			url: t,
			options: n,
		});
		if (r.getError()) throw new Error(r.getError());
		return r.resource;
	}
	clearRequests() {
		this.dispatcher.clearRequests();
	}
}
var St;
!(function (e) {
	((e.RequestStarted = "RequestStarted"),
		(e.RequestUpdated = "RequestUpdated"),
		(e.RequestFinished = "RequestFinished"),
		(e.RequestUpdateDropped = "RequestUpdateDropped"),
		(e.ResponseReceived = "ResponseReceived"),
		(e.MessageGenerated = "MessageGenerated"),
		(e.RequestRedirected = "RequestRedirected"),
		(e.LoadingFinished = "LoadingFinished"),
		(e.ReportingApiReportAdded = "ReportingApiReportAdded"),
		(e.ReportingApiReportUpdated = "ReportingApiReportUpdated"),
		(e.ReportingApiEndpointsChangedForOrigin =
			"ReportingApiEndpointsChangedForOrigin"));
})(St || (St = {}));
const wt = {
		title: yt(mt.noThrottling),
		i18nTitleKey: mt.noThrottling,
		download: -1,
		upload: -1,
		latency: 0,
	},
	Ct = {
		title: yt(mt.offline),
		i18nTitleKey: mt.offline,
		download: 0,
		upload: 0,
		latency: 0,
	},
	Rt = {
		title: yt(mt.slowG),
		i18nTitleKey: mt.slowG,
		download: 5e4,
		upload: 5e4,
		latency: 2e3,
	},
	Tt = {
		title: yt(mt.fastG),
		i18nTitleKey: mt.fastG,
		download: 18e4,
		upload: 84375,
		latency: 562.5,
	},
	xt = 65536;
class Mt {
	#gt;
	#pt;
	constructor(e, t) {
		((this.#gt = e), (this.#pt = t));
	}
	requestPaused({
		requestId: e,
		request: t,
		resourceType: n,
		responseStatusCode: r,
		responseHeaders: s,
		networkId: i,
	}) {
		const a = i ? this.#pt.requestForId(i) : null;
		(0 === a?.originalResponseHeaders.length &&
			s &&
			(a.originalResponseHeaders = s),
			Et.instance().requestIntercepted(new Ot(this.#gt, t, n, e, a, r, s)));
	}
	authRequired({}) {}
}
class Pt {
	#pt;
	#mt;
	#ft;
	#bt;
	#yt;
	#vt;
	constructor(e) {
		((this.#pt = e),
			(this.#mt = new Map()),
			(this.#ft = new Map()),
			(this.#bt = new Map()),
			(this.#yt = new Map()),
			(this.#vt = new Map()),
			Et.instance().addEventListener(
				Et.Events.RequestIntercepted,
				this.#It.bind(this)
			));
	}
	#It(e) {
		const t = this.requestForId(e.data);
		t && t.setWasIntercepted(!0);
	}
	headersMapToHeadersArray(e) {
		const t = [];
		for (const n in e) {
			const r = e[n].split("\n");
			for (let e = 0; e < r.length; ++e) t.push({ name: n, value: r[e] });
		}
		return t;
	}
	updateNetworkRequestWithRequest(e, t) {
		((e.requestMethod = t.method),
			e.setRequestHeaders(this.headersMapToHeadersArray(t.headers)),
			e.setRequestFormData(Boolean(t.hasPostData), t.postData || null),
			e.setInitialPriority(t.initialPriority),
			(e.mixedContentType = t.mixedContentType || "none"),
			e.setReferrerPolicy(t.referrerPolicy),
			e.setIsSameSite(t.isSameSite || !1));
	}
	updateNetworkRequestWithResponse(t, n) {
		(n.url && t.url() !== n.url && t.setUrl(n.url),
			(t.mimeType = n.mimeType),
			(t.statusCode && !t.wasIntercepted()) || (t.statusCode = n.status),
			(t.statusText && !t.wasIntercepted()) || (t.statusText = n.statusText),
			(t.hasExtraResponseInfo() && !t.wasIntercepted()) ||
				(t.responseHeaders = this.headersMapToHeadersArray(n.headers)),
			n.encodedDataLength >= 0 && t.setTransferSize(n.encodedDataLength),
			n.requestHeaders &&
				!t.hasExtraRequestInfo() &&
				(t.setRequestHeaders(this.headersMapToHeadersArray(n.requestHeaders)),
				t.setRequestHeadersText(n.requestHeadersText || "")),
			(t.connectionReused = n.connectionReused),
			(t.connectionId = String(n.connectionId)),
			n.remoteIPAddress &&
				t.setRemoteAddress(n.remoteIPAddress, n.remotePort || -1),
			n.fromServiceWorker && (t.fetchedViaServiceWorker = !0),
			n.fromDiskCache && t.setFromDiskCache(),
			n.fromPrefetchCache && t.setFromPrefetchCache(),
			n.cacheStorageCacheName &&
				t.setResponseCacheStorageCacheName(n.cacheStorageCacheName),
			n.serviceWorkerRouterInfo &&
				(t.serviceWorkerRouterInfo = n.serviceWorkerRouterInfo),
			n.responseTime && t.setResponseRetrievalTime(new Date(n.responseTime)),
			(t.timing = n.timing),
			(t.protocol = n.protocol || ""),
			(t.alternateProtocolUsage = n.alternateProtocolUsage),
			n.serviceWorkerResponseSource &&
				t.setServiceWorkerResponseSource(n.serviceWorkerResponseSource),
			t.setSecurityState(n.securityState),
			n.securityDetails && t.setSecurityDetails(n.securityDetails));
		const r = e.ResourceType.ResourceType.fromMimeTypeOverride(t.mimeType);
		r && t.setResourceType(r);
	}
	requestForId(e) {
		return this.#mt.get(e) || null;
	}
	requestForURL(e) {
		return this.#ft.get(e) || null;
	}
	requestForLoaderId(e) {
		return this.#bt.get(e) || null;
	}
	resourceChangedPriority({ requestId: e, newPriority: t }) {
		const n = this.#mt.get(e);
		n && n.setPriority(t);
	}
	signedExchangeReceived({ requestId: t, info: n }) {
		let r = this.#mt.get(t);
		(r || ((r = this.#ft.get(n.outerResponse.url)), r)) &&
			(r.setSignedExchangeInfo(n),
			r.setResourceType(e.ResourceType.resourceTypes.SignedExchange),
			this.updateNetworkRequestWithResponse(r, n.outerResponse),
			this.updateNetworkRequest(r),
			this.#pt.dispatchEventToListeners(St.ResponseReceived, {
				request: r,
				response: n.outerResponse,
			}));
	}
	requestWillBeSent({
		requestId: t,
		loaderId: n,
		documentURL: r,
		request: s,
		timestamp: i,
		wallTime: a,
		initiator: o,
		redirectResponse: l,
		type: d,
		frameId: c,
		hasUserGesture: h,
	}) {
		let u = this.#mt.get(t);
		if (u) {
			if (!l) return;
			(u.signedExchangeInfo() ||
				this.responseReceived({
					requestId: t,
					loaderId: n,
					timestamp: i,
					type: d || "Other",
					response: l,
					hasExtraInfo: !1,
					frameId: c,
				}),
				(u = this.appendRedirect(t, i, s.url)),
				this.#pt.dispatchEventToListeners(St.RequestRedirected, u));
		} else
			((u = Xr.create(t, s.url, r, c ?? null, n, o, h)), vt.set(u, this.#pt));
		((u.hasNetworkData = !0),
			this.updateNetworkRequestWithRequest(u, s),
			u.setIssueTime(i, a),
			u.setResourceType(
				d ? e.ResourceType.resourceTypes[d] : e.ResourceType.resourceTypes.Other
			),
			s.trustTokenParams && u.setTrustTokenParams(s.trustTokenParams));
		const g = this.#vt.get(t);
		(g && (u.setTrustTokenOperationDoneEvent(g), this.#vt.delete(t)),
			this.getExtraInfoBuilder(t).addRequest(u),
			this.startNetworkRequest(u, s));
	}
	requestServedFromCache({ requestId: e }) {
		const t = this.#mt.get(e);
		t && t.setFromMemoryCache();
	}
	responseReceived({
		requestId: t,
		loaderId: n,
		timestamp: r,
		type: s,
		response: i,
		frameId: a,
	}) {
		const o = this.#mt.get(t),
			l = kt.lowercaseHeaders(i.headers);
		if (o)
			((o.responseReceivedTime = r),
				o.setResourceType(e.ResourceType.resourceTypes[s]),
				this.updateNetworkRequestWithResponse(o, i),
				this.updateNetworkRequest(o),
				this.#pt.dispatchEventToListeners(St.ResponseReceived, {
					request: o,
					response: i,
				}));
		else {
			const e = l["last-modified"],
				t = {
					url: i.url,
					frameId: a ?? null,
					loaderId: n,
					resourceType: s,
					mimeType: i.mimeType,
					lastModified: e ? new Date(e) : null,
				};
			this.#pt.dispatchEventToListeners(St.RequestUpdateDropped, t);
		}
	}
	dataReceived({
		requestId: e,
		timestamp: t,
		dataLength: n,
		encodedDataLength: r,
	}) {
		let s = this.#mt.get(e);
		(s || (s = this.maybeAdoptMainResourceRequest(e)),
			s &&
				((s.resourceSize += n),
				-1 !== r && s.increaseTransferSize(r),
				(s.endTime = t),
				this.updateNetworkRequest(s)));
	}
	loadingFinished({ requestId: e, timestamp: t, encodedDataLength: n }) {
		let r = this.#mt.get(e);
		(r || (r = this.maybeAdoptMainResourceRequest(e)),
			r &&
				(this.getExtraInfoBuilder(e).finished(),
				this.finishNetworkRequest(r, t, n),
				this.#pt.dispatchEventToListeners(St.LoadingFinished, r)));
	}
	loadingFailed({
		requestId: t,
		timestamp: n,
		type: r,
		errorText: s,
		canceled: i,
		blockedReason: a,
		corsErrorStatus: o,
	}) {
		const l = this.#mt.get(t);
		if (l) {
			if (
				((l.failed = !0),
				l.setResourceType(e.ResourceType.resourceTypes[r]),
				(l.canceled = Boolean(i)),
				a && (l.setBlockedReason(a), "inspector" === a))
			) {
				const e = bt(mt.requestWasBlockedByDevtoolsS, { PH1: l.url() });
				this.#pt.dispatchEventToListeners(St.MessageGenerated, {
					message: e,
					requestId: t,
					warning: !0,
				});
			}
			(o && l.setCorsErrorStatus(o),
				(l.localizedFailDescription = s),
				this.getExtraInfoBuilder(t).finished(),
				this.finishNetworkRequest(l, n, -1));
		}
	}
	webSocketCreated({ requestId: t, url: n, initiator: r }) {
		const s = Xr.createForWebSocket(t, n, r);
		(vt.set(s, this.#pt),
			s.setResourceType(e.ResourceType.resourceTypes.WebSocket),
			this.startNetworkRequest(s, null));
	}
	webSocketWillSendHandshakeRequest({
		requestId: e,
		timestamp: t,
		wallTime: n,
		request: r,
	}) {
		const s = this.#mt.get(e);
		s &&
			((s.requestMethod = "GET"),
			s.setRequestHeaders(this.headersMapToHeadersArray(r.headers)),
			s.setIssueTime(t, n),
			this.updateNetworkRequest(s));
	}
	webSocketHandshakeResponseReceived({
		requestId: e,
		timestamp: t,
		response: n,
	}) {
		const r = this.#mt.get(e);
		r &&
			((r.statusCode = n.status),
			(r.statusText = n.statusText),
			(r.responseHeaders = this.headersMapToHeadersArray(n.headers)),
			(r.responseHeadersText = n.headersText || ""),
			n.requestHeaders &&
				r.setRequestHeaders(this.headersMapToHeadersArray(n.requestHeaders)),
			n.requestHeadersText && r.setRequestHeadersText(n.requestHeadersText),
			(r.responseReceivedTime = t),
			(r.protocol = "websocket"),
			this.updateNetworkRequest(r));
	}
	webSocketFrameReceived({ requestId: e, timestamp: t, response: n }) {
		const r = this.#mt.get(e);
		r &&
			(r.addProtocolFrame(n, t, !1),
			(r.responseReceivedTime = t),
			this.updateNetworkRequest(r));
	}
	webSocketFrameSent({ requestId: e, timestamp: t, response: n }) {
		const r = this.#mt.get(e);
		r &&
			(r.addProtocolFrame(n, t, !0),
			(r.responseReceivedTime = t),
			this.updateNetworkRequest(r));
	}
	webSocketFrameError({ requestId: e, timestamp: t, errorMessage: n }) {
		const r = this.#mt.get(e);
		r &&
			(r.addProtocolFrameError(n, t),
			(r.responseReceivedTime = t),
			this.updateNetworkRequest(r));
	}
	webSocketClosed({ requestId: e, timestamp: t }) {
		const n = this.#mt.get(e);
		n && this.finishNetworkRequest(n, t, -1);
	}
	eventSourceMessageReceived({
		requestId: e,
		timestamp: t,
		eventName: n,
		eventId: r,
		data: s,
	}) {
		const i = this.#mt.get(e);
		i && i.addEventSourceMessage(t, n, r, s);
	}
	requestIntercepted({}) {}
	requestWillBeSentExtraInfo({
		requestId: e,
		associatedCookies: t,
		headers: n,
		clientSecurityState: r,
		connectTiming: s,
		siteHasCookieInOtherPartition: i,
	}) {
		const a = [],
			o = [];
		for (const { blockedReasons: e, cookie: n } of t)
			0 === e.length
				? o.push(U.fromProtocolCookie(n))
				: a.push({ blockedReasons: e, cookie: U.fromProtocolCookie(n) });
		const l = {
			blockedRequestCookies: a,
			includedRequestCookies: o,
			requestHeaders: this.headersMapToHeadersArray(n),
			clientSecurityState: r,
			connectTiming: s,
			siteHasCookieInOtherPartition: i,
		};
		this.getExtraInfoBuilder(e).addRequestExtraInfo(l);
	}
	responseReceivedExtraInfo({
		requestId: e,
		blockedCookies: t,
		headers: n,
		headersText: r,
		resourceIPAddressSpace: s,
		statusCode: i,
		cookiePartitionKey: a,
		cookiePartitionKeyOpaque: o,
	}) {
		const l = {
			blockedResponseCookies: t.map((e) => ({
				blockedReasons: e.blockedReasons,
				cookieLine: e.cookieLine,
				cookie: e.cookie ? U.fromProtocolCookie(e.cookie) : null,
			})),
			responseHeaders: this.headersMapToHeadersArray(n),
			responseHeadersText: r,
			resourceIPAddressSpace: s,
			statusCode: i,
			cookiePartitionKey: a,
			cookiePartitionKeyOpaque: o,
		};
		this.getExtraInfoBuilder(e).addResponseExtraInfo(l);
	}
	getExtraInfoBuilder(e) {
		let t;
		return (
			this.#yt.has(e)
				? (t = this.#yt.get(e))
				: ((t = new At()), this.#yt.set(e, t)),
			t
		);
	}
	appendRedirect(e, t, n) {
		const r = this.#mt.get(e);
		if (!r) throw new Error(`Could not find original network request for ${e}`);
		let s = 0;
		for (let e = r.redirectSource(); e; e = e.redirectSource()) s++;
		(r.markAsRedirect(s), this.finishNetworkRequest(r, t, -1));
		const i = Xr.create(
			e,
			n,
			r.documentURL,
			r.frameId,
			r.loaderId,
			r.initiator(),
			r.hasUserGesture() ?? void 0
		);
		return (
			vt.set(i, this.#pt),
			i.setRedirectSource(r),
			r.setRedirectDestination(i),
			i
		);
	}
	maybeAdoptMainResourceRequest(e) {
		const t = Et.instance().inflightMainResourceRequests.get(e);
		if (!t) return null;
		const n = kt.forRequest(t).dispatcher;
		(n.#mt.delete(e), n.#ft.delete(t.url()));
		const r = t.loaderId;
		r && n.#bt.delete(r);
		const s = n.#yt.get(e);
		return (
			n.#yt.delete(e),
			this.#mt.set(e, t),
			this.#ft.set(t.url(), t),
			r && this.#bt.set(r, t),
			s && this.#yt.set(e, s),
			vt.set(t, this.#pt),
			t
		);
	}
	startNetworkRequest(e, t) {
		(this.#mt.set(e.requestId(), e), this.#ft.set(e.url(), e));
		const n = e.loaderId;
		(n && this.#bt.set(n, e),
			e.loaderId === e.requestId() &&
				Et.instance().inflightMainResourceRequests.set(e.requestId(), e),
			this.#pt.dispatchEventToListeners(St.RequestStarted, {
				request: e,
				originalRequest: t,
			}));
	}
	updateNetworkRequest(e) {
		this.#pt.dispatchEventToListeners(St.RequestUpdated, e);
	}
	finishNetworkRequest(t, n, r) {
		if (((t.endTime = n), (t.finished = !0), r >= 0)) {
			const e = t.redirectSource();
			e && e.signedExchangeInfo()
				? (t.setTransferSize(0),
					e.setTransferSize(r),
					this.updateNetworkRequest(e))
				: t.setTransferSize(r);
		}
		if (
			(this.#pt.dispatchEventToListeners(St.RequestFinished, t),
			Et.instance().inflightMainResourceRequests.delete(t.requestId()),
			e.Settings.Settings.instance()
				.moduleSetting("monitoringXHREnabled")
				.get() &&
				t.resourceType().category() === e.ResourceType.resourceCategories.XHR)
		) {
			let e;
			const n = t.failed || t.hasErrorStatusCode();
			((e = bt(n ? mt.sFailedLoadingSS : mt.sFinishedLoadingSS, {
				PH1: t.resourceType().title(),
				PH2: t.requestMethod,
				PH3: t.url(),
			})),
				this.#pt.dispatchEventToListeners(St.MessageGenerated, {
					message: e,
					requestId: t.requestId(),
					warning: !1,
				}));
		}
	}
	clearRequests() {
		for (const [e, t] of this.#mt) t.finished && this.#mt.delete(e);
		for (const [e, t] of this.#ft) t.finished && this.#ft.delete(e);
		for (const [e, t] of this.#bt) t.finished && this.#bt.delete(e);
		for (const [e, t] of this.#yt) t.isFinished() && this.#yt.delete(e);
	}
	webTransportCreated({ transportId: t, url: n, timestamp: r, initiator: s }) {
		const i = Xr.createForWebSocket(t, n, s);
		((i.hasNetworkData = !0),
			vt.set(i, this.#pt),
			i.setResourceType(e.ResourceType.resourceTypes.WebTransport),
			i.setIssueTime(r, 0),
			this.startNetworkRequest(i, null));
	}
	webTransportConnectionEstablished({ transportId: e, timestamp: t }) {
		const n = this.#mt.get(e);
		n &&
			((n.responseReceivedTime = t),
			(n.endTime = t + 0.001),
			this.updateNetworkRequest(n));
	}
	webTransportClosed({ transportId: e, timestamp: t }) {
		const n = this.#mt.get(e);
		n && ((n.endTime = t), this.finishNetworkRequest(n, t, 0));
	}
	trustTokenOperationDone(e) {
		const t = this.#mt.get(e.requestId);
		t ? t.setTrustTokenOperationDoneEvent(e) : this.#vt.set(e.requestId, e);
	}
	subresourceWebBundleMetadataReceived({ requestId: e, urls: t }) {
		const n = this.getExtraInfoBuilder(e);
		n.setWebBundleInfo({ resourceUrls: t });
		const r = n.finalRequest();
		r && this.updateNetworkRequest(r);
	}
	subresourceWebBundleMetadataError({ requestId: e, errorMessage: t }) {
		const n = this.getExtraInfoBuilder(e);
		n.setWebBundleInfo({ errorMessage: t });
		const r = n.finalRequest();
		r && this.updateNetworkRequest(r);
	}
	subresourceWebBundleInnerResponseParsed({
		innerRequestId: e,
		bundleRequestId: t,
	}) {
		const n = this.getExtraInfoBuilder(e);
		n.setWebBundleInnerRequestInfo({ bundleRequestId: t });
		const r = n.finalRequest();
		r && this.updateNetworkRequest(r);
	}
	subresourceWebBundleInnerResponseError({
		innerRequestId: e,
		errorMessage: t,
	}) {
		const n = this.getExtraInfoBuilder(e);
		n.setWebBundleInnerRequestInfo({ errorMessage: t });
		const r = n.finalRequest();
		r && this.updateNetworkRequest(r);
	}
	reportingApiReportAdded(e) {
		this.#pt.dispatchEventToListeners(St.ReportingApiReportAdded, e.report);
	}
	reportingApiReportUpdated(e) {
		this.#pt.dispatchEventToListeners(St.ReportingApiReportUpdated, e.report);
	}
	reportingApiEndpointsChangedForOrigin(e) {
		this.#pt.dispatchEventToListeners(
			St.ReportingApiEndpointsChangedForOrigin,
			e
		);
	}
	createNetworkRequest(e, t, n, r, s, i) {
		const a = Xr.create(e, r, s, t, n, i);
		return (vt.set(a, this.#pt), a);
	}
}
let Lt;
class Et extends e.ObjectWrapper.ObjectWrapper {
	#kt;
	#St;
	#wt;
	#Ct;
	#Rt;
	inflightMainResourceRequests;
	#Tt;
	#xt;
	#Mt;
	#Pt;
	#Lt;
	#Et;
	#Ot;
	#At;
	constructor() {
		(super(),
			(this.#kt = ""),
			(this.#St = null),
			(this.#wt = null),
			(this.#Ct = new Set()),
			(this.#Rt = new Set()),
			(this.inflightMainResourceRequests = new Map()),
			(this.#Tt = wt),
			(this.#xt = null),
			(this.#Mt = e.Settings.Settings.instance().moduleSetting(
				"requestBlockingEnabled"
			)),
			(this.#Pt = e.Settings.Settings.instance().createSetting(
				"networkBlockedPatterns",
				[]
			)),
			(this.#Lt = []),
			this.updateBlockedPatterns(),
			(this.#Et = new t.MapUtilities.Multimap()),
			$e.instance().observeModels(kt, this));
	}
	static instance(e = { forceNew: null }) {
		const { forceNew: t } = e;
		return ((Lt && !t) || (Lt = new Et()), Lt);
	}
	static dispose() {
		Lt = null;
	}
	static getChromeVersion() {
		const e = navigator.userAgent.match(
			/(?:^|\W)(?:Chrome|HeadlessChrome)\/(\S+)/
		);
		return e && e.length > 1 ? e[1] : "";
	}
	static patchUserAgentWithChromeVersion(e) {
		const n = Et.getChromeVersion();
		if (n.length > 0) {
			const r = n.split(".", 1)[0] + ".0.100.0";
			return t.StringUtilities.sprintf(e, n, r);
		}
		return e;
	}
	static patchUserAgentMetadataWithChromeVersion(e) {
		if (!e.brands) return;
		const n = Et.getChromeVersion();
		if (0 === n.length) return;
		const r = n.split(".", 1)[0];
		for (const n of e.brands)
			n.version.includes("%s") &&
				(n.version = t.StringUtilities.sprintf(n.version, r));
		e.fullVersion &&
			e.fullVersion.includes("%s") &&
			(e.fullVersion = t.StringUtilities.sprintf(e.fullVersion, n));
	}
	modelAdded(e) {
		const t = e.target().networkAgent(),
			n = e.target().fetchAgent();
		(this.#Ot && t.invoke_setExtraHTTPHeaders({ headers: this.#Ot }),
			this.currentUserAgent() &&
				t.invoke_setUserAgentOverride({
					userAgent: this.currentUserAgent(),
					userAgentMetadata: this.#St || void 0,
				}),
			this.#Lt.length && t.invoke_setBlockedURLs({ urls: this.#Lt }),
			this.isIntercepting() &&
				n.invoke_enable({ patterns: this.#Et.valuesArray() }),
			null === this.#wt
				? t.invoke_clearAcceptedEncodingsOverride()
				: t.invoke_setAcceptedEncodings({ encodings: this.#wt }),
			this.#Ct.add(t),
			this.#Rt.add(n),
			this.isThrottling() && this.updateNetworkConditions(t));
	}
	modelRemoved(e) {
		for (const t of this.inflightMainResourceRequests) {
			kt.forRequest(t[1]) === e &&
				this.inflightMainResourceRequests.delete(t[0]);
		}
		(this.#Ct.delete(e.target().networkAgent()),
			this.#Rt.delete(e.target().fetchAgent()));
	}
	isThrottling() {
		return (
			this.#Tt.download >= 0 || this.#Tt.upload >= 0 || this.#Tt.latency > 0
		);
	}
	isOffline() {
		return !this.#Tt.download && !this.#Tt.upload;
	}
	setNetworkConditions(e) {
		this.#Tt = e;
		for (const e of this.#Ct) this.updateNetworkConditions(e);
		this.dispatchEventToListeners(Et.Events.ConditionsChanged);
	}
	networkConditions() {
		return this.#Tt;
	}
	updateNetworkConditions(e) {
		const t = this.#Tt;
		this.isThrottling()
			? e.invoke_emulateNetworkConditions({
					offline: this.isOffline(),
					latency: t.latency,
					downloadThroughput: t.download < 0 ? 0 : t.download,
					uploadThroughput: t.upload < 0 ? 0 : t.upload,
					connectionType: kt.connectionType(t),
				})
			: e.invoke_emulateNetworkConditions({
					offline: !1,
					latency: 0,
					downloadThroughput: 0,
					uploadThroughput: 0,
				});
	}
	setExtraHTTPHeaders(e) {
		this.#Ot = e;
		for (const e of this.#Ct)
			e.invoke_setExtraHTTPHeaders({ headers: this.#Ot });
	}
	currentUserAgent() {
		return this.#At ? this.#At : this.#kt;
	}
	updateUserAgentOverride() {
		const e = this.currentUserAgent();
		for (const t of this.#Ct)
			t.invoke_setUserAgentOverride({
				userAgent: e,
				userAgentMetadata: this.#St || void 0,
			});
	}
	setUserAgentOverride(e, t) {
		const n = this.#kt !== e;
		((this.#kt = e),
			this.#At
				? (this.#St = null)
				: ((this.#St = t), this.updateUserAgentOverride()),
			n && this.dispatchEventToListeners(Et.Events.UserAgentChanged));
	}
	userAgentOverride() {
		return this.#kt;
	}
	setCustomUserAgentOverride(e, t = null) {
		((this.#At = e), (this.#St = t), this.updateUserAgentOverride());
	}
	setCustomAcceptedEncodingsOverride(e) {
		((this.#wt = e),
			this.updateAcceptedEncodingsOverride(),
			this.dispatchEventToListeners(Et.Events.AcceptedEncodingsChanged));
	}
	clearCustomAcceptedEncodingsOverride() {
		((this.#wt = null),
			this.updateAcceptedEncodingsOverride(),
			this.dispatchEventToListeners(Et.Events.AcceptedEncodingsChanged));
	}
	isAcceptedEncodingOverrideSet() {
		return null !== this.#wt;
	}
	updateAcceptedEncodingsOverride() {
		const e = this.#wt;
		for (const t of this.#Ct)
			null === e
				? t.invoke_clearAcceptedEncodingsOverride()
				: t.invoke_setAcceptedEncodings({ encodings: e });
	}
	blockedPatterns() {
		return this.#Pt.get().slice();
	}
	blockingEnabled() {
		return this.#Mt.get();
	}
	isBlocking() {
		return Boolean(this.#Lt.length);
	}
	setBlockedPatterns(e) {
		(this.#Pt.set(e),
			this.updateBlockedPatterns(),
			this.dispatchEventToListeners(Et.Events.BlockedPatternsChanged));
	}
	setBlockingEnabled(e) {
		this.#Mt.get() !== e &&
			(this.#Mt.set(e),
			this.updateBlockedPatterns(),
			this.dispatchEventToListeners(Et.Events.BlockedPatternsChanged));
	}
	updateBlockedPatterns() {
		const e = [];
		if (this.#Mt.get())
			for (const t of this.#Pt.get()) t.enabled && e.push(t.url);
		if (e.length || this.#Lt.length) {
			this.#Lt = e;
			for (const e of this.#Ct) e.invoke_setBlockedURLs({ urls: this.#Lt });
		}
	}
	isIntercepting() {
		return Boolean(this.#Et.size);
	}
	setInterceptionHandlerForPatterns(e, t) {
		this.#Et.deleteAll(t);
		for (const n of e) this.#Et.set(t, n);
		return this.updateInterceptionPatternsOnNextTick();
	}
	updateInterceptionPatternsOnNextTick() {
		return (
			this.#xt ||
				(this.#xt = Promise.resolve().then(
					this.updateInterceptionPatterns.bind(this)
				)),
			this.#xt
		);
	}
	async updateInterceptionPatterns() {
		(e.Settings.Settings.instance().moduleSetting("cacheDisabled").get() ||
			e.Settings.Settings.instance().moduleSetting("cacheDisabled").set(!0),
			(this.#xt = null));
		const t = [];
		for (const e of this.#Rt)
			t.push(e.invoke_enable({ patterns: this.#Et.valuesArray() }));
		(this.dispatchEventToListeners(Et.Events.InterceptorsChanged),
			await Promise.all(t));
	}
	async requestIntercepted(e) {
		for (const t of this.#Et.keysArray())
			if ((await t(e), e.hasResponded() && e.networkRequest))
				return void this.dispatchEventToListeners(
					Et.Events.RequestIntercepted,
					e.networkRequest.requestId()
				);
		e.hasResponded() || e.continueRequestWithoutChange();
	}
	clearBrowserCache() {
		for (const e of this.#Ct) e.invoke_clearBrowserCache();
	}
	clearBrowserCookies() {
		for (const e of this.#Ct) e.invoke_clearBrowserCookies();
	}
	async getCertificate(e) {
		const t = $e.instance().primaryPageTarget();
		if (!t) return [];
		const n = await t.networkAgent().invoke_getCertificate({ origin: e });
		return n ? n.tableNames : [];
	}
	async loadResource(t) {
		const n = {},
			r = this.currentUserAgent();
		(r && (n["User-Agent"] = r),
			e.Settings.Settings.instance().moduleSetting("cacheDisabled").get() &&
				(n["Cache-Control"] = "no-cache"));
		const s = e.Settings.Settings.instance()
			.moduleSetting("network.enable-remote-file-loading")
			.get();
		return new Promise((e) =>
			o.ResourceLoader.load(
				t,
				n,
				(t, n, r, s) => {
					e({ success: t, content: r, errorDescription: s });
				},
				s
			)
		);
	}
}
!(function (e) {
	let t;
	!(function (e) {
		((e.BlockedPatternsChanged = "BlockedPatternsChanged"),
			(e.ConditionsChanged = "ConditionsChanged"),
			(e.UserAgentChanged = "UserAgentChanged"),
			(e.InterceptorsChanged = "InterceptorsChanged"),
			(e.AcceptedEncodingsChanged = "AcceptedEncodingsChanged"),
			(e.RequestIntercepted = "RequestIntercepted"),
			(e.RequestFulfilled = "RequestFulfilled"));
	})((t = e.Events || (e.Events = {})));
})(Et || (Et = {}));
class Ot {
	#gt;
	#Nt;
	request;
	resourceType;
	responseStatusCode;
	responseHeaders;
	requestId;
	networkRequest;
	constructor(e, t, n, r, s, i, a) {
		((this.#gt = e),
			(this.#Nt = !1),
			(this.request = t),
			(this.resourceType = n),
			(this.responseStatusCode = i),
			(this.responseHeaders = a),
			(this.requestId = r),
			(this.networkRequest = s));
	}
	hasResponded() {
		return this.#Nt;
	}
	static mergeSetCookieHeaders(e, t) {
		const n = (e) => {
				const t = new Map();
				for (const n of e) {
					const e = n.value.match(/^([a-zA-Z0-9!#$%&'*+.^_`|~-]+=)(.*)$/);
					e
						? t.has(e[1])
							? t.get(e[1])?.push(n.value)
							: t.set(e[1], [n.value])
						: t.has(n.value)
							? t.get(n.value)?.push(n.value)
							: t.set(n.value, [n.value]);
				}
				return t;
			},
			r = n(e),
			s = n(t),
			i = [];
		for (const [e, t] of r)
			if (s.has(e))
				for (const t of s.get(e) || [])
					i.push({ name: "set-cookie", value: t });
			else for (const e of t) i.push({ name: "set-cookie", value: e });
		for (const [e, t] of s)
			if (!r.has(e))
				for (const e of t) i.push({ name: "set-cookie", value: e });
		return i;
	}
	async continueRequestWithContent(e, t, n, r) {
		this.#Nt = !0;
		const s = t
				? await e.text()
				: await (async function (e) {
						const t = new FileReader(),
							n = new Promise((e) => {
								t.onloadend = e;
							});
						if ((t.readAsDataURL(e), await n, t.error))
							return (
								console.error("Could not convert blob to base64.", t.error),
								""
							);
						const r = t.result;
						if (null == r || "string" != typeof r)
							return (console.error("Could not convert blob to base64."), "");
						return r.substring(r.indexOf(",") + 1);
					})(e),
			i = r ? 200 : this.responseStatusCode || 200;
		if (this.networkRequest) {
			const e =
					this.networkRequest?.originalResponseHeaders.filter(
						(e) => "set-cookie" === e.name
					) || [],
				t = n.filter((e) => "set-cookie" === e.name);
			((this.networkRequest.setCookieHeaders = Ot.mergeSetCookieHeaders(e, t)),
				(this.networkRequest.hasOverriddenContent = r));
		}
		(this.#gt.invoke_fulfillRequest({
			requestId: this.requestId,
			responseCode: i,
			body: s,
			responseHeaders: n,
		}),
			Et.instance().dispatchEventToListeners(
				Et.Events.RequestFulfilled,
				this.request.url
			));
	}
	continueRequestWithoutChange() {
		(console.assert(!this.#Nt),
			(this.#Nt = !0),
			this.#gt.invoke_continueRequest({ requestId: this.requestId }));
	}
	continueRequestWithError(e) {
		(console.assert(!this.#Nt),
			(this.#Nt = !0),
			this.#gt.invoke_failRequest({
				requestId: this.requestId,
				errorReason: e,
			}));
	}
	async responseBody() {
		const e = await this.#gt.invoke_getResponseBody({
				requestId: this.requestId,
			}),
			t = e.getError() || null;
		return { error: t, content: t ? null : e.body, encoded: e.base64Encoded };
	}
	isRedirect() {
		return (
			void 0 !== this.responseStatusCode &&
			this.responseStatusCode >= 300 &&
			this.responseStatusCode < 400
		);
	}
}
class At {
	#Dt;
	#Ft;
	#Bt;
	#Ut;
	#Ht;
	#qt;
	constructor() {
		((this.#Dt = []),
			(this.#Ft = []),
			(this.#Bt = []),
			(this.#Ut = !1),
			(this.#Ht = null),
			(this.#qt = null));
	}
	addRequest(e) {
		(this.#Dt.push(e), this.sync(this.#Dt.length - 1));
	}
	addRequestExtraInfo(e) {
		(this.#Ft.push(e), this.sync(this.#Ft.length - 1));
	}
	addResponseExtraInfo(e) {
		(this.#Bt.push(e), this.sync(this.#Bt.length - 1));
	}
	setWebBundleInfo(e) {
		((this.#Ht = e), this.updateFinalRequest());
	}
	setWebBundleInnerRequestInfo(e) {
		((this.#qt = e), this.updateFinalRequest());
	}
	finished() {
		((this.#Ut = !0), this.updateFinalRequest());
	}
	isFinished() {
		return this.#Ut;
	}
	sync(e) {
		const t = this.#Dt[e];
		if (!t) return;
		const n = this.#Ft[e];
		n && (t.addExtraRequestInfo(n), (this.#Ft[e] = null));
		const r = this.#Bt[e];
		r && (t.addExtraResponseInfo(r), (this.#Bt[e] = null));
	}
	finalRequest() {
		return (this.#Ut && this.#Dt[this.#Dt.length - 1]) || null;
	}
	updateFinalRequest() {
		if (!this.#Ut) return;
		const e = this.finalRequest();
		(e?.setWebBundleInfo(this.#Ht), e?.setWebBundleInnerRequestInfo(this.#qt));
	}
}
c.register(kt, { capabilities: We.Network, autostart: !0 });
var Nt = Object.freeze({
	__proto__: null,
	NetworkManager: kt,
	get Events() {
		return St;
	},
	NoThrottlingConditions: wt,
	OfflineConditions: Ct,
	Slow3GConditions: Rt,
	Fast3GConditions: Tt,
	FetchDispatcher: Mt,
	NetworkDispatcher: Pt,
	get MultitargetNetworkManager() {
		return Et;
	},
	InterceptedRequest: Ot,
	ConditionsSerializer: class {
		stringify(e) {
			const t = e;
			return JSON.stringify({
				...t,
				title: "function" == typeof t.title ? t.title() : t.title,
			});
		}
		parse(e) {
			const t = JSON.parse(e);
			return { ...t, title: t.i18nTitleKey ? yt(t.i18nTitleKey) : t.title };
		}
	},
	networkConditionsEqual: function (e, t) {
		const n = "function" == typeof e.title ? e.title() : e.title,
			r = "function" == typeof t.title ? t.title() : t.title;
		return (
			t.download === e.download &&
			t.upload === e.upload &&
			t.latency === e.latency &&
			r === n
		);
	},
});
const Dt = {
		loadCanceledDueToReloadOf: "Load canceled due to reload of inspected page",
	},
	Ft = i.i18n.registerUIStrings("core/sdk/PageResourceLoader.ts", Dt),
	Bt = i.i18n.getLocalizedString.bind(void 0, Ft);
let Ut = null;
class Ht extends e.ObjectWrapper.ObjectWrapper {
	#_t;
	#zt;
	#jt;
	#Wt;
	#Vt;
	#Gt;
	constructor(e, t) {
		(super(),
			(this.#_t = 0),
			(this.#zt = new Map()),
			(this.#jt = t),
			(this.#Wt = new Map()),
			(this.#Vt = []),
			$e
				.instance()
				.addModelListener(
					Pr,
					xr.PrimaryPageChanged,
					this.onPrimaryPageChanged,
					this
				),
			(this.#Gt = e));
	}
	static instance(
		{ forceNew: e, loadOverride: t, maxConcurrentLoads: n } = {
			forceNew: !1,
			loadOverride: null,
			maxConcurrentLoads: 500,
		}
	) {
		return ((Ut && !e) || (Ut = new Ht(t, n)), Ut);
	}
	static removeInstance() {
		Ut = null;
	}
	onPrimaryPageChanged(e) {
		const { frame: t, type: n } = e.data;
		if (!t.isOutermostFrame()) return;
		for (const { reject: e } of this.#Vt)
			e(new Error(Bt(Dt.loadCanceledDueToReloadOf)));
		this.#Vt = [];
		const r = t.resourceTreeModel().target(),
			s = new Map();
		for (const [e, t] of this.#Wt.entries())
			"Activation" === n && r === t.initiator.target && s.set(e, t);
		((this.#Wt = s), this.dispatchEventToListeners(_t.Update));
	}
	getResourcesLoaded() {
		return this.#Wt;
	}
	getScopedResourcesLoaded() {
		return new Map(
			[...this.#Wt].filter(([e, t]) =>
				$e.instance().isInScope(t.initiator.target)
			)
		);
	}
	getNumberOfResources() {
		return {
			loading: this.#_t,
			queued: this.#Vt.length,
			resources: this.#Wt.size,
		};
	}
	getScopedNumberOfResources() {
		const e = $e.instance();
		let t = 0;
		for (const [n, r] of this.#zt) {
			const s = e.targetById(n);
			e.isInScope(s) && (t += r);
		}
		return { loading: t, resources: this.getScopedResourcesLoaded().size };
	}
	async acquireLoadSlot(e) {
		if ((this.#_t++, e)) {
			const t = this.#zt.get(e.id()) || 0;
			this.#zt.set(e.id(), t + 1);
		}
		if (this.#_t > this.#jt) {
			const e = { resolve: () => {}, reject: () => {} },
				t = new Promise((t, n) => {
					((e.resolve = t), (e.reject = n));
				});
			(this.#Vt.push(e), await t);
		}
	}
	releaseLoadSlot(e) {
		if ((this.#_t--, e)) {
			const t = this.#zt.get(e.id());
			t && this.#zt.set(e.id(), t - 1);
		}
		const t = this.#Vt.shift();
		t && t.resolve();
	}
	static makeKey(e, t) {
		if (t.frameId) return `${e}-${t.frameId}`;
		if (t.target) return `${e}-${t.target.id()}`;
		throw new Error("Invalid initiator");
	}
	async loadResource(e, t) {
		const n = Ht.makeKey(e, t),
			r = {
				success: null,
				size: null,
				errorMessage: void 0,
				url: e,
				initiator: t,
			};
		(this.#Wt.set(n, r), this.dispatchEventToListeners(_t.Update));
		try {
			await this.acquireLoadSlot(t.target);
			const n = this.dispatchLoad(e, t),
				s = await n;
			if (
				((r.errorMessage = s.errorDescription.message),
				(r.success = s.success),
				s.success)
			)
				return ((r.size = s.content.length), { content: s.content });
			throw new Error(s.errorDescription.message);
		} catch (e) {
			throw (
				void 0 === r.errorMessage && (r.errorMessage = e.message),
				null === r.success && (r.success = !1),
				e
			);
		} finally {
			(this.releaseLoadSlot(t.target),
				this.dispatchEventToListeners(_t.Update));
		}
	}
	async dispatchLoad(t, n) {
		let r = null;
		if (this.#Gt) return this.#Gt(t);
		const s = new e.ParsedURL.ParsedURL(t),
			i =
				qt().get() &&
				s &&
				"file" !== s.scheme &&
				"data" !== s.scheme &&
				"devtools" !== s.scheme;
		if (
			(o.userMetrics.developerResourceScheme(
				this.getDeveloperResourceScheme(s)
			),
			i)
		) {
			try {
				if (n.target) {
					o.userMetrics.developerResourceLoaded(
						o.UserMetrics.DeveloperResourceLoaded.LoadThroughPageViaTarget
					);
					return await this.loadFromTarget(n.target, n.frameId, t);
				}
				const e = Ze.instance().getFrame(n.frameId);
				if (e) {
					o.userMetrics.developerResourceLoaded(
						o.UserMetrics.DeveloperResourceLoaded.LoadThroughPageViaFrame
					);
					return await this.loadFromTarget(
						e.resourceTreeModel().target(),
						n.frameId,
						t
					);
				}
			} catch (e) {
				e instanceof Error &&
					(o.userMetrics.developerResourceLoaded(
						o.UserMetrics.DeveloperResourceLoaded.LoadThroughPageFailure
					),
					(r = e.message));
			}
			o.userMetrics.developerResourceLoaded(
				o.UserMetrics.DeveloperResourceLoaded.LoadThroughPageFallback
			);
		} else {
			const e = qt().get()
				? o.UserMetrics.DeveloperResourceLoaded.FallbackPerProtocol
				: o.UserMetrics.DeveloperResourceLoaded.FallbackPerOverride;
			o.userMetrics.developerResourceLoaded(e);
		}
		const a = await Et.instance().loadResource(t);
		return (
			i &&
				!a.success &&
				o.userMetrics.developerResourceLoaded(
					o.UserMetrics.DeveloperResourceLoaded.FallbackFailure
				),
			r &&
				(a.errorDescription.message = `Fetch through target failed: ${r}; Fallback: ${a.errorDescription.message}`),
			a
		);
	}
	getDeveloperResourceScheme(e) {
		if (!e || "" === e.scheme)
			return o.UserMetrics.DeveloperResourceScheme.SchemeUnknown;
		const t = "localhost" === e.host || e.host.endsWith(".localhost");
		switch (e.scheme) {
			case "file":
				return o.UserMetrics.DeveloperResourceScheme.SchemeFile;
			case "data":
				return o.UserMetrics.DeveloperResourceScheme.SchemeData;
			case "blob":
				return o.UserMetrics.DeveloperResourceScheme.SchemeBlob;
			case "http":
				return t
					? o.UserMetrics.DeveloperResourceScheme.SchemeHttpLocalhost
					: o.UserMetrics.DeveloperResourceScheme.SchemeHttp;
			case "https":
				return t
					? o.UserMetrics.DeveloperResourceScheme.SchemeHttpsLocalhost
					: o.UserMetrics.DeveloperResourceScheme.SchemeHttps;
		}
		return o.UserMetrics.DeveloperResourceScheme.SchemeOther;
	}
	async loadFromTarget(t, n, r) {
		const s = t.model(kt),
			i = t.model(gt),
			a = e.Settings.Settings.instance().moduleSetting("cacheDisabled").get(),
			l = await s.loadNetworkResource(n, r, {
				disableCache: a,
				includeCredentials: !0,
			});
		try {
			const e = l.stream ? await i.readToString(l.stream) : "";
			return {
				success: l.success,
				content: e,
				errorDescription: {
					statusCode: l.httpStatusCode || 0,
					netError: l.netError,
					netErrorName: l.netErrorName,
					message:
						o.ResourceLoader.netErrorToMessage(
							l.netError,
							l.httpStatusCode,
							l.netErrorName
						) || "",
					urlValid: void 0,
				},
			};
		} finally {
			l.stream && i.close(l.stream);
		}
	}
}
function qt() {
	return e.Settings.Settings.instance().createSetting("loadThroughTarget", !0);
}
var _t;
(_t || (_t = {})).Update = "Update";
var zt = Object.freeze({
	__proto__: null,
	PageResourceLoader: Ht,
	getLoadThroughTargetSetting: qt,
	get Events() {
		return _t;
	},
});
function jt(e) {
	return (
		e.startsWith(")]}") && (e = e.substring(e.indexOf("\n"))),
		65279 === e.charCodeAt(0) && (e = e.slice(1)),
		JSON.parse(e)
	);
}
class Wt {
	lineNumber;
	columnNumber;
	sourceURL;
	sourceLineNumber;
	sourceColumnNumber;
	name;
	constructor(e, t, n, r, s, i) {
		((this.lineNumber = e),
			(this.columnNumber = t),
			(this.sourceURL = n),
			(this.sourceLineNumber = r),
			(this.sourceColumnNumber = s),
			(this.name = i));
	}
	static compare(e, t) {
		return e.lineNumber !== t.lineNumber
			? e.lineNumber - t.lineNumber
			: e.columnNumber - t.columnNumber;
	}
}
function Vt(e, t) {
	return e.lineNumber - t.lineNumber || e.columnNumber - t.columnNumber;
}
class Gt {
	startLineNumber;
	startColumnNumber;
	endLineNumber;
	endColumnNumber;
	name;
	children = [];
	constructor(e, t, n, r, s) {
		((this.startLineNumber = e),
			(this.startColumnNumber = t),
			(this.endLineNumber = n),
			(this.endColumnNumber = r),
			(this.name = s));
	}
	scopeName() {
		return this.name;
	}
	start() {
		return {
			lineNumber: this.startLineNumber,
			columnNumber: this.startColumnNumber,
		};
	}
	end() {
		return {
			lineNumber: this.endLineNumber,
			columnNumber: this.endColumnNumber,
		};
	}
}
const Kt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	Qt = new Map();
for (let e = 0; e < 64; ++e) Qt.set(Kt.charAt(e), e);
const $t = new WeakMap();
class Xt {
	#Kt;
	#Qt;
	#$t;
	#Xt;
	#Jt;
	#Yt;
	constructor(t, n, r) {
		((this.#Kt = r),
			(this.#Qt = t),
			(this.#$t = n),
			(this.#Xt = e.ParsedURL.schemeIs(n, "data:") ? t : n),
			(this.#Jt = null),
			(this.#Yt = new Map()),
			"sections" in this.#Kt &&
				this.#Kt.sections.find((e) => "url" in e) &&
				e.Console.Console.instance().warn(
					`SourceMap "${n}" contains unsupported "URL" field in one of its sections.`
				),
			this.eachSection(this.parseSources.bind(this)));
	}
	compiledURL() {
		return this.#Qt;
	}
	url() {
		return this.#$t;
	}
	sourceURLs() {
		return [...this.#Yt.keys()];
	}
	embeddedContentByURL(e) {
		const t = this.#Yt.get(e);
		return t ? t.content : null;
	}
	findEntry(e, n) {
		const r = this.mappings(),
			s = t.ArrayUtilities.upperBound(
				r,
				void 0,
				(t, r) => e - r.lineNumber || n - r.columnNumber
			);
		return s ? r[s - 1] : null;
	}
	findEntryRanges(e, n) {
		const r = this.mappings(),
			i = t.ArrayUtilities.upperBound(
				r,
				void 0,
				(t, r) => e - r.lineNumber || n - r.columnNumber
			);
		if (!i) return null;
		const a = i - 1,
			o = r[a].sourceURL;
		if (!o) return null;
		const l = i < r.length ? r[i].lineNumber : 2 ** 31 - 1,
			d = i < r.length ? r[i].columnNumber : 2 ** 31 - 1,
			c = new s.TextRange.TextRange(r[a].lineNumber, r[a].columnNumber, l, d),
			h = this.reversedMappings(o),
			u = r[a].sourceLineNumber,
			g = r[a].sourceColumnNumber,
			p = t.ArrayUtilities.upperBound(
				h,
				void 0,
				(e, t) => u - r[t].sourceLineNumber || g - r[t].sourceColumnNumber
			);
		if (!p) return null;
		const m = p < h.length ? r[h[p]].sourceLineNumber : 2 ** 31 - 1,
			f = p < h.length ? r[h[p]].sourceColumnNumber : 2 ** 31 - 1;
		return {
			range: c,
			sourceRange: new s.TextRange.TextRange(u, g, m, f),
			sourceURL: o,
		};
	}
	sourceLineMapping(e, n, r) {
		const s = this.mappings(),
			i = this.reversedMappings(e),
			a = t.ArrayUtilities.lowerBound(i, n, c),
			o = t.ArrayUtilities.upperBound(i, n, c);
		if (a >= i.length || s[i[a]].sourceLineNumber !== n) return null;
		const l = i.slice(a, o);
		if (!l.length) return null;
		const d = t.ArrayUtilities.lowerBound(
			l,
			r,
			(e, t) => e - s[t].sourceColumnNumber
		);
		return d >= l.length ? s[l[l.length - 1]] : s[l[d]];
		function c(e, t) {
			return e - s[t].sourceLineNumber;
		}
	}
	findReverseIndices(e, n, r) {
		const s = this.mappings(),
			i = this.reversedMappings(e),
			a = t.ArrayUtilities.upperBound(
				i,
				void 0,
				(e, t) => n - s[t].sourceLineNumber || r - s[t].sourceColumnNumber
			);
		let o = a;
		for (
			;
			o > 0 &&
			s[i[o - 1]].sourceLineNumber === s[i[a - 1]].sourceLineNumber &&
			s[i[o - 1]].sourceColumnNumber === s[i[a - 1]].sourceColumnNumber;

		)
			--o;
		return i.slice(o, a);
	}
	findReverseEntries(e, t, n) {
		const r = this.mappings();
		return this.findReverseIndices(e, t, n).map((e) => r[e]);
	}
	findReverseRanges(e, t, n) {
		const r = this.mappings(),
			i = this.findReverseIndices(e, t, n),
			a = [];
		for (let e = 0; e < i.length; ++e) {
			const t = i[e];
			let n = t + 1;
			for (; e + 1 < i.length && n === i[e + 1]; ) (++n, ++e);
			const o = r[t].lineNumber,
				l = r[t].columnNumber,
				d = n < r.length ? r[n].lineNumber : 2 ** 31 - 1,
				c = n < r.length ? r[n].columnNumber : 2 ** 31 - 1;
			a.push(new s.TextRange.TextRange(o, l, d, c));
		}
		return a;
	}
	mappings() {
		return (this.#Zt(), this.#Jt ?? []);
	}
	reversedMappings(e) {
		return (this.#Zt(), this.#Yt.get(e)?.reverseMappings ?? []);
	}
	#Zt() {
		null === this.#Jt &&
			((this.#Jt = []),
			this.eachSection(this.parseMap.bind(this)),
			this.mappings().sort(Wt.compare),
			this.#en(this.#Jt),
			(this.#Kt = null));
	}
	#en(e) {
		const t = new Map();
		for (let n = 0; n < e.length; n++) {
			const r = e[n].sourceURL;
			if (!r) continue;
			let s = t.get(r);
			(s || ((s = []), t.set(r, s)), s.push(n));
		}
		for (const [e, r] of t.entries()) {
			const t = this.#Yt.get(e);
			t && (r.sort(n), (t.reverseMappings = r));
		}
		function n(t, n) {
			const r = e[t],
				s = e[n];
			return (
				r.sourceLineNumber - s.sourceLineNumber ||
				r.sourceColumnNumber - s.sourceColumnNumber ||
				r.lineNumber - s.lineNumber ||
				r.columnNumber - s.columnNumber
			);
		}
	}
	eachSection(e) {
		if (this.#Kt)
			if ("sections" in this.#Kt)
				for (const t of this.#Kt.sections)
					"map" in t && e(t.map, t.offset.line, t.offset.column);
			else e(this.#Kt, 0, 0);
	}
	parseSources(t) {
		const n = [],
			r = t.sourceRoot ?? "",
			s = new Set(t.ignoreList ?? t.x_google_ignoreList);
		for (let i = 0; i < t.sources.length; ++i) {
			let a = t.sources[i];
			e.ParsedURL.ParsedURL.isRelativeURL(a) &&
				(a =
					r && !r.endsWith("/") && a && !a.startsWith("/")
						? r.concat("/", a)
						: r.concat(a));
			const o = e.ParsedURL.ParsedURL.completeURL(this.#Xt, a) || a,
				l = t.sourcesContent && t.sourcesContent[i];
			if ((n.push(o), !this.#Yt.has(o))) {
				const e = l ?? null,
					t = s.has(i);
				this.#Yt.set(o, {
					content: e,
					ignoreListHint: t,
					reverseMappings: null,
					scopeTree: null,
				});
			}
		}
		$t.set(t, n);
	}
	parseMap(e, t, n) {
		let r = 0,
			s = 0,
			i = 0,
			o = 0;
		const l = $t.get(e),
			d = e.names ?? [],
			c = new Xt.StringCharIterator(e.mappings);
		let h = l && l[r];
		for (;;) {
			if ("," === c.peek()) c.next();
			else {
				for (; ";" === c.peek(); ) ((t += 1), (n = 0), c.next());
				if (!c.hasNext()) break;
			}
			if (
				((n += this.decodeVLQ(c)), !c.hasNext() || this.isSeparator(c.peek()))
			) {
				this.mappings().push(new Wt(t, n));
				continue;
			}
			const e = this.decodeVLQ(c);
			(e && ((r += e), l && (h = l[r])),
				(s += this.decodeVLQ(c)),
				(i += this.decodeVLQ(c)),
				c.hasNext() && !this.isSeparator(c.peek())
					? ((o += this.decodeVLQ(c)),
						this.mappings().push(new Wt(t, n, h, s, i, d[o])))
					: this.mappings().push(new Wt(t, n, h, s, i)));
		}
		a.Runtime.experiments.isEnabled(
			a.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES
		) && this.parseScopes(e);
	}
	parseScopes(e) {
		if (!e.x_com_bloomberg_sourcesFunctionMappings) return;
		const t = $t.get(e);
		if (!t) return;
		const n = e.names ?? [],
			r = e.x_com_bloomberg_sourcesFunctionMappings;
		for (let e = 0; e < t?.length; e++) {
			if (!r[e] || !t[e]) continue;
			const s = this.#Yt.get(t[e]);
			if (!s) continue;
			const i = r[e];
			let a = 0,
				o = 0,
				l = 0,
				d = 0,
				c = 0;
			const h = new Xt.StringCharIterator(i),
				u = [];
			let g = !0;
			for (; h.hasNext(); ) {
				if (g) g = !1;
				else {
					if ("," !== h.peek()) return;
					h.next();
				}
				((a += this.decodeVLQ(h)),
					(o += this.decodeVLQ(h)),
					(l += this.decodeVLQ(h)),
					(d += this.decodeVLQ(h)),
					(c += this.decodeVLQ(h)),
					u.push(new Gt(o, l, d, c, n[a] ?? "<invalid>")));
			}
			s.scopeTree = this.buildScopeTree(u);
		}
	}
	buildScopeTree(e) {
		const t = [];
		e.sort((e, t) => Vt(e.start(), t.start()));
		const n = [];
		for (const r of e) {
			const e = r.start();
			for (; n.length > 0; ) {
				if (!(Vt(n[n.length - 1].end(), e) < 0)) break;
				n.pop();
			}
			(n.length > 0 ? n[n.length - 1].children.push(r) : t.push(r), n.push(r));
		}
		return t;
	}
	findScopeEntry(e, t, n) {
		const r = this.#Yt.get(e);
		if (!r || !r.scopeTree) return null;
		const s = { lineNumber: t, columnNumber: n };
		let i = null;
		for (;;) {
			const e = (i?.children ?? r.scopeTree).find(
				(e) => Vt(e.start(), s) <= 0 && Vt(s, e.end()) <= 0
			);
			if (!e) return i;
			i = e;
		}
	}
	isSeparator(e) {
		return "," === e || ";" === e;
	}
	decodeVLQ(e) {
		let t = 0,
			n = 0,
			r = Xt._VLQ_CONTINUATION_MASK;
		for (; r & Xt._VLQ_CONTINUATION_MASK; )
			((r = Qt.get(e.next()) || 0),
				(t += (r & Xt._VLQ_BASE_MASK) << n),
				(n += Xt._VLQ_BASE_SHIFT));
		const s = 1 & t;
		return ((t >>= 1), s ? -t : t);
	}
	reverseMapTextRanges(e, n) {
		const r = this.reversedMappings(e),
			i = this.mappings();
		if (0 === r.length) return [];
		let a = t.ArrayUtilities.lowerBound(
			r,
			n,
			({ startLine: e, startColumn: t }, n) => {
				const { sourceLineNumber: r, sourceColumnNumber: s } = i[n];
				return e - r || t - s;
			}
		);
		for (
			;
			a === r.length ||
			(a > 0 &&
				(i[r[a]].sourceLineNumber > n.startLine ||
					i[r[a]].sourceColumnNumber > n.startColumn));

		)
			a--;
		let o = a + 1;
		for (; o < r.length; ++o) {
			const { sourceLineNumber: e, sourceColumnNumber: t } = i[r[o]];
			if (!(e < n.endLine || (e === n.endLine && t < n.endColumn))) break;
		}
		const l = [];
		for (let e = a; e < o; ++e) {
			const t = r[e],
				n = t + 1,
				a = s.TextRange.TextRange.createUnboundedFromLocation(
					i[t].lineNumber,
					i[t].columnNumber
				);
			(n < i.length &&
				((a.endLine = i[n].lineNumber), (a.endColumn = i[n].columnNumber)),
				l.push(a));
		}
		l.sort(s.TextRange.TextRange.comparator);
		let d = 0;
		for (let e = 1; e < l.length; ++e)
			l[d].immediatelyPrecedes(l[e])
				? ((l[d].endLine = l[e].endLine), (l[d].endColumn = l[e].endColumn))
				: (l[++d] = l[e]);
		return ((l.length = d + 1), l);
	}
	mapsOrigin() {
		const e = this.mappings();
		if (e.length > 0) {
			const t = e[0];
			return 0 === t?.lineNumber || 0 === t.columnNumber;
		}
		return !1;
	}
	hasIgnoreListHint(e) {
		return this.#Yt.get(e)?.ignoreListHint ?? !1;
	}
	findRanges(e, t) {
		const n = this.mappings(),
			r = [];
		if (!n.length) return [];
		let i = null;
		(0 === n[0].lineNumber && 0 === n[0].columnNumber) ||
			!t?.isStartMatching ||
			((i = s.TextRange.TextRange.createUnboundedFromLocation(0, 0)),
			r.push(i));
		for (const { sourceURL: t, lineNumber: a, columnNumber: o } of n) {
			const n = t && e(t);
			i || !n
				? i && !n && ((i.endLine = a), (i.endColumn = o), (i = null))
				: ((i = s.TextRange.TextRange.createUnboundedFromLocation(a, o)),
					r.push(i));
		}
		return r;
	}
	compatibleForURL(e, t) {
		return (
			this.embeddedContentByURL(e) === t.embeddedContentByURL(e) &&
			this.hasIgnoreListHint(e) === t.hasIgnoreListHint(e)
		);
	}
}
!(function (e) {
	((e._VLQ_BASE_SHIFT = 5),
		(e._VLQ_BASE_MASK = 31),
		(e._VLQ_CONTINUATION_MASK = 32));
	e.StringCharIterator = class {
		string;
		position;
		constructor(e) {
			((this.string = e), (this.position = 0));
		}
		next() {
			return this.string.charAt(this.position++);
		}
		peek() {
			return this.string.charAt(this.position);
		}
		hasNext() {
			return this.position < this.string.length;
		}
	};
})(Xt || (Xt = {}));
var Jt,
	Yt = Object.freeze({
		__proto__: null,
		parseSourceMap: jt,
		SourceMapEntry: Wt,
		get SourceMap() {
			return Xt;
		},
	});
class Zt extends e.ObjectWrapper.ObjectWrapper {
	#tn;
	#nn;
	#rn;
	#sn;
	#in;
	constructor(e) {
		(super(),
			(this.#tn = e),
			(this.#nn = !0),
			(this.#in = null),
			(this.#rn = new Map()),
			(this.#sn = new Map()),
			$e
				.instance()
				.addEventListener(
					Xe.InspectedURLChanged,
					this.inspectedURLChanged,
					this
				));
	}
	setEnabled(e) {
		if (e === this.#nn) return;
		const t = [...this.#rn.entries()];
		for (const [e] of t) this.detachSourceMap(e);
		this.#nn = e;
		for (const [e, { relativeSourceURL: n, relativeSourceMapURL: r }] of t)
			this.attachSourceMap(e, n, r);
	}
	static getBaseUrl(e) {
		for (; e && e.type() !== je.Frame; ) e = e.parentTarget();
		return e?.inspectedURL() ?? t.DevToolsPath.EmptyUrlString;
	}
	static resolveRelativeSourceURL(t, n) {
		return (n = e.ParsedURL.ParsedURL.completeURL(Zt.getBaseUrl(t), n) ?? n);
	}
	inspectedURLChanged(e) {
		if (e.data !== this.#tn) return;
		const t = [...this.#rn.entries()];
		for (const [e, { relativeSourceURL: n, relativeSourceMapURL: r }] of t)
			(this.detachSourceMap(e), this.attachSourceMap(e, n, r));
	}
	sourceMapForClient(e) {
		return this.#rn.get(e)?.sourceMap;
	}
	sourceMapForClientPromise(e) {
		const t = this.#rn.get(e);
		return t ? t.sourceMapPromise : Promise.resolve(void 0);
	}
	clientForSourceMap(e) {
		return this.#sn.get(e);
	}
	attachSourceMap(t, n, r) {
		if (this.#rn.has(t))
			throw new Error(
				"SourceMap is already attached or being attached to client"
			);
		if (!r) return;
		let s = {
			relativeSourceURL: n,
			relativeSourceMapURL: r,
			sourceMap: void 0,
			sourceMapPromise: Promise.resolve(void 0),
		};
		if (this.#nn) {
			const i = Zt.resolveRelativeSourceURL(this.#tn, n),
				a = e.ParsedURL.ParsedURL.completeURL(i, r);
			if (a)
				if (
					(this.#in &&
						console.error(
							"Attaching source map may cancel previously attaching source map"
						),
					(this.#in = t),
					this.dispatchEventToListeners(Jt.SourceMapWillAttach, { client: t }),
					this.#in === t)
				) {
					this.#in = null;
					const e = t.createPageResourceLoadInitiator();
					s.sourceMapPromise = (async function (e, t) {
						try {
							const { content: n } = await Ht.instance().loadResource(e, t);
							return jt(n);
						} catch (t) {
							throw new Error(`Could not load content for ${e}: ${t.message}`, {
								cause: t,
							});
						}
					})(a, e).then(
						(e) => {
							const n = new Xt(i, a, e);
							return (
								this.#rn.get(t) === s &&
									((s.sourceMap = n),
									this.#sn.set(n, t),
									this.dispatchEventToListeners(Jt.SourceMapAttached, {
										client: t,
										sourceMap: n,
									})),
								n
							);
						},
						() => {
							this.#rn.get(t) === s &&
								this.dispatchEventToListeners(Jt.SourceMapFailedToAttach, {
									client: t,
								});
						}
					);
				} else
					(this.#in &&
						console.error(
							"Cancelling source map attach because another source map is attaching"
						),
						(s = null),
						this.dispatchEventToListeners(Jt.SourceMapFailedToAttach, {
							client: t,
						}));
		}
		s && this.#rn.set(t, s);
	}
	cancelAttachSourceMap(e) {
		e === this.#in
			? (this.#in = null)
			: this.#in
				? console.error(
						"cancel attach source map requested but a different source map was being attached"
					)
				: console.error(
						"cancel attach source map requested but no source map was being attached"
					);
	}
	detachSourceMap(e) {
		const t = this.#rn.get(e);
		if (!t) return;
		if ((this.#rn.delete(e), !this.#nn)) return;
		const { sourceMap: n } = t;
		n
			? (this.#sn.delete(n),
				this.dispatchEventToListeners(Jt.SourceMapDetached, {
					client: e,
					sourceMap: n,
				}))
			: this.dispatchEventToListeners(Jt.SourceMapFailedToAttach, {
					client: e,
				});
	}
	dispose() {
		$e.instance().removeEventListener(
			Xe.InspectedURLChanged,
			this.inspectedURLChanged,
			this
		);
	}
}
!(function (e) {
	((e.SourceMapWillAttach = "SourceMapWillAttach"),
		(e.SourceMapFailedToAttach = "SourceMapFailedToAttach"),
		(e.SourceMapAttached = "SourceMapAttached"),
		(e.SourceMapDetached = "SourceMapDetached"));
})(Jt || (Jt = {}));
var en,
	tn = Object.freeze({
		__proto__: null,
		SourceMapManager: Zt,
		get Events() {
			return Jt;
		},
	});
class nn extends c {
	agent;
	#an;
	#on;
	#ln;
	#dn;
	#cn;
	#hn;
	#un;
	#gn;
	#pn;
	#mn;
	#fn;
	#bn;
	#yn;
	#nn;
	#vn;
	#In;
	constructor(t) {
		(super(t),
			(this.#nn = !1),
			(this.#mn = null),
			(this.#fn = null),
			(this.#an = t.model(mr)),
			(this.#cn = new Zt(t)),
			(this.agent = t.cssAgent()),
			(this.#hn = new ln(this)),
			(this.#dn = t.model(Pr)),
			this.#dn &&
				this.#dn.addEventListener(
					xr.PrimaryPageChanged,
					this.onPrimaryPageChanged,
					this
				),
			t.registerCSSDispatcher(new on(this)),
			t.suspended() || this.enable(),
			(this.#pn = new Map()),
			(this.#gn = new Map()),
			(this.#ln = new Map()),
			(this.#vn = !1),
			(this.#on = new Map()),
			(this.#bn = null),
			(this.#yn = !1),
			(this.#In = !1),
			(this.#un = new e.Throttler.Throttler(hn)),
			this.#cn.setEnabled(
				e.Settings.Settings.instance()
					.moduleSetting("cssSourceMapsEnabled")
					.get()
			),
			e.Settings.Settings.instance()
				.moduleSetting("cssSourceMapsEnabled")
				.addChangeListener((e) => this.#cn.setEnabled(e.data)));
	}
	headersForSourceURL(e) {
		const t = [];
		for (const n of this.getStyleSheetIdsForURL(e)) {
			const e = this.styleSheetHeaderForId(n);
			e && t.push(e);
		}
		return t;
	}
	createRawLocationsByURL(e, n, r = 0) {
		const s = this.headersForSourceURL(e);
		s.sort(function (e, t) {
			return (
				e.startLine - t.startLine ||
				e.startColumn - t.startColumn ||
				e.id.localeCompare(t.id)
			);
		});
		const i = t.ArrayUtilities.upperBound(
			s,
			void 0,
			(e, t) => n - t.startLine || r - t.startColumn
		);
		if (!i) return [];
		const a = [],
			o = s[i - 1];
		for (
			let e = i - 1;
			e >= 0 &&
			s[e].startLine === o.startLine &&
			s[e].startColumn === o.startColumn;
			--e
		)
			s[e].containsLocation(n, r) && a.push(new an(s[e], n, r));
		return a;
	}
	sourceMapManager() {
		return this.#cn;
	}
	static readableLayerName(e) {
		return e || "<anonymous>";
	}
	static trimSourceURL(e) {
		let t = e.lastIndexOf("/*# sourceURL=");
		if (-1 === t && ((t = e.lastIndexOf("/*@ sourceURL=")), -1 === t)) return e;
		const n = e.lastIndexOf("\n", t);
		if (-1 === n) return e;
		const r = e.substr(n + 1).split("\n", 1)[0];
		return -1 ===
			r.search(
				/[\040\t]*\/\*[#@] sourceURL=[\040\t]*([^\s]*)[\040\t]*\*\/[\040\t]*$/
			)
			? e
			: e.substr(0, n) + e.substr(n + r.length + 1);
	}
	domModel() {
		return this.#an;
	}
	async setStyleText(e, t, n, r) {
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { styles: s } = await this.agent.invoke_setStyleTexts({
				edits: [{ styleSheetId: e, range: t.serializeToObject(), text: n }],
			});
			if (!s || 1 !== s.length) return !1;
			this.#an.markUndoableState(!r);
			const i = new sn(e, t, n, s[0]);
			return (this.fireStyleSheetChanged(e, i), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setSelectorText(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { selectorList: r } = await this.agent.invoke_setRuleSelector({
				styleSheetId: e,
				range: t,
				selector: n,
			});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setPropertyRulePropertyName(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { propertyName: r } =
				await this.agent.invoke_setPropertyRulePropertyName({
					styleSheetId: e,
					range: t,
					propertyName: n,
				});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setKeyframeKey(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { keyText: r } = await this.agent.invoke_setKeyframeKey({
				styleSheetId: e,
				range: t,
				keyText: n,
			});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	startCoverage() {
		return ((this.#vn = !0), this.agent.invoke_startRuleUsageTracking());
	}
	async takeCoverageDelta() {
		const e = await this.agent.invoke_takeCoverageDelta();
		return {
			timestamp: (e && e.timestamp) || 0,
			coverage: (e && e.coverage) || [],
		};
	}
	setLocalFontsEnabled(e) {
		return this.agent.invoke_setLocalFontsEnabled({ enabled: e });
	}
	async stopCoverage() {
		((this.#vn = !1), await this.agent.invoke_stopRuleUsageTracking());
	}
	async getMediaQueries() {
		const { medias: e } = await this.agent.invoke_getMediaQueries();
		return e ? te.parseMediaArrayPayload(this, e) : [];
	}
	async getRootLayer(e) {
		const { rootLayer: t } = await this.agent.invoke_getLayersForNode({
			nodeId: e,
		});
		return t;
	}
	isEnabled() {
		return this.#nn;
	}
	async enable() {
		(await this.agent.invoke_enable(),
			(this.#nn = !0),
			this.#vn && (await this.startCoverage()),
			this.dispatchEventToListeners(en.ModelWasEnabled));
	}
	async getMatchedStyles(e) {
		const t = await this.agent.invoke_getMatchedStylesForNode({ nodeId: e });
		if (t.getError()) return null;
		const n = this.#an.nodeForId(e);
		return n
			? await De.create({
					cssModel: this,
					node: n,
					inlinePayload: t.inlineStyle || null,
					attributesPayload: t.attributesStyle || null,
					matchedPayload: t.matchedCSSRules || [],
					pseudoPayload: t.pseudoElements || [],
					inheritedPayload: t.inherited || [],
					inheritedPseudoPayload: t.inheritedPseudoElements || [],
					animationsPayload: t.cssKeyframesRules || [],
					parentLayoutNodeId: t.parentLayoutNodeId,
					positionFallbackRules: t.cssPositionFallbackRules || [],
					propertyRules: t.cssPropertyRules ?? [],
					cssPropertyRegistrations: t.cssPropertyRegistrations ?? [],
					fontPaletteValuesRule: t.cssFontPaletteValuesRule,
				})
			: null;
	}
	async getClassNames(e) {
		const { classNames: t } = await this.agent.invoke_collectClassNames({
			styleSheetId: e,
		});
		return t || [];
	}
	async getComputedStyle(e) {
		return (
			this.isEnabled() || (await this.enable()),
			this.#hn.computedStylePromise(e)
		);
	}
	async getBackgroundColors(e) {
		const t = await this.agent.invoke_getBackgroundColors({ nodeId: e });
		return t.getError()
			? null
			: {
					backgroundColors: t.backgroundColors || null,
					computedFontSize: t.computedFontSize || "",
					computedFontWeight: t.computedFontWeight || "",
				};
	}
	async getPlatformFonts(e) {
		const { fonts: t } = await this.agent.invoke_getPlatformFontsForNode({
			nodeId: e,
		});
		return t;
	}
	allStyleSheets() {
		const e = [...this.#pn.values()];
		return (
			e.sort(function (e, t) {
				return e.sourceURL < t.sourceURL
					? -1
					: e.sourceURL > t.sourceURL
						? 1
						: e.startLine - t.startLine || e.startColumn - t.startColumn;
			}),
			e
		);
	}
	async getInlineStyles(e) {
		const t = await this.agent.invoke_getInlineStylesForNode({ nodeId: e });
		if (t.getError() || !t.inlineStyle) return null;
		const n = new me(this, null, t.inlineStyle, ge.Inline),
			r = t.attributesStyle
				? new me(this, null, t.attributesStyle, ge.Attributes)
				: null;
		return new dn(n, r);
	}
	forcePseudoState(e, n, r) {
		const s = e.marker(rn) || [],
			i = s.includes(n);
		if (r) {
			if (i) return !1;
			(s.push(n), e.setMarker(rn, s));
		} else {
			if (!i) return !1;
			(t.ArrayUtilities.removeElement(s, n),
				s.length ? e.setMarker(rn, s) : e.setMarker(rn, null));
		}
		return (
			void 0 !== e.id &&
			(this.agent.invoke_forcePseudoState({
				nodeId: e.id,
				forcedPseudoClasses: s,
			}),
			this.dispatchEventToListeners(en.PseudoStateForced, {
				node: e,
				pseudoClass: n,
				enable: r,
			}),
			!0)
		);
	}
	pseudoState(e) {
		return e.marker(rn) || [];
	}
	async setMediaText(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { media: r } = await this.agent.invoke_setMediaText({
				styleSheetId: e,
				range: t,
				text: n,
			});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setContainerQueryText(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { containerQuery: r } =
				await this.agent.invoke_setContainerQueryText({
					styleSheetId: e,
					range: t,
					text: n,
				});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setSupportsText(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { supports: r } = await this.agent.invoke_setSupportsText({
				styleSheetId: e,
				range: t,
				text: n,
			});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async setScopeText(e, t, n) {
		o.userMetrics.actionTaken(o.UserMetrics.Action.StyleRuleEdited);
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { scope: r } = await this.agent.invoke_setScopeText({
				styleSheetId: e,
				range: t,
				text: n,
			});
			if (!r) return !1;
			this.#an.markUndoableState();
			const s = new sn(e, t, n, r);
			return (this.fireStyleSheetChanged(e, s), !0);
		} catch (e) {
			return (console.error(e), !1);
		}
	}
	async addRule(e, t, n) {
		try {
			await this.ensureOriginalStyleSheetText(e);
			const { rule: r } = await this.agent.invoke_addRule({
				styleSheetId: e,
				ruleText: t,
				location: n,
			});
			if (!r) return null;
			this.#an.markUndoableState();
			const s = new sn(e, n, t, r);
			return (this.fireStyleSheetChanged(e, s), new ke(this, r));
		} catch (e) {
			return (console.error(e), null);
		}
	}
	async requestViaInspectorStylesheet(e) {
		const t =
				e.frameId() ||
				(this.#dn && this.#dn.mainFrame ? this.#dn.mainFrame.id : null),
			n = [...this.#pn.values()].find(
				(e) => e.frameId === t && e.isViaInspector()
			);
		if (n) return n;
		if (!t) return null;
		try {
			const { styleSheetId: e } = await this.agent.invoke_createStyleSheet({
				frameId: t,
			});
			return (e && this.#pn.get(e)) || null;
		} catch (e) {
			return (console.error(e), null);
		}
	}
	mediaQueryResultChanged() {
		this.dispatchEventToListeners(en.MediaQueryResultChanged);
	}
	fontsUpdated(e) {
		(e && this.#on.set(e.src, new z(e)),
			this.dispatchEventToListeners(en.FontsUpdated));
	}
	fontFaces() {
		return [...this.#on.values()];
	}
	fontFaceForSource(e) {
		return this.#on.get(e);
	}
	styleSheetHeaderForId(e) {
		return this.#pn.get(e) || null;
	}
	styleSheetHeaders() {
		return [...this.#pn.values()];
	}
	fireStyleSheetChanged(e, t) {
		this.dispatchEventToListeners(en.StyleSheetChanged, {
			styleSheetId: e,
			edit: t,
		});
	}
	ensureOriginalStyleSheetText(e) {
		const t = this.styleSheetHeaderForId(e);
		if (!t) return Promise.resolve(null);
		let n = this.#ln.get(t);
		return (
			n ||
				((n = this.getStyleSheetText(t.id)),
				this.#ln.set(t, n),
				this.originalContentRequestedForTest(t)),
			n
		);
	}
	originalContentRequestedForTest(e) {}
	originalStyleSheetText(e) {
		return this.ensureOriginalStyleSheetText(e.id);
	}
	getAllStyleSheetHeaders() {
		return this.#pn.values();
	}
	styleSheetAdded(e) {
		(console.assert(!this.#pn.get(e.styleSheetId)),
			e.loadingFailed &&
				((e.hasSourceURL = !1),
				(e.isConstructed = !0),
				(e.isInline = !1),
				(e.isMutable = !1),
				(e.sourceURL = ""),
				(e.sourceMapURL = void 0)));
		const t = new ze(this, e);
		this.#pn.set(e.styleSheetId, t);
		const n = t.resourceURL();
		let r = this.#gn.get(n);
		if ((r || ((r = new Map()), this.#gn.set(n, r)), r)) {
			let e = r.get(t.frameId);
			(e || ((e = new Set()), r.set(t.frameId, e)), e.add(t.id));
		}
		(this.#cn.attachSourceMap(t, t.sourceURL, t.sourceMapURL),
			this.dispatchEventToListeners(en.StyleSheetAdded, t));
	}
	styleSheetRemoved(e) {
		const t = this.#pn.get(e);
		if ((console.assert(Boolean(t)), !t)) return;
		this.#pn.delete(e);
		const n = t.resourceURL(),
			r = this.#gn.get(n);
		if (
			(console.assert(
				Boolean(r),
				"No frameId to styleSheetId map is available for given style sheet URL."
			),
			r)
		) {
			const s = r.get(t.frameId);
			s &&
				(s.delete(e),
				s.size || (r.delete(t.frameId), r.size || this.#gn.delete(n)));
		}
		(this.#ln.delete(t),
			this.#cn.detachSourceMap(t),
			this.dispatchEventToListeners(en.StyleSheetRemoved, t));
	}
	getStyleSheetIdsForURL(e) {
		const t = this.#gn.get(e);
		if (!t) return [];
		const n = [];
		for (const e of t.values()) n.push(...e);
		return n;
	}
	async setStyleSheetText(e, t, n) {
		const r = this.#pn.get(e);
		if (!r) return "Unknown stylesheet in CSS.setStyleSheetText";
		((t = nn.trimSourceURL(t)),
			r.hasSourceURL && (t += "\n/*# sourceURL=" + r.sourceURL + " */"),
			await this.ensureOriginalStyleSheetText(e));
		const s = (
			await this.agent.invoke_setStyleSheetText({ styleSheetId: r.id, text: t })
		).sourceMapURL;
		return (
			this.#cn.detachSourceMap(r),
			r.setSourceMapURL(s),
			this.#cn.attachSourceMap(r, r.sourceURL, r.sourceMapURL),
			null === s
				? "Error in CSS.setStyleSheetText"
				: (this.#an.markUndoableState(!n), this.fireStyleSheetChanged(e), null)
		);
	}
	async getStyleSheetText(e) {
		try {
			const { text: t } = await this.agent.invoke_getStyleSheetText({
				styleSheetId: e,
			});
			return t && nn.trimSourceURL(t);
		} catch (e) {
			return null;
		}
	}
	async onPrimaryPageChanged(e) {
		e.data.frame.backForwardCacheDetails.restoredFromCache
			? (await this.suspendModel(), await this.resumeModel())
			: "Activation" !== e.data.type &&
				(this.resetStyleSheets(), this.resetFontFaces());
	}
	resetStyleSheets() {
		const e = [...this.#pn.values()];
		(this.#gn.clear(), this.#pn.clear());
		for (const t of e)
			(this.#cn.detachSourceMap(t),
				this.dispatchEventToListeners(en.StyleSheetRemoved, t));
	}
	resetFontFaces() {
		this.#on.clear();
	}
	async suspendModel() {
		((this.#nn = !1),
			await this.agent.invoke_disable(),
			this.resetStyleSheets(),
			this.resetFontFaces());
	}
	async resumeModel() {
		return this.enable();
	}
	setEffectivePropertyValueForNode(e, t, n) {
		this.agent.invoke_setEffectivePropertyValueForNode({
			nodeId: e,
			propertyName: t,
			value: n,
		});
	}
	cachedMatchedCascadeForNode(e) {
		if (
			(this.#mn !== e && this.discardCachedMatchedCascade(),
			(this.#mn = e),
			!this.#fn)
		) {
			if (!e.id) return Promise.resolve(null);
			this.#fn = this.getMatchedStyles(e.id);
		}
		return this.#fn;
	}
	discardCachedMatchedCascade() {
		((this.#mn = null), (this.#fn = null));
	}
	createCSSPropertyTracker(e) {
		return new cn(this, e);
	}
	enableCSSPropertyTracker(e) {
		const t = e.getTrackedProperties();
		0 !== t.length &&
			(this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack: t }),
			(this.#yn = !0),
			(this.#bn = e),
			this.pollComputedStyleUpdates());
	}
	disableCSSPropertyTracker() {
		((this.#yn = !1),
			(this.#bn = null),
			this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack: [] }));
	}
	async pollComputedStyleUpdates() {
		if (!this.#In) {
			if (this.#yn) {
				this.#In = !0;
				const e = await this.agent.invoke_takeComputedStyleUpdates();
				if (((this.#In = !1), e.getError() || !e.nodeIds || !this.#yn)) return;
				this.#bn &&
					this.#bn.dispatchEventToListeners(
						un.TrackedCSSPropertiesUpdated,
						e.nodeIds.map((e) => this.#an.nodeForId(e))
					);
			}
			this.#yn && this.#un.schedule(this.pollComputedStyleUpdates.bind(this));
		}
	}
	dispose() {
		(this.disableCSSPropertyTracker(), super.dispose(), this.#cn.dispose());
	}
	getAgent() {
		return this.agent;
	}
}
!(function (e) {
	((e.FontsUpdated = "FontsUpdated"),
		(e.MediaQueryResultChanged = "MediaQueryResultChanged"),
		(e.ModelWasEnabled = "ModelWasEnabled"),
		(e.PseudoStateForced = "PseudoStateForced"),
		(e.StyleSheetAdded = "StyleSheetAdded"),
		(e.StyleSheetChanged = "StyleSheetChanged"),
		(e.StyleSheetRemoved = "StyleSheetRemoved"));
})(en || (en = {}));
const rn = "pseudo-state-marker";
class sn {
	styleSheetId;
	oldRange;
	newRange;
	newText;
	payload;
	constructor(e, t, n, r) {
		((this.styleSheetId = e),
			(this.oldRange = t),
			(this.newRange = s.TextRange.TextRange.fromEdit(t, n)),
			(this.newText = n),
			(this.payload = r));
	}
}
class an {
	#F;
	styleSheetId;
	url;
	lineNumber;
	columnNumber;
	constructor(e, t, n) {
		((this.#F = e.cssModel()),
			(this.styleSheetId = e.id),
			(this.url = e.resourceURL()),
			(this.lineNumber = t),
			(this.columnNumber = n || 0));
	}
	cssModel() {
		return this.#F;
	}
	header() {
		return this.#F.styleSheetHeaderForId(this.styleSheetId);
	}
}
class on {
	#ee;
	constructor(e) {
		this.#ee = e;
	}
	mediaQueryResultChanged() {
		this.#ee.mediaQueryResultChanged();
	}
	fontsUpdated({ font: e }) {
		this.#ee.fontsUpdated(e);
	}
	styleSheetChanged({ styleSheetId: e }) {
		this.#ee.fireStyleSheetChanged(e);
	}
	styleSheetAdded({ header: e }) {
		this.#ee.styleSheetAdded(e);
	}
	styleSheetRemoved({ styleSheetId: e }) {
		this.#ee.styleSheetRemoved(e);
	}
}
class ln {
	#ee;
	#kn;
	constructor(e) {
		((this.#ee = e), (this.#kn = new Map()));
	}
	computedStylePromise(e) {
		let t = this.#kn.get(e);
		return (
			t ||
			((t = this.#ee
				.getAgent()
				.invoke_getComputedStyleForNode({ nodeId: e })
				.then(({ computedStyle: t }) => {
					if ((this.#kn.delete(e), !t || !t.length)) return null;
					const n = new Map();
					for (const e of t) n.set(e.name, e.value);
					return n;
				})),
			this.#kn.set(e, t),
			t)
		);
	}
}
class dn {
	inlineStyle;
	attributesStyle;
	constructor(e, t) {
		((this.inlineStyle = e), (this.attributesStyle = t));
	}
}
class cn extends e.ObjectWrapper.ObjectWrapper {
	#ee;
	#Sn;
	constructor(e, t) {
		(super(), (this.#ee = e), (this.#Sn = t));
	}
	start() {
		this.#ee.enableCSSPropertyTracker(this);
	}
	stop() {
		this.#ee.disableCSSPropertyTracker();
	}
	getTrackedProperties() {
		return this.#Sn;
	}
}
const hn = 1e3;
var un;
(!(function (e) {
	e.TrackedCSSPropertiesUpdated = "TrackedCSSPropertiesUpdated";
})(un || (un = {})),
	c.register(nn, { capabilities: We.DOM, autostart: !0 }));
var gn,
	pn = Object.freeze({
		__proto__: null,
		CSSModel: nn,
		get Events() {
			return en;
		},
		Edit: sn,
		CSSLocation: an,
		InlineStyleResult: dn,
		CSSPropertyTracker: cn,
		get CSSPropertyTrackerEvents() {
			return un;
		},
	});
class mn extends c {
	#wn;
	#Cn;
	#Rn;
	#Tn;
	constructor(e) {
		(super(e),
			e.registerHeapProfilerDispatcher(new fn(this)),
			(this.#wn = !1),
			(this.#Cn = e.heapProfilerAgent()),
			(this.#Rn = e.model(yn)),
			(this.#Tn = 0));
	}
	debuggerModel() {
		return this.#Rn.debuggerModel();
	}
	runtimeModel() {
		return this.#Rn;
	}
	async enable() {
		this.#wn || ((this.#wn = !0), await this.#Cn.invoke_enable());
	}
	async startSampling(e) {
		if (this.#Tn++) return !1;
		const t = await this.#Cn.invoke_startSampling({
			samplingInterval: e || 16384,
		});
		return Boolean(t.getError());
	}
	async stopSampling() {
		if (!this.#Tn) throw new Error("Sampling profiler is not running.");
		if (--this.#Tn) return this.getSamplingProfile();
		const e = await this.#Cn.invoke_stopSampling();
		return e.getError() ? null : e.profile;
	}
	async getSamplingProfile() {
		const e = await this.#Cn.invoke_getSamplingProfile();
		return e.getError() ? null : e.profile;
	}
	async collectGarbage() {
		const e = await this.#Cn.invoke_collectGarbage();
		return Boolean(e.getError());
	}
	async snapshotObjectIdForObjectId(e) {
		const t = await this.#Cn.invoke_getHeapObjectId({ objectId: e });
		return t.getError() ? null : t.heapSnapshotObjectId;
	}
	async objectForSnapshotObjectId(e, t) {
		const n = await this.#Cn.invoke_getObjectByHeapObjectId({
			objectId: e,
			objectGroup: t,
		});
		return n.getError() ? null : this.#Rn.createRemoteObject(n.result);
	}
	async addInspectedHeapObject(e) {
		const t = await this.#Cn.invoke_addInspectedHeapObject({ heapObjectId: e });
		return Boolean(t.getError());
	}
	async takeHeapSnapshot(e) {
		await this.#Cn.invoke_takeHeapSnapshot(e);
	}
	async startTrackingHeapObjects(e) {
		const t = await this.#Cn.invoke_startTrackingHeapObjects({
			trackAllocations: e,
		});
		return Boolean(t.getError());
	}
	async stopTrackingHeapObjects(e) {
		const t = await this.#Cn.invoke_stopTrackingHeapObjects({
			reportProgress: e,
		});
		return Boolean(t.getError());
	}
	heapStatsUpdate(e) {
		this.dispatchEventToListeners(gn.HeapStatsUpdate, e);
	}
	lastSeenObjectId(e, t) {
		this.dispatchEventToListeners(gn.LastSeenObjectId, {
			lastSeenObjectId: e,
			timestamp: t,
		});
	}
	addHeapSnapshotChunk(e) {
		this.dispatchEventToListeners(gn.AddHeapSnapshotChunk, e);
	}
	reportHeapSnapshotProgress(e, t, n) {
		this.dispatchEventToListeners(gn.ReportHeapSnapshotProgress, {
			done: e,
			total: t,
			finished: n,
		});
	}
	resetProfiles() {
		this.dispatchEventToListeners(gn.ResetProfiles, this);
	}
}
!(function (e) {
	((e.HeapStatsUpdate = "HeapStatsUpdate"),
		(e.LastSeenObjectId = "LastSeenObjectId"),
		(e.AddHeapSnapshotChunk = "AddHeapSnapshotChunk"),
		(e.ReportHeapSnapshotProgress = "ReportHeapSnapshotProgress"),
		(e.ResetProfiles = "ResetProfiles"));
})(gn || (gn = {}));
class fn {
	#xn;
	constructor(e) {
		this.#xn = e;
	}
	heapStatsUpdate({ statsUpdate: e }) {
		this.#xn.heapStatsUpdate(e);
	}
	lastSeenObjectId({ lastSeenObjectId: e, timestamp: t }) {
		this.#xn.lastSeenObjectId(e, t);
	}
	addHeapSnapshotChunk({ chunk: e }) {
		this.#xn.addHeapSnapshotChunk(e);
	}
	reportHeapSnapshotProgress({ done: e, total: t, finished: n }) {
		this.#xn.reportHeapSnapshotProgress(e, t, n);
	}
	resetProfiles() {
		this.#xn.resetProfiles();
	}
}
c.register(mn, { capabilities: We.JS, autostart: !1 });
var bn = Object.freeze({
	__proto__: null,
	HeapProfilerModel: mn,
	get Events() {
		return gn;
	},
});
class yn extends c {
	agent;
	#Mn;
	#Pn;
	#Ln;
	constructor(t) {
		(super(t),
			(this.agent = t.runtimeAgent()),
			this.target().registerRuntimeDispatcher(new kn(this)),
			this.agent.invoke_enable(),
			(this.#Mn = new Map()),
			(this.#Pn = Sn.comparator),
			(this.#Ln = null),
			e.Settings.Settings.instance().moduleSetting("customFormatters").get() &&
				this.agent.invoke_setCustomObjectFormatterEnabled({ enabled: !0 }),
			e.Settings.Settings.instance()
				.moduleSetting("customFormatters")
				.addChangeListener(this.customFormattersStateChanged.bind(this)));
	}
	static isSideEffectFailure(e) {
		const t = "exceptionDetails" in e && e.exceptionDetails;
		return Boolean(
			t &&
				t.exception &&
				t.exception.description &&
				t.exception.description.startsWith(
					"EvalError: Possible side-effect in debug-evaluate"
				)
		);
	}
	debuggerModel() {
		return this.target().model(Bn);
	}
	heapProfilerModel() {
		return this.target().model(mn);
	}
	executionContexts() {
		return [...this.#Mn.values()].sort(this.executionContextComparator());
	}
	setExecutionContextComparator(e) {
		this.#Pn = e;
	}
	executionContextComparator() {
		return this.#Pn;
	}
	defaultExecutionContext() {
		for (const e of this.executionContexts()) if (e.isDefault) return e;
		return null;
	}
	executionContext(e) {
		return this.#Mn.get(e) || null;
	}
	executionContextCreated(e) {
		const t = e.auxData || { isDefault: !0 },
			n = new Sn(
				this,
				e.id,
				e.uniqueId,
				e.name,
				e.origin,
				t.isDefault,
				t.frameId
			);
		(this.#Mn.set(n.id, n),
			this.dispatchEventToListeners(In.ExecutionContextCreated, n));
	}
	executionContextDestroyed(e) {
		const t = this.#Mn.get(e);
		t &&
			(this.debuggerModel().executionContextDestroyed(t),
			this.#Mn.delete(e),
			this.dispatchEventToListeners(In.ExecutionContextDestroyed, t));
	}
	fireExecutionContextOrderChanged() {
		this.dispatchEventToListeners(In.ExecutionContextOrderChanged, this);
	}
	executionContextsCleared() {
		this.debuggerModel().globalObjectCleared();
		const e = this.executionContexts();
		this.#Mn.clear();
		for (let t = 0; t < e.length; ++t)
			this.dispatchEventToListeners(In.ExecutionContextDestroyed, e[t]);
	}
	createRemoteObject(e) {
		return (
			console.assert(
				"object" == typeof e,
				"Remote object payload should only be an object"
			),
			new rt(
				this,
				e.objectId,
				e.type,
				e.subtype,
				e.value,
				e.unserializableValue,
				e.description,
				e.preview,
				e.customPreview,
				e.className
			)
		);
	}
	createScopeRemoteObject(e, t) {
		return new st(
			this,
			e.objectId,
			t,
			e.type,
			e.subtype,
			e.value,
			e.unserializableValue,
			e.description,
			e.preview
		);
	}
	createRemoteObjectFromPrimitiveValue(e) {
		const t = typeof e;
		let n;
		const r = nt.unserializableDescription(e);
		return (
			null !== r && (n = r),
			void 0 !== n && (e = void 0),
			new rt(this, void 0, t, void 0, e, n)
		);
	}
	createRemotePropertyFromPrimitiveValue(e, t) {
		return new at(e, this.createRemoteObjectFromPrimitiveValue(t));
	}
	discardConsoleEntries() {
		this.agent.invoke_discardConsoleEntries();
	}
	releaseObjectGroup(e) {
		this.agent.invoke_releaseObjectGroup({ objectGroup: e });
	}
	releaseEvaluationResult(e) {
		if (
			("object" in e && e.object && e.object.release(),
			"exceptionDetails" in e &&
				e.exceptionDetails &&
				e.exceptionDetails.exception)
		) {
			const t = e.exceptionDetails.exception;
			this.createRemoteObject({ type: t.type, objectId: t.objectId }).release();
		}
	}
	runIfWaitingForDebugger() {
		this.agent.invoke_runIfWaitingForDebugger();
	}
	customFormattersStateChanged({ data: e }) {
		this.agent.invoke_setCustomObjectFormatterEnabled({ enabled: e });
	}
	async compileScript(e, t, n, r) {
		const s = await this.agent.invoke_compileScript({
			expression: e,
			sourceURL: t,
			persistScript: n,
			executionContextId: r,
		});
		return s.getError()
			? (console.error(s.getError()), null)
			: { scriptId: s.scriptId, exceptionDetails: s.exceptionDetails };
	}
	async runScript(e, t, n, r, s, i, a, o) {
		const l = await this.agent.invoke_runScript({
				scriptId: e,
				executionContextId: t,
				objectGroup: n,
				silent: r,
				includeCommandLineAPI: s,
				returnByValue: i,
				generatePreview: a,
				awaitPromise: o,
			}),
			d = l.getError();
		return d
			? (console.error(d), { error: d })
			: {
					object: this.createRemoteObject(l.result),
					exceptionDetails: l.exceptionDetails,
				};
	}
	async queryObjects(e) {
		if (!e.objectId) return { error: "Prototype should be an Object." };
		const t = await this.agent.invoke_queryObjects({
				prototypeObjectId: e.objectId,
				objectGroup: "console",
			}),
			n = t.getError();
		return n
			? (console.error(n), { error: n })
			: { objects: this.createRemoteObject(t.objects) };
	}
	async isolateId() {
		const e = await this.agent.invoke_getIsolateId();
		return e.getError() || !e.id ? this.target().id() : e.id;
	}
	async heapUsage() {
		const e = await this.agent.invoke_getHeapUsage();
		return e.getError() ? null : e;
	}
	inspectRequested(t, n, r) {
		const s = this.createRemoteObject(t);
		n && "copyToClipboard" in n && Boolean(n.copyToClipboard)
			? this.copyRequested(s)
			: n && "queryObjects" in n && n.queryObjects
				? this.queryObjectsRequested(s, r)
				: s.isNode()
					? e.Revealer.reveal(s).then(s.release.bind(s))
					: "function" !== s.type
						? s.release()
						: dt
								.objectAsFunction(s)
								.targetFunctionDetails()
								.then(function (t) {
									if ((s.release(), !t || !t.location)) return;
									e.Revealer.reveal(t.location);
								});
	}
	async addBinding(e) {
		return await this.agent.invoke_addBinding(e);
	}
	bindingCalled(e) {
		this.dispatchEventToListeners(In.BindingCalled, e);
	}
	copyRequested(t) {
		if (!t.objectId)
			return void o.InspectorFrontendHost.InspectorFrontendHostInstance.copyText(
				t.unserializableValue() || t.value
			);
		const n = e.Settings.Settings.instance()
			.moduleSetting("textEditorIndent")
			.get();
		t.callFunctionJSON(
			function (e) {
				const t = e.subtype,
					n = e.indent;
				if ("node" === t)
					return this instanceof Element ? this.outerHTML : void 0;
				if (t && void 0 === this) return String(t);
				try {
					return JSON.stringify(this, null, n);
				} catch (e) {
					return String(this);
				}
			},
			[{ value: { subtype: t.subtype, indent: n } }]
		).then(
			o.InspectorFrontendHost.InspectorFrontendHostInstance.copyText.bind(
				o.InspectorFrontendHost.InspectorFrontendHostInstance
			)
		);
	}
	async queryObjectsRequested(t, n) {
		const r = await this.queryObjects(t);
		(t.release(),
			"error" in r
				? e.Console.Console.instance().error(r.error)
				: this.dispatchEventToListeners(In.QueryObjectRequested, {
						objects: r.objects,
						executionContextId: n,
					}));
	}
	static simpleTextFromException(e) {
		let t = e.text;
		if (e.exception && e.exception.description) {
			let n = e.exception.description;
			(-1 !== n.indexOf("\n") && (n = n.substring(0, n.indexOf("\n"))),
				(t += " " + n));
		}
		return t;
	}
	exceptionThrown(e, t) {
		const n = { timestamp: e, details: t };
		this.dispatchEventToListeners(In.ExceptionThrown, n);
	}
	exceptionRevoked(e) {
		this.dispatchEventToListeners(In.ExceptionRevoked, e);
	}
	consoleAPICalled(e, t, n, r, s, i) {
		const a = {
			type: e,
			args: t,
			executionContextId: n,
			timestamp: r,
			stackTrace: s,
			context: i,
		};
		this.dispatchEventToListeners(In.ConsoleAPICalled, a);
	}
	executionContextIdForScriptId(e) {
		const t = this.debuggerModel().scriptForId(e);
		return t ? t.executionContextId : 0;
	}
	executionContextForStackTrace(e) {
		let t = e;
		for (; t && !t.callFrames.length; ) t = t.parent || null;
		return t && t.callFrames.length
			? this.executionContextIdForScriptId(t.callFrames[0].scriptId)
			: 0;
	}
	hasSideEffectSupport() {
		return this.#Ln;
	}
	async checkSideEffectSupport() {
		const e = this.executionContexts(),
			t = e[e.length - 1];
		if (!t) return !1;
		const n = await this.agent.invoke_evaluate({
			expression: vn,
			contextId: t.id,
			throwOnSideEffect: !0,
		});
		return ((this.#Ln = !n.getError() && yn.isSideEffectFailure(n)), this.#Ln);
	}
	terminateExecution() {
		return this.agent.invoke_terminateExecution();
	}
	async getExceptionDetails(e) {
		const t = await this.agent.invoke_getExceptionDetails({ errorObjectId: e });
		if (!t.getError()) return t.exceptionDetails;
	}
}
const vn = "(async function(){ await 1; })()";
var In;
!(function (e) {
	((e.BindingCalled = "BindingCalled"),
		(e.ExecutionContextCreated = "ExecutionContextCreated"),
		(e.ExecutionContextDestroyed = "ExecutionContextDestroyed"),
		(e.ExecutionContextChanged = "ExecutionContextChanged"),
		(e.ExecutionContextOrderChanged = "ExecutionContextOrderChanged"),
		(e.ExceptionThrown = "ExceptionThrown"),
		(e.ExceptionRevoked = "ExceptionRevoked"),
		(e.ConsoleAPICalled = "ConsoleAPICalled"),
		(e.QueryObjectRequested = "QueryObjectRequested"));
})(In || (In = {}));
class kn {
	#En;
	constructor(e) {
		this.#En = e;
	}
	executionContextCreated({ context: e }) {
		this.#En.executionContextCreated(e);
	}
	executionContextDestroyed({ executionContextId: e }) {
		this.#En.executionContextDestroyed(e);
	}
	executionContextsCleared() {
		this.#En.executionContextsCleared();
	}
	exceptionThrown({ timestamp: e, exceptionDetails: t }) {
		this.#En.exceptionThrown(e, t);
	}
	exceptionRevoked({ exceptionId: e }) {
		this.#En.exceptionRevoked(e);
	}
	consoleAPICalled({
		type: e,
		args: t,
		executionContextId: n,
		timestamp: r,
		stackTrace: s,
		context: i,
	}) {
		this.#En.consoleAPICalled(e, t, n, r, s, i);
	}
	inspectRequested({ object: e, hints: t, executionContextId: n }) {
		this.#En.inspectRequested(e, t, n);
	}
	bindingCalled(e) {
		this.#En.bindingCalled(e);
	}
}
class Sn {
	id;
	uniqueId;
	name;
	#On;
	origin;
	isDefault;
	runtimeModel;
	debuggerModel;
	frameId;
	constructor(e, t, n, r, s, i, a) {
		((this.id = t),
			(this.uniqueId = n),
			(this.name = r),
			(this.#On = null),
			(this.origin = s),
			(this.isDefault = i),
			(this.runtimeModel = e),
			(this.debuggerModel = e.debuggerModel()),
			(this.frameId = a),
			this.setLabelInternal(""));
	}
	target() {
		return this.runtimeModel.target();
	}
	static comparator(e, t) {
		function n(e) {
			return e.parentTarget()?.type() !== je.Frame
				? 5
				: e.type() === je.Frame
					? 4
					: e.type() === je.ServiceWorker
						? 3
						: e.type() === je.Worker || e.type() === je.SharedWorker
							? 2
							: 1;
		}
		function r(e) {
			let t = e;
			const n = [];
			for (; t; ) (n.push(t), (t = t.parentTarget()));
			return n.reverse();
		}
		const s = r(e.target()),
			i = r(t.target());
		let a, o;
		for (let e = 0; ; e++)
			if (!s[e] || !i[e] || s[e] !== i[e]) {
				((a = s[e]), (o = i[e]));
				break;
			}
		if (!a && o) return -1;
		if (!o && a) return 1;
		if (a && o) {
			const e = n(a) - n(o);
			return e ? -e : a.id().localeCompare(o.id());
		}
		return e.isDefault ? -1 : t.isDefault ? 1 : e.name.localeCompare(t.name);
	}
	async evaluate(e, t, n) {
		if (this.debuggerModel.selectedCallFrame())
			return this.debuggerModel.evaluateOnSelectedCallFrame(e);
		return !(Boolean(e.throwOnSideEffect) || void 0 !== e.timeout) ||
			this.runtimeModel.hasSideEffectSupport() ||
			(!1 !== this.runtimeModel.hasSideEffectSupport() &&
				(await this.runtimeModel.checkSideEffectSupport(),
				this.runtimeModel.hasSideEffectSupport()))
			? this.evaluateGlobal(e, t, n)
			: { error: "Side-effect checks not supported by backend." };
	}
	globalObject(e, t) {
		const n = {
			expression: "this",
			objectGroup: e,
			includeCommandLineAPI: !1,
			silent: !0,
			returnByValue: !1,
			generatePreview: t,
		};
		return this.evaluateGlobal(n, !1, !1);
	}
	async evaluateGlobal(e, t, n) {
		e.expression || (e.expression = "this");
		const r = await this.runtimeModel.agent.invoke_evaluate({
				expression: e.expression,
				objectGroup: e.objectGroup,
				includeCommandLineAPI: e.includeCommandLineAPI,
				silent: e.silent,
				returnByValue: e.returnByValue,
				generatePreview: e.generatePreview,
				userGesture: t,
				awaitPromise: n,
				throwOnSideEffect: e.throwOnSideEffect,
				timeout: e.timeout,
				disableBreaks: e.disableBreaks,
				replMode: e.replMode,
				allowUnsafeEvalBlockedByCSP: e.allowUnsafeEvalBlockedByCSP,
				...(this.uniqueId
					? { uniqueContextId: this.uniqueId }
					: { contextId: this.id }),
			}),
			s = r.getError();
		return s
			? (console.error(s), { error: s })
			: {
					object: this.runtimeModel.createRemoteObject(r.result),
					exceptionDetails: r.exceptionDetails,
				};
	}
	async globalLexicalScopeNames() {
		const e = await this.runtimeModel.agent.invoke_globalLexicalScopeNames({
			executionContextId: this.id,
		});
		return e.getError() ? [] : e.names;
	}
	label() {
		return this.#On;
	}
	setLabel(e) {
		(this.setLabelInternal(e),
			this.runtimeModel.dispatchEventToListeners(
				In.ExecutionContextChanged,
				this
			));
	}
	setLabelInternal(t) {
		if (t) return void (this.#On = t);
		if (this.name) return void (this.#On = this.name);
		const n = e.ParsedURL.ParsedURL.fromString(this.origin);
		this.#On = n ? n.lastPathComponentWithFragment() : "";
	}
}
c.register(yn, { capabilities: We.JS, autostart: !0 });
var wn = Object.freeze({
	__proto__: null,
	RuntimeModel: yn,
	get Events() {
		return In;
	},
	ExecutionContext: Sn,
});
const Cn = {
		scriptRemovedOrDeleted: "Script removed or deleted.",
		unableToFetchScriptSource: "Unable to fetch script source.",
	},
	Rn = i.i18n.registerUIStrings("core/sdk/Script.ts", Cn),
	Tn = i.i18n.getLocalizedString.bind(void 0, Rn);
let xn = null;
class Mn {
	debuggerModel;
	scriptId;
	sourceURL;
	lineOffset;
	columnOffset;
	endLine;
	endColumn;
	executionContextId;
	hash;
	#An;
	#Nn;
	sourceMapURL;
	debugSymbols;
	hasSourceURL;
	contentLength;
	originStackTrace;
	#Dn;
	#Fn;
	#Bn;
	#Un;
	isModule;
	constructor(e, t, n, r, s, i, a, o, l, d, c, h, u, g, p, m, f, b, y, v) {
		((this.debuggerModel = e),
			(this.scriptId = t),
			(this.sourceURL = n),
			(this.lineOffset = r),
			(this.columnOffset = s),
			(this.endLine = i),
			(this.endColumn = a),
			(this.isModule = p),
			(this.executionContextId = o),
			(this.hash = l),
			(this.#An = d),
			(this.#Nn = c),
			(this.sourceMapURL = h),
			(this.debugSymbols = y),
			(this.hasSourceURL = u),
			(this.contentLength = g),
			(this.originStackTrace = m),
			(this.#Dn = f),
			(this.#Fn = b),
			(this.#Bn = null),
			(this.#Un = v));
	}
	embedderName() {
		return this.#Un;
	}
	target() {
		return this.debuggerModel.target();
	}
	static trimSourceURLComment(e) {
		let t = e.lastIndexOf("//# sourceURL=");
		if (-1 === t && ((t = e.lastIndexOf("//@ sourceURL=")), -1 === t)) return e;
		const n = e.lastIndexOf("\n", t);
		if (-1 === n) return e;
		return e.substr(n + 1).match(Ln) ? e.substr(0, n) : e;
	}
	isContentScript() {
		return this.#An;
	}
	codeOffset() {
		return this.#Dn;
	}
	isJavaScript() {
		return "JavaScript" === this.#Fn;
	}
	isWasm() {
		return "WebAssembly" === this.#Fn;
	}
	scriptLanguage() {
		return this.#Fn;
	}
	executionContext() {
		return this.debuggerModel
			.runtimeModel()
			.executionContext(this.executionContextId);
	}
	isLiveEdit() {
		return this.#Nn;
	}
	contentURL() {
		return this.sourceURL;
	}
	contentType() {
		return e.ResourceType.resourceTypes.Script;
	}
	async loadTextContent() {
		const t = await this.debuggerModel
			.target()
			.debuggerAgent()
			.invoke_getScriptSource({ scriptId: this.scriptId });
		if (t.getError()) throw new Error(t.getError());
		const { scriptSource: n, bytecode: r } = t;
		if (r) return { content: r, isEncoded: !0 };
		let s = n || "";
		return (
			this.hasSourceURL &&
				e.ParsedURL.schemeIs(this.sourceURL, "snippet:") &&
				(s = Mn.trimSourceURLComment(s)),
			{ content: s, isEncoded: !1 }
		);
	}
	async loadWasmContent() {
		if (!this.isWasm()) throw new Error("Not a wasm script");
		const t = await this.debuggerModel
			.target()
			.debuggerAgent()
			.invoke_disassembleWasmModule({ scriptId: this.scriptId });
		if (t.getError()) return this.loadTextContent();
		const {
				streamId: n,
				functionBodyOffsets: r,
				chunk: { lines: s, bytecodeOffsets: i },
			} = t,
			a = [],
			o = [];
		let l = s.reduce((e, t) => e + t.length + 1, 0);
		const d = "<truncated>";
		if (n)
			for (;;) {
				const e = await this.debuggerModel
					.target()
					.debuggerAgent()
					.invoke_nextWasmDisassemblyChunk({ streamId: n });
				if (e.getError()) throw new Error(e.getError());
				const {
					chunk: { lines: t, bytecodeOffsets: r },
				} = e;
				if (((l += t.reduce((e, t) => e + t.length + 1, 0)), 0 === t.length))
					break;
				if (l >= 999999989) {
					(a.push([d]), o.push([0]));
					break;
				}
				(a.push(t), o.push(r));
			}
		const c = [];
		for (let e = 0; e < r.length; e += 2)
			c.push({ start: r[e], end: r[e + 1] });
		return {
			content: "",
			isEncoded: !1,
			wasmDisassemblyInfo: new e.WasmDisassembly.WasmDisassembly(
				s.concat(...a),
				i.concat(...o),
				c
			),
		};
	}
	requestContent() {
		if (!this.#Bn) {
			const e = 65535;
			if (this.hash && !this.#Nn && this.contentLength > e) {
				xn ||
					(xn = {
						cache: new Map(),
						registry: new FinalizationRegistry((e) => xn?.cache.delete(e)),
					});
				const e = [
						this.#Fn,
						this.contentLength,
						this.lineOffset,
						this.columnOffset,
						this.endLine,
						this.endColumn,
						this.#Dn,
						this.hash,
					].join(":"),
					t = xn.cache.get(e)?.deref();
				t
					? (this.#Bn = t)
					: ((this.#Bn = this.requestContentInternal()),
						xn.cache.set(e, new WeakRef(this.#Bn)),
						xn.registry.register(this.#Bn, e));
			} else this.#Bn = this.requestContentInternal();
		}
		return this.#Bn;
	}
	async requestContentInternal() {
		if (!this.scriptId)
			return {
				content: null,
				error: Tn(Cn.scriptRemovedOrDeleted),
				isEncoded: !1,
			};
		try {
			return this.isWasm()
				? await this.loadWasmContent()
				: await this.loadTextContent();
		} catch (e) {
			return {
				content: null,
				error: Tn(Cn.unableToFetchScriptSource),
				isEncoded: !1,
			};
		}
	}
	async getWasmBytecode() {
		const e = await this.debuggerModel
			.target()
			.debuggerAgent()
			.invoke_getWasmBytecode({ scriptId: this.scriptId });
		return (
			await fetch(`data:application/wasm;base64,${e.bytecode}`)
		).arrayBuffer();
	}
	originalContentProvider() {
		return new s.StaticContentProvider.StaticContentProvider(
			this.contentURL(),
			this.contentType(),
			() => this.requestContent()
		);
	}
	async searchInContent(e, t, n) {
		if (!this.scriptId) return [];
		const r = await this.debuggerModel
			.target()
			.debuggerAgent()
			.invoke_searchInContent({
				scriptId: this.scriptId,
				query: e,
				caseSensitive: t,
				isRegex: n,
			});
		return s.TextUtils.performSearchInSearchMatches(r.result || [], e, t, n);
	}
	appendSourceURLCommentIfNeeded(e) {
		return this.hasSourceURL ? e + "\n //# sourceURL=" + this.sourceURL : e;
	}
	async editSource(e) {
		((e = Mn.trimSourceURLComment(e)),
			(e = this.appendSourceURLCommentIfNeeded(e)));
		const { content: t } = await this.requestContent();
		if (t === e) return { changed: !1, status: "Ok" };
		const n = await this.debuggerModel
			.target()
			.debuggerAgent()
			.invoke_setScriptSource({
				scriptId: this.scriptId,
				scriptSource: e,
				allowTopFrameEditing: !0,
			});
		if (n.getError())
			throw new Error(
				`Script#editSource failed for script with id ${this.scriptId}: ${n.getError()}`
			);
		return (
			n.getError() ||
				"Ok" !== n.status ||
				(this.#Bn = Promise.resolve({ content: e, isEncoded: !1 })),
			this.debuggerModel.dispatchEventToListeners(qn.ScriptSourceWasEdited, {
				script: this,
				status: n.status,
			}),
			{ changed: !0, status: n.status, exceptionDetails: n.exceptionDetails }
		);
	}
	rawLocation(e, t) {
		return this.containsLocation(e, t)
			? new zn(this.debuggerModel, this.scriptId, e, t)
			: null;
	}
	isInlineScript() {
		const e = !this.lineOffset && !this.columnOffset;
		return !this.isWasm() && Boolean(this.sourceURL) && !e;
	}
	isAnonymousScript() {
		return !this.sourceURL;
	}
	async setBlackboxedRanges(e) {
		return !(
			await this.debuggerModel
				.target()
				.debuggerAgent()
				.invoke_setBlackboxedRanges({ scriptId: this.scriptId, positions: e })
		).getError();
	}
	containsLocation(e, t) {
		const n =
				(e === this.lineOffset && t >= this.columnOffset) ||
				e > this.lineOffset,
			r = e < this.endLine || (e === this.endLine && t <= this.endColumn);
		return n && r;
	}
	get frameId() {
		return (
			"string" != typeof this[Pn] &&
				(this[Pn] = (function (e) {
					const t = e.executionContext();
					if (t) return t.frameId || null;
					const n = e.debuggerModel.target().model(Pr);
					if (!n || !n.mainFrame) return null;
					return n.mainFrame.id;
				})(this)),
			this[Pn]
		);
	}
	get isBreakpointCondition() {
		return [Qn, Kn].includes(this.sourceURL);
	}
	createPageResourceLoadInitiator() {
		return {
			target: this.target(),
			frameId: this.frameId,
			initiatorUrl: this.embedderName(),
		};
	}
	rawLocationToRelativeLocation(e) {
		let { lineNumber: t, columnNumber: n } = e;
		return (
			!this.hasSourceURL &&
				this.isInlineScript() &&
				((t -= this.lineOffset),
				0 === t && void 0 !== n && (n -= this.columnOffset)),
			{ lineNumber: t, columnNumber: n }
		);
	}
	relativeLocationToRawLocation(e) {
		let { lineNumber: t, columnNumber: n } = e;
		return (
			!this.hasSourceURL &&
				this.isInlineScript() &&
				(0 === t && void 0 !== n && (n += this.columnOffset),
				(t += this.lineOffset)),
			{ lineNumber: t, columnNumber: n }
		);
	}
}
const Pn = Symbol("frameid");
const Ln = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/;
var En = Object.freeze({ __proto__: null, Script: Mn, sourceURLRegex: Ln });
const On = {
		local: "Local",
		closure: "Closure",
		block: "Block",
		script: "Script",
		withBlock: "`With` block",
		catchBlock: "`Catch` block",
		global: "Global",
		module: "Module",
		expression: "Expression",
	},
	An = i.i18n.registerUIStrings("core/sdk/DebuggerModel.ts", On),
	Nn = i.i18n.getLocalizedString.bind(void 0, An);
function Dn(e) {
	function t(e, t) {
		return e.lineNumber - t.lineNumber || e.columnNumber - t.columnNumber;
	}
	function n(e, n) {
		if (e.scriptId !== n.scriptId) return !1;
		const r = t(e.start, n.start);
		return r < 0 ? t(e.end, n.start) >= 0 : !(r > 0) || t(e.start, n.end) <= 0;
	}
	if (0 === e.length) return [];
	e.sort((e, n) =>
		e.scriptId < n.scriptId
			? -1
			: e.scriptId > n.scriptId
				? 1
				: t(e.start, n.start) || t(e.end, n.end)
	);
	let r = e[0];
	const s = [];
	for (let i = 1; i < e.length; ++i) {
		const a = e[i];
		n(r, a)
			? t(r.end, a.end) <= 0 && (r = { ...r, end: a.end })
			: (s.push(r), (r = a));
	}
	return (s.push(r), s);
}
var Fn;
!(function (e) {
	((e.StepInto = "StepInto"),
		(e.StepOut = "StepOut"),
		(e.StepOver = "StepOver"));
})(Fn || (Fn = {}));
class Bn extends c {
	agent;
	runtimeModelInternal;
	#Hn;
	#qn;
	#_n;
	#zn;
	#jn;
	continueToLocationCallback;
	#Wn;
	#Vn;
	#Gn;
	#Kn;
	#Qn;
	#$n;
	#Xn;
	evaluateOnCallFrameCallback;
	#Jn;
	#Yn = new e.ObjectWrapper.ObjectWrapper();
	#Zn;
	#er;
	constructor(t) {
		(super(t),
			t.registerDebuggerDispatcher(new _n(this)),
			(this.agent = t.debuggerAgent()),
			(this.runtimeModelInternal = t.model(yn)),
			(this.#Hn = new Zt(t)),
			(this.#qn = null),
			(this.#_n = new Map()),
			(this.#zn = new Map()),
			(this.#jn = []),
			(this.continueToLocationCallback = null),
			(this.#Wn = null),
			(this.#Vn = !1),
			(this.#Gn = null),
			(this.#Kn = 0),
			(this.#Qn = null),
			(this.#$n = null),
			(this.#Xn = null),
			(this.evaluateOnCallFrameCallback = null),
			(this.#Jn = null),
			(this.#Zn = null),
			(this.#er = !1),
			e.Settings.Settings.instance()
				.moduleSetting("pauseOnExceptionEnabled")
				.addChangeListener(this.pauseOnExceptionStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("pauseOnCaughtException")
				.addChangeListener(this.pauseOnExceptionStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("pauseOnUncaughtException")
				.addChangeListener(this.pauseOnExceptionStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("disableAsyncStackTraces")
				.addChangeListener(this.asyncStackTracesStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("breakpointsActive")
				.addChangeListener(this.breakpointsActiveChanged, this),
			t.suspended() || this.enableDebugger(),
			this.#Hn.setEnabled(
				e.Settings.Settings.instance()
					.moduleSetting("jsSourceMapsEnabled")
					.get()
			),
			e.Settings.Settings.instance()
				.moduleSetting("jsSourceMapsEnabled")
				.addChangeListener((e) => this.#Hn.setEnabled(e.data)));
		const n = t.model(Pr);
		n && n.addEventListener(xr.FrameNavigated, this.onFrameNavigated, this);
	}
	sourceMapManager() {
		return this.#Hn;
	}
	runtimeModel() {
		return this.runtimeModelInternal;
	}
	debuggerEnabled() {
		return Boolean(this.#Vn);
	}
	debuggerId() {
		return this.#Gn;
	}
	async enableDebugger() {
		if (this.#Vn) return;
		this.#Vn = !0;
		const t =
				a.Runtime.Runtime.queryParam("remoteFrontend") ||
				a.Runtime.Runtime.queryParam("ws")
					? 1e7
					: 1e8,
			n = this.agent.invoke_enable({ maxScriptsCacheSize: t });
		let r;
		(a.Runtime.experiments.isEnabled(
			a.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS
		) &&
			(r = this.agent.invoke_setInstrumentationBreakpoint({
				instrumentation: "beforeScriptExecution",
			})),
			this.pauseOnExceptionStateChanged(),
			this.asyncStackTracesStateChanged(),
			e.Settings.Settings.instance().moduleSetting("breakpointsActive").get() ||
				this.breakpointsActiveChanged(),
			this.dispatchEventToListeners(qn.DebuggerWasEnabled, this));
		const [s] = await Promise.all([n, r]);
		this.registerDebugger(s);
	}
	async syncDebuggerId() {
		const e =
				a.Runtime.Runtime.queryParam("remoteFrontend") ||
				a.Runtime.Runtime.queryParam("ws")
					? 1e7
					: 1e8,
			t = this.agent.invoke_enable({ maxScriptsCacheSize: e });
		return (t.then(this.registerDebugger.bind(this)), t);
	}
	onFrameNavigated() {
		Bn.shouldResyncDebuggerId || (Bn.shouldResyncDebuggerId = !0);
	}
	registerDebugger(e) {
		if (e.getError()) return;
		const { debuggerId: t } = e;
		(Un.set(t, this),
			(this.#Gn = t),
			this.dispatchEventToListeners(qn.DebuggerIsReadyToPause, this));
	}
	isReadyToPause() {
		return Boolean(this.#Gn);
	}
	static async modelForDebuggerId(e) {
		return (
			Bn.shouldResyncDebuggerId &&
				(await Bn.resyncDebuggerIdForModels(),
				(Bn.shouldResyncDebuggerId = !1)),
			Un.get(e) || null
		);
	}
	static async resyncDebuggerIdForModels() {
		const e = Un.values();
		for (const t of e) t.debuggerEnabled() && (await t.syncDebuggerId());
	}
	async disableDebugger() {
		this.#Vn &&
			((this.#Vn = !1),
			await this.asyncStackTracesStateChanged(),
			await this.agent.invoke_disable(),
			(this.#er = !1),
			this.globalObjectCleared(),
			this.dispatchEventToListeners(qn.DebuggerWasDisabled, this),
			"string" == typeof this.#Gn && Un.delete(this.#Gn),
			(this.#Gn = null));
	}
	skipAllPauses(e) {
		(this.#Kn && (clearTimeout(this.#Kn), (this.#Kn = 0)),
			this.agent.invoke_setSkipAllPauses({ skip: e }));
	}
	skipAllPausesUntilReloadOrTimeout(e) {
		(this.#Kn && clearTimeout(this.#Kn),
			this.agent.invoke_setSkipAllPauses({ skip: !0 }),
			(this.#Kn = window.setTimeout(this.skipAllPauses.bind(this, !1), e)));
	}
	pauseOnExceptionStateChanged() {
		const t = e.Settings.Settings.instance()
			.moduleSetting("pauseOnCaughtException")
			.get();
		let n;
		const r = e.Settings.Settings.instance()
			.moduleSetting("pauseOnUncaughtException")
			.get();
		((n = t && r ? "all" : t ? "caught" : r ? "uncaught" : "none"),
			this.agent.invoke_setPauseOnExceptions({ state: n }));
	}
	asyncStackTracesStateChanged() {
		const t =
			!e.Settings.Settings.instance()
				.moduleSetting("disableAsyncStackTraces")
				.get() && this.#Vn
				? 32
				: 0;
		return this.agent.invoke_setAsyncCallStackDepth({ maxDepth: t });
	}
	breakpointsActiveChanged() {
		this.agent.invoke_setBreakpointsActive({
			active: e.Settings.Settings.instance()
				.moduleSetting("breakpointsActive")
				.get(),
		});
	}
	setComputeAutoStepRangesCallback(e) {
		this.#$n = e;
	}
	async computeAutoStepSkipList(e) {
		let t = [];
		if (this.#$n && this.#qn && this.#qn.callFrames.length > 0) {
			const [n] = this.#qn.callFrames;
			t = await this.#$n.call(null, e, n);
		}
		return Dn(
			t.map(({ start: e, end: t }) => ({
				scriptId: e.scriptId,
				start: { lineNumber: e.lineNumber, columnNumber: e.columnNumber },
				end: { lineNumber: t.lineNumber, columnNumber: t.columnNumber },
			}))
		);
	}
	async stepInto() {
		const e = await this.computeAutoStepSkipList(Fn.StepInto);
		this.agent.invoke_stepInto({ breakOnAsyncCall: !1, skipList: e });
	}
	async stepOver() {
		this.#Zn = this.#qn?.callFrames[0]?.functionLocation() ?? null;
		const e = await this.computeAutoStepSkipList(Fn.StepOver);
		this.agent.invoke_stepOver({ skipList: e });
	}
	async stepOut() {
		const e = await this.computeAutoStepSkipList(Fn.StepOut);
		0 !== e.length
			? this.agent.invoke_stepOver({ skipList: e })
			: this.agent.invoke_stepOut();
	}
	scheduleStepIntoAsync() {
		this.computeAutoStepSkipList(Fn.StepInto).then((e) => {
			this.agent.invoke_stepInto({ breakOnAsyncCall: !0, skipList: e });
		});
	}
	resume() {
		(this.agent.invoke_resume({ terminateOnResume: !1 }), (this.#er = !1));
	}
	pause() {
		((this.#er = !0), this.skipAllPauses(!1), this.agent.invoke_pause());
	}
	async setBreakpointByURL(n, r, s, i) {
		let a;
		if (this.target().type() === je.Node && e.ParsedURL.schemeIs(n, "file:")) {
			const r = e.ParsedURL.ParsedURL.urlToRawPathString(n, o.Platform.isWin());
			((a = `${t.StringUtilities.escapeForRegExp(r)}|${t.StringUtilities.escapeForRegExp(n)}`),
				o.Platform.isWin() &&
					r.match(/^.:\\/) &&
					(a = `[${r[0].toUpperCase()}${r[0].toLowerCase()}]` + a.substr(1)));
		}
		let l = 0;
		const d = this.#zn.get(n) || [];
		for (let e = 0, t = d.length; e < t; ++e) {
			const t = d[e];
			r === t.lineOffset &&
				(l = l ? Math.min(l, t.columnOffset) : t.columnOffset);
		}
		s = Math.max(s || 0, l);
		const c = await this.agent.invoke_setBreakpointByUrl({
			lineNumber: r,
			url: a ? void 0 : n,
			urlRegex: a,
			columnNumber: s,
			condition: i,
		});
		if (c.getError()) return { locations: [], breakpointId: null };
		let h = [];
		return (
			c.locations && (h = c.locations.map((e) => zn.fromPayload(this, e))),
			{ locations: h, breakpointId: c.breakpointId }
		);
	}
	async setBreakpointInAnonymousScript(e, t, n, r) {
		const s = await this.agent.invoke_setBreakpointByUrl({
			lineNumber: t,
			scriptHash: e,
			columnNumber: n,
			condition: r,
		});
		if (s.getError()) return { locations: [], breakpointId: null };
		let i = [];
		return (
			s.locations && (i = s.locations.map((e) => zn.fromPayload(this, e))),
			{ locations: i, breakpointId: s.breakpointId }
		);
	}
	async removeBreakpoint(e) {
		await this.agent.invoke_removeBreakpoint({ breakpointId: e });
	}
	async getPossibleBreakpoints(e, t, n) {
		const r = await this.agent.invoke_getPossibleBreakpoints({
			start: e.payload(),
			end: t ? t.payload() : void 0,
			restrictToFunction: n,
		});
		return r.getError() || !r.locations
			? []
			: r.locations.map((e) => jn.fromPayload(this, e));
	}
	async fetchAsyncStackTrace(e) {
		const t = await this.agent.invoke_getStackTrace({ stackTraceId: e });
		return t.getError() ? null : t.stackTrace;
	}
	breakpointResolved(e, t) {
		this.#Yn.dispatchEventToListeners(e, zn.fromPayload(this, t));
	}
	globalObjectCleared() {
		(this.resetDebuggerPausedDetails(),
			this.reset(),
			this.dispatchEventToListeners(qn.GlobalObjectCleared, this));
	}
	reset() {
		for (const e of this.#_n.values()) this.#Hn.detachSourceMap(e);
		(this.#_n.clear(), this.#zn.clear(), (this.#jn = []), (this.#Zn = null));
	}
	scripts() {
		return Array.from(this.#_n.values());
	}
	scriptForId(e) {
		return this.#_n.get(e) || null;
	}
	scriptsForSourceURL(e) {
		return this.#zn.get(e) || [];
	}
	scriptsForExecutionContext(e) {
		const t = [];
		for (const n of this.#_n.values())
			n.executionContextId === e.id && t.push(n);
		return t;
	}
	get callFrames() {
		return this.#qn ? this.#qn.callFrames : null;
	}
	debuggerPausedDetails() {
		return this.#qn;
	}
	async setDebuggerPausedDetails(e) {
		return (
			(this.#er = !1),
			(this.#qn = e),
			!(this.#Qn && !(await this.#Qn.call(null, e, this.#Zn))) &&
				((this.#Zn = null),
				this.dispatchEventToListeners(qn.DebuggerPaused, this),
				this.setSelectedCallFrame(e.callFrames[0]),
				!0)
		);
	}
	resetDebuggerPausedDetails() {
		((this.#er = !1), (this.#qn = null), this.setSelectedCallFrame(null));
	}
	setBeforePausedCallback(e) {
		this.#Qn = e;
	}
	setExpandCallFramesCallback(e) {
		this.#Xn = e;
	}
	setEvaluateOnCallFrameCallback(e) {
		this.evaluateOnCallFrameCallback = e;
	}
	setSynchronizeBreakpointsCallback(e) {
		this.#Jn = e;
	}
	async pausedScript(t, n, r, s, i, a) {
		if ("instrumentation" === n) {
			const e = this.scriptForId(r.scriptId);
			return (this.#Jn && e && (await this.#Jn(e)), void this.resume());
		}
		const o = new Gn(this, t, n, r, s, i, a);
		if (
			(this.#Xn && (o.callFrames = await this.#Xn.call(null, o.callFrames)),
			this.continueToLocationCallback)
		) {
			const e = this.continueToLocationCallback;
			if (((this.continueToLocationCallback = null), e(o))) return;
		}
		(await this.setDebuggerPausedDetails(o))
			? e.EventTarget.fireEvent("DevTools.DebuggerPaused")
			: this.#Zn
				? this.stepOver()
				: this.stepInto();
	}
	resumedScript() {
		(this.resetDebuggerPausedDetails(),
			this.dispatchEventToListeners(qn.DebuggerResumed, this));
	}
	parsedScriptSource(
		e,
		t,
		n,
		r,
		s,
		i,
		a,
		l,
		d,
		c,
		h,
		u,
		g,
		p,
		m,
		f,
		b,
		y,
		v,
		I
	) {
		const k = this.#_n.get(e);
		if (k) return k;
		let S = !1;
		d && "isDefault" in d && (S = !d.isDefault);
		const w = new Mn(
			this,
			e,
			t,
			n,
			r,
			s,
			i,
			a,
			l,
			S,
			c,
			h,
			u,
			p,
			m,
			f,
			b,
			y,
			v,
			I
		);
		(this.registerScript(w),
			this.dispatchEventToListeners(qn.ParsedScriptSource, w),
			w.isInlineScript() &&
				!w.hasSourceURL &&
				(w.isModule
					? o.userMetrics.inlineScriptParsed(0)
					: o.userMetrics.inlineScriptParsed(1)),
			w.sourceMapURL &&
				!g &&
				this.#Hn.attachSourceMap(w, w.sourceURL, w.sourceMapURL));
		return (
			g &&
				w.isAnonymousScript() &&
				(this.#jn.push(w), this.collectDiscardedScripts()),
			w
		);
	}
	setSourceMapURL(e, t) {
		(this.#Hn.detachSourceMap(e),
			(e.sourceMapURL = t),
			this.#Hn.attachSourceMap(e, e.sourceURL, e.sourceMapURL));
	}
	async setDebugInfoURL(e, t) {
		(this.#Xn &&
			this.#qn &&
			(this.#qn.callFrames = await this.#Xn.call(null, this.#qn.callFrames)),
			this.dispatchEventToListeners(qn.DebugInfoAttached, e));
	}
	executionContextDestroyed(e) {
		for (const t of this.#_n.values())
			t.executionContextId === e.id && this.#Hn.detachSourceMap(t);
	}
	registerScript(e) {
		if ((this.#_n.set(e.scriptId, e), e.isAnonymousScript())) return;
		let t = this.#zn.get(e.sourceURL);
		(t || ((t = []), this.#zn.set(e.sourceURL, t)), t.unshift(e));
	}
	unregisterScript(e) {
		(console.assert(e.isAnonymousScript()), this.#_n.delete(e.scriptId));
	}
	collectDiscardedScripts() {
		if (this.#jn.length < 1e3) return;
		const e = this.#jn.splice(0, 100);
		for (const t of e)
			(this.unregisterScript(t),
				this.dispatchEventToListeners(qn.DiscardedAnonymousScriptSource, t));
	}
	createRawLocation(e, t, n, r) {
		return this.createRawLocationByScriptId(e.scriptId, t, n, r);
	}
	createRawLocationByURL(e, t, n, r) {
		for (const s of this.#zn.get(e) || [])
			if (
				!(
					s.lineOffset > t ||
					(s.lineOffset === t && void 0 !== n && s.columnOffset > n) ||
					s.endLine < t ||
					(s.endLine === t && void 0 !== n && s.endColumn <= n)
				)
			)
				return new zn(this, s.scriptId, t, n, r);
		return null;
	}
	createRawLocationByScriptId(e, t, n, r) {
		return new zn(this, e, t, n, r);
	}
	createRawLocationsByStackTrace(e) {
		const t = [];
		for (let n = e; n; n = n.parent)
			for (const {
				scriptId: e,
				lineNumber: r,
				columnNumber: s,
			} of n.callFrames)
				t.push(this.createRawLocationByScriptId(e, r, s));
		return t;
	}
	isPaused() {
		return Boolean(this.debuggerPausedDetails());
	}
	isPausing() {
		return this.#er;
	}
	setSelectedCallFrame(e) {
		this.#Wn !== e &&
			((this.#Wn = e),
			this.dispatchEventToListeners(qn.CallFrameSelected, this));
	}
	selectedCallFrame() {
		return this.#Wn;
	}
	async evaluateOnSelectedCallFrame(e) {
		const t = this.selectedCallFrame();
		if (!t) throw new Error("No call frame selected");
		return t.evaluate(e);
	}
	functionDetailsPromise(e) {
		return e.getAllProperties(!1, !1).then(
			function (e) {
				if (!e) return null;
				let t = null;
				if (e.internalProperties)
					for (const n of e.internalProperties)
						"[[FunctionLocation]]" === n.name && (t = n.value);
				let n = null;
				if (e.properties)
					for (const t of e.properties)
						"name" === t.name &&
							t.value &&
							"string" === t.value.type &&
							(n = t.value);
				let r = null;
				t &&
					(r = this.createRawLocationByScriptId(
						t.value.scriptId,
						t.value.lineNumber,
						t.value.columnNumber
					));
				return { location: r, functionName: n ? n.value : "" };
			}.bind(this)
		);
	}
	async setVariableValue(e, t, n, r) {
		return (
			await this.agent.invoke_setVariableValue({
				scopeNumber: e,
				variableName: t,
				newValue: n,
				callFrameId: r,
			})
		).getError();
	}
	addBreakpointListener(e, t, n) {
		this.#Yn.addEventListener(e, t, n);
	}
	removeBreakpointListener(e, t, n) {
		this.#Yn.removeEventListener(e, t, n);
	}
	async setBlackboxPatterns(e) {
		return !(
			await this.agent.invoke_setBlackboxPatterns({ patterns: e })
		).getError();
	}
	dispose() {
		(this.#Hn.dispose(),
			this.#Gn && Un.delete(this.#Gn),
			e.Settings.Settings.instance()
				.moduleSetting("pauseOnExceptionEnabled")
				.removeChangeListener(this.pauseOnExceptionStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("pauseOnCaughtException")
				.removeChangeListener(this.pauseOnExceptionStateChanged, this),
			e.Settings.Settings.instance()
				.moduleSetting("disableAsyncStackTraces")
				.removeChangeListener(this.asyncStackTracesStateChanged, this));
	}
	async suspendModel() {
		await this.disableDebugger();
	}
	async resumeModel() {
		await this.enableDebugger();
	}
	static shouldResyncDebuggerId = !1;
	getContinueToLocationCallback() {
		return this.continueToLocationCallback;
	}
	getEvaluateOnCallFrameCallback() {
		return this.evaluateOnCallFrameCallback;
	}
}
const Un = new Map();
var Hn, qn;
(!(function (e) {
	((e.DontPauseOnExceptions = "none"),
		(e.PauseOnAllExceptions = "all"),
		(e.PauseOnCaughtExceptions = "caught"),
		(e.PauseOnUncaughtExceptions = "uncaught"));
})(Hn || (Hn = {})),
	(function (e) {
		((e.DebuggerWasEnabled = "DebuggerWasEnabled"),
			(e.DebuggerWasDisabled = "DebuggerWasDisabled"),
			(e.DebuggerPaused = "DebuggerPaused"),
			(e.DebuggerResumed = "DebuggerResumed"),
			(e.DebugInfoAttached = "DebugInfoAttached"),
			(e.ParsedScriptSource = "ParsedScriptSource"),
			(e.DiscardedAnonymousScriptSource = "DiscardedAnonymousScriptSource"),
			(e.GlobalObjectCleared = "GlobalObjectCleared"),
			(e.CallFrameSelected = "CallFrameSelected"),
			(e.DebuggerIsReadyToPause = "DebuggerIsReadyToPause"),
			(e.ScriptSourceWasEdited = "ScriptSourceWasEdited"));
	})(qn || (qn = {})));
class _n {
	#tr;
	constructor(e) {
		this.#tr = e;
	}
	paused({
		callFrames: e,
		reason: t,
		data: n,
		hitBreakpoints: r,
		asyncStackTrace: s,
		asyncStackTraceId: i,
	}) {
		this.#tr.debuggerEnabled() && this.#tr.pausedScript(e, t, n, r || [], s, i);
	}
	resumed() {
		this.#tr.debuggerEnabled() && this.#tr.resumedScript();
	}
	scriptParsed({
		scriptId: e,
		url: t,
		startLine: n,
		startColumn: r,
		endLine: s,
		endColumn: i,
		executionContextId: a,
		hash: o,
		executionContextAuxData: l,
		isLiveEdit: d,
		sourceMapURL: c,
		hasSourceURL: h,
		length: u,
		isModule: g,
		stackTrace: p,
		codeOffset: m,
		scriptLanguage: f,
		debugSymbols: b,
		embedderName: y,
	}) {
		this.#tr.debuggerEnabled() &&
			this.#tr.parsedScriptSource(
				e,
				t,
				n,
				r,
				s,
				i,
				a,
				o,
				l,
				Boolean(d),
				c,
				Boolean(h),
				!1,
				u || 0,
				g || null,
				p || null,
				m || null,
				f || null,
				b || null,
				y || null
			);
	}
	scriptFailedToParse({
		scriptId: e,
		url: t,
		startLine: n,
		startColumn: r,
		endLine: s,
		endColumn: i,
		executionContextId: a,
		hash: o,
		executionContextAuxData: l,
		sourceMapURL: d,
		hasSourceURL: c,
		length: h,
		isModule: u,
		stackTrace: g,
		codeOffset: p,
		scriptLanguage: m,
		embedderName: f,
	}) {
		this.#tr.debuggerEnabled() &&
			this.#tr.parsedScriptSource(
				e,
				t,
				n,
				r,
				s,
				i,
				a,
				o,
				l,
				!1,
				d,
				Boolean(c),
				!0,
				h || 0,
				u || null,
				g || null,
				p || null,
				m || null,
				null,
				f || null
			);
	}
	breakpointResolved({ breakpointId: e, location: t }) {
		this.#tr.debuggerEnabled() && this.#tr.breakpointResolved(e, t);
	}
}
class zn {
	debuggerModel;
	scriptId;
	lineNumber;
	columnNumber;
	inlineFrameIndex;
	constructor(e, t, n, r, s) {
		((this.debuggerModel = e),
			(this.scriptId = t),
			(this.lineNumber = n),
			(this.columnNumber = r || 0),
			(this.inlineFrameIndex = s || 0));
	}
	static fromPayload(e, t, n) {
		return new zn(e, t.scriptId, t.lineNumber, t.columnNumber, n);
	}
	payload() {
		return {
			scriptId: this.scriptId,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
		};
	}
	script() {
		return this.debuggerModel.scriptForId(this.scriptId);
	}
	continueToLocation(e) {
		(e &&
			(this.debuggerModel.continueToLocationCallback = this.paused.bind(
				this,
				e
			)),
			this.debuggerModel.agent.invoke_continueToLocation({
				location: this.payload(),
				targetCallFrames: "current",
			}));
	}
	paused(e, t) {
		const n = t.callFrames[0].location();
		return (
			n.scriptId === this.scriptId &&
			n.lineNumber === this.lineNumber &&
			n.columnNumber === this.columnNumber &&
			(e(), !0)
		);
	}
	id() {
		return (
			this.debuggerModel.target().id() +
			":" +
			this.scriptId +
			":" +
			this.lineNumber +
			":" +
			this.columnNumber
		);
	}
}
class jn extends zn {
	type;
	constructor(e, t, n, r, s) {
		(super(e, t, n, r), s && (this.type = s));
	}
	static fromPayload(e, t) {
		return new jn(e, t.scriptId, t.lineNumber, t.columnNumber, t.type);
	}
}
class Wn {
	debuggerModel;
	script;
	payload;
	#nr;
	#rr;
	#sr;
	inlineFrameIndex;
	functionName;
	#ir;
	#ar;
	missingDebugInfoDetails;
	canBeRestarted;
	constructor(e, t, n, r, s) {
		((this.debuggerModel = e),
			(this.script = t),
			(this.payload = n),
			(this.#nr = zn.fromPayload(e, n.location, r)),
			(this.#rr = []),
			(this.#sr = null),
			(this.inlineFrameIndex = r || 0),
			(this.functionName = s || n.functionName),
			(this.missingDebugInfoDetails = null),
			(this.canBeRestarted = Boolean(n.canBeRestarted)));
		for (let e = 0; e < n.scopeChain.length; ++e) {
			const t = new Vn(this, e);
			(this.#rr.push(t), "local" === t.type() && (this.#sr = t));
		}
		(n.functionLocation && (this.#ir = zn.fromPayload(e, n.functionLocation)),
			(this.#ar = n.returnValue
				? this.debuggerModel.runtimeModel().createRemoteObject(n.returnValue)
				: null));
	}
	static fromPayloadArray(e, t) {
		const n = [];
		for (let r = 0; r < t.length; ++r) {
			const s = t[r],
				i = e.scriptForId(s.location.scriptId);
			i && n.push(new Wn(e, i, s));
		}
		return n;
	}
	createVirtualCallFrame(e, t) {
		return new Wn(this.debuggerModel, this.script, this.payload, e, t);
	}
	get id() {
		return this.payload.callFrameId;
	}
	scopeChain() {
		return this.#rr;
	}
	localScope() {
		return this.#sr;
	}
	thisObject() {
		return this.payload.this
			? this.debuggerModel.runtimeModel().createRemoteObject(this.payload.this)
			: null;
	}
	returnValue() {
		return this.#ar;
	}
	async setReturnValue(e) {
		if (!this.#ar) return null;
		const t = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({
			callFrameId: this.id,
			expression: e,
			silent: !0,
			objectGroup: "backtrace",
		});
		if (t.getError() || t.exceptionDetails) return null;
		return (
			await this.debuggerModel.agent.invoke_setReturnValue({
				newValue: t.result,
			})
		).getError()
			? null
			: ((this.#ar = this.debuggerModel
					.runtimeModel()
					.createRemoteObject(t.result)),
				this.#ar);
	}
	location() {
		return this.#nr;
	}
	functionLocation() {
		return this.#ir || null;
	}
	async evaluate(e) {
		const t = this.debuggerModel,
			n = t.runtimeModel();
		if (
			(Boolean(e.throwOnSideEffect) || void 0 !== e.timeout) &&
			(!1 === n.hasSideEffectSupport() ||
				(null === n.hasSideEffectSupport() &&
					!(await n.checkSideEffectSupport())))
		)
			return { error: "Side-effect checks not supported by backend." };
		const r = t.getEvaluateOnCallFrameCallback();
		if (r) {
			const t = await r(this, e);
			if (t) return t;
		}
		const s = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({
				callFrameId: this.id,
				expression: e.expression,
				objectGroup: e.objectGroup,
				includeCommandLineAPI: e.includeCommandLineAPI,
				silent: e.silent,
				returnByValue: e.returnByValue,
				generatePreview: e.generatePreview,
				throwOnSideEffect: e.throwOnSideEffect,
				timeout: e.timeout,
			}),
			i = s.getError();
		return i
			? { error: i }
			: {
					object: n.createRemoteObject(s.result),
					exceptionDetails: s.exceptionDetails,
				};
	}
	async restart() {
		(console.assert(this.canBeRestarted, "This frame can not be restarted."),
			await this.debuggerModel.agent.invoke_restartFrame({
				callFrameId: this.id,
				mode: "StepInto",
			}));
	}
	getPayload() {
		return this.payload;
	}
}
class Vn {
	#or;
	#lr;
	#f;
	#p;
	#dr;
	#cr;
	#ct;
	constructor(e, t) {
		((this.#or = e),
			(this.#lr = e.getPayload().scopeChain[t]),
			(this.#f = this.#lr.type),
			(this.#p = this.#lr.name),
			(this.#dr = t),
			(this.#ct = null));
		const n = this.#lr.startLocation
				? zn.fromPayload(e.debuggerModel, this.#lr.startLocation)
				: null,
			r = this.#lr.endLocation
				? zn.fromPayload(e.debuggerModel, this.#lr.endLocation)
				: null;
		n && r && n.scriptId === r.scriptId
			? (this.#cr = { start: n, end: r })
			: (this.#cr = null);
	}
	callFrame() {
		return this.#or;
	}
	type() {
		return this.#f;
	}
	typeName() {
		switch (this.#f) {
			case "local":
				return Nn(On.local);
			case "closure":
				return Nn(On.closure);
			case "catch":
				return Nn(On.catchBlock);
			case "eval":
				return i.i18n.lockedString("Eval");
			case "block":
				return Nn(On.block);
			case "script":
				return Nn(On.script);
			case "with":
				return Nn(On.withBlock);
			case "global":
				return Nn(On.global);
			case "module":
				return Nn(On.module);
			case "wasm-expression-stack":
				return Nn(On.expression);
		}
		return "";
	}
	name() {
		return this.#p;
	}
	range() {
		return this.#cr;
	}
	object() {
		if (this.#ct) return this.#ct;
		const e = this.#or.debuggerModel.runtimeModel(),
			t = "with" !== this.#f && "global" !== this.#f;
		return (
			(this.#ct = t
				? e.createScopeRemoteObject(
						this.#lr.object,
						new it(this.#dr, this.#or.id)
					)
				: e.createRemoteObject(this.#lr.object)),
			this.#ct
		);
	}
	description() {
		return "with" !== this.#f && "global" !== this.#f
			? ""
			: this.#lr.object.description || "";
	}
	icon() {}
}
class Gn {
	debuggerModel;
	callFrames;
	reason;
	auxData;
	breakpointIds;
	asyncStackTrace;
	asyncStackTraceId;
	constructor(e, t, n, r, s, i, a) {
		((this.debuggerModel = e),
			(this.callFrames = Wn.fromPayloadArray(e, t)),
			(this.reason = n),
			(this.auxData = r),
			(this.breakpointIds = s),
			i && (this.asyncStackTrace = this.cleanRedundantFrames(i)),
			(this.asyncStackTraceId = a));
	}
	exception() {
		return "exception" !== this.reason && "promiseRejection" !== this.reason
			? null
			: this.debuggerModel.runtimeModel().createRemoteObject(this.auxData);
	}
	cleanRedundantFrames(e) {
		let t = e,
			n = null;
		for (; t; )
			("async function" === t.description &&
				t.callFrames.length &&
				t.callFrames.shift(),
				n && !t.callFrames.length ? (n.parent = t.parent) : (n = t),
				(t = t.parent));
		return e;
	}
}
c.register(Bn, { capabilities: We.JS, autostart: !0 });
const Kn = "debugger://logpoint",
	Qn = "debugger://breakpoint";
var $n = Object.freeze({
	__proto__: null,
	sortAndMergeRanges: Dn,
	get StepMode() {
		return Fn;
	},
	DebuggerModel: Bn,
	_debuggerIdToModel: Un,
	get PauseOnExceptionsState() {
		return Hn;
	},
	get Events() {
		return qn;
	},
	Location: zn,
	BreakLocation: jn,
	CallFrame: Wn,
	Scope: Vn,
	DebuggerPausedDetails: Gn,
	LOGPOINT_SOURCE_URL: Kn,
	COND_BREAKPOINT_SOURCE_URL: Qn,
});
class Xn {
	#hr;
	#ur;
	constructor() {
		const t = "rgba";
		((this.#hr = [
			new e.Color.Legacy(
				[0.9607843137254902, 0.592156862745098, 0.5803921568627451, 1],
				t
			),
			new e.Color.Legacy(
				[0.9411764705882353, 0.7490196078431373, 0.2980392156862745, 1],
				t
			),
			new e.Color.Legacy(
				[0.8313725490196079, 0.9294117647058824, 0.19215686274509805, 1],
				t
			),
			new e.Color.Legacy(
				[0.6196078431372549, 0.9215686274509803, 0.2784313725490196, 1],
				t
			),
			new e.Color.Legacy(
				[0.3568627450980392, 0.8196078431372549, 0.8431372549019608, 1],
				t
			),
			new e.Color.Legacy(
				[0.7372549019607844, 0.807843137254902, 0.984313725490196, 1],
				t
			),
			new e.Color.Legacy(
				[0.7764705882352941, 0.7450980392156863, 0.9333333333333333, 1],
				t
			),
			new e.Color.Legacy(
				[0.8156862745098039, 0.5803921568627451, 0.9176470588235294, 1],
				t
			),
			new e.Color.Legacy(
				[0.9215686274509803, 0.5803921568627451, 0.8117647058823529, 1],
				t
			),
		]),
			(this.#ur = 0));
	}
	next() {
		const e = this.#hr[this.#ur];
		return (this.#ur++, this.#ur >= this.#hr.length && (this.#ur = 0), e);
	}
}
var Jn = Object.freeze({ __proto__: null, OverlayColorGenerator: Xn });
class Yn {
	#gr;
	#hr;
	#pr;
	#mr;
	#fr;
	#br;
	#yr;
	#vr;
	#Ir;
	#kr;
	#Sr;
	#wr;
	#Cr;
	#Rr;
	#Tr;
	constructor(t, n) {
		((this.#gr = t),
			(this.#Tr = n),
			(this.#pr = e.Settings.Settings.instance().createLocalSetting(
				"persistentHighlightSetting",
				[]
			)),
			(this.#mr = new Map()),
			(this.#fr = new Map()),
			(this.#br = new Map()),
			(this.#yr = new Map()),
			(this.#vr = new Map()),
			(this.#hr = new Map()),
			(this.#Ir = new Xn()),
			(this.#kr = new Xn()),
			(this.#Sr =
				e.Settings.Settings.instance().moduleSetting("showGridLineLabels")),
			this.#Sr.addChangeListener(this.onSettingChange, this),
			(this.#wr =
				e.Settings.Settings.instance().moduleSetting("extendGridLines")),
			this.#wr.addChangeListener(this.onSettingChange, this),
			(this.#Cr =
				e.Settings.Settings.instance().moduleSetting("showGridAreas")),
			this.#Cr.addChangeListener(this.onSettingChange, this),
			(this.#Rr =
				e.Settings.Settings.instance().moduleSetting("showGridTrackSizes")),
			this.#Rr.addChangeListener(this.onSettingChange, this));
	}
	onSettingChange() {
		this.resetOverlay();
	}
	buildGridHighlightConfig(e) {
		const t = this.colorOfGrid(e).asLegacyColor(),
			n = t.setAlpha(0.1).asLegacyColor(),
			r = t.setAlpha(0.3).asLegacyColor(),
			s = t.setAlpha(0.8).asLegacyColor(),
			i = this.#wr.get(),
			a = "lineNumbers" === this.#Sr.get(),
			o = a,
			l = "lineNames" === this.#Sr.get();
		return {
			rowGapColor: r.toProtocolRGBA(),
			rowHatchColor: s.toProtocolRGBA(),
			columnGapColor: r.toProtocolRGBA(),
			columnHatchColor: s.toProtocolRGBA(),
			gridBorderColor: t.toProtocolRGBA(),
			gridBorderDash: !1,
			rowLineColor: t.toProtocolRGBA(),
			columnLineColor: t.toProtocolRGBA(),
			rowLineDash: !0,
			columnLineDash: !0,
			showGridExtensionLines: i,
			showPositiveLineNumbers: a,
			showNegativeLineNumbers: o,
			showLineNames: l,
			showAreaNames: this.#Cr.get(),
			showTrackSizes: this.#Rr.get(),
			areaBorderColor: t.toProtocolRGBA(),
			gridBackgroundColor: n.toProtocolRGBA(),
		};
	}
	buildFlexContainerHighlightConfig(e) {
		const t = this.colorOfFlex(e).asLegacyColor();
		return {
			containerBorder: { color: t.toProtocolRGBA(), pattern: "dashed" },
			itemSeparator: { color: t.toProtocolRGBA(), pattern: "dotted" },
			lineSeparator: { color: t.toProtocolRGBA(), pattern: "dashed" },
			mainDistributedSpace: { hatchColor: t.toProtocolRGBA() },
			crossDistributedSpace: { hatchColor: t.toProtocolRGBA() },
		};
	}
	buildScrollSnapContainerHighlightConfig(t) {
		return {
			snapAreaBorder: {
				color: e.Color.PageHighlight.GridBorder.toProtocolRGBA(),
				pattern: "dashed",
			},
			snapportBorder: {
				color: e.Color.PageHighlight.GridBorder.toProtocolRGBA(),
			},
			scrollMarginColor: e.Color.PageHighlight.Margin.toProtocolRGBA(),
			scrollPaddingColor: e.Color.PageHighlight.Padding.toProtocolRGBA(),
		};
	}
	highlightGridInOverlay(e) {
		(this.#mr.set(e, this.buildGridHighlightConfig(e)),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onGridOverlayStateChanged({ nodeId: e, enabled: !0 }));
	}
	isGridHighlighted(e) {
		return this.#mr.has(e);
	}
	colorOfGrid(e) {
		let t = this.#hr.get(e);
		return (t || ((t = this.#Ir.next()), this.#hr.set(e, t)), t);
	}
	setColorOfGrid(e, t) {
		this.#hr.set(e, t);
	}
	hideGridInOverlay(e) {
		this.#mr.has(e) &&
			(this.#mr.delete(e),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onGridOverlayStateChanged({ nodeId: e, enabled: !1 }));
	}
	highlightScrollSnapInOverlay(e) {
		(this.#fr.set(e, this.buildScrollSnapContainerHighlightConfig(e)),
			this.updateHighlightsInOverlay(),
			this.#Tr.onScrollSnapOverlayStateChanged({ nodeId: e, enabled: !0 }),
			this.savePersistentHighlightSetting());
	}
	isScrollSnapHighlighted(e) {
		return this.#fr.has(e);
	}
	hideScrollSnapInOverlay(e) {
		this.#fr.has(e) &&
			(this.#fr.delete(e),
			this.updateHighlightsInOverlay(),
			this.#Tr.onScrollSnapOverlayStateChanged({ nodeId: e, enabled: !1 }),
			this.savePersistentHighlightSetting());
	}
	highlightFlexInOverlay(e) {
		(this.#br.set(e, this.buildFlexContainerHighlightConfig(e)),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onFlexOverlayStateChanged({ nodeId: e, enabled: !0 }));
	}
	isFlexHighlighted(e) {
		return this.#br.has(e);
	}
	colorOfFlex(e) {
		let t = this.#hr.get(e);
		return (t || ((t = this.#kr.next()), this.#hr.set(e, t)), t);
	}
	setColorOfFlex(e, t) {
		this.#hr.set(e, t);
	}
	hideFlexInOverlay(e) {
		this.#br.has(e) &&
			(this.#br.delete(e),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onFlexOverlayStateChanged({ nodeId: e, enabled: !1 }));
	}
	highlightContainerQueryInOverlay(e) {
		(this.#yr.set(e, this.buildContainerQueryContainerHighlightConfig()),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onContainerQueryOverlayStateChanged({ nodeId: e, enabled: !0 }));
	}
	hideContainerQueryInOverlay(e) {
		this.#yr.has(e) &&
			(this.#yr.delete(e),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting(),
			this.#Tr.onContainerQueryOverlayStateChanged({ nodeId: e, enabled: !1 }));
	}
	isContainerQueryHighlighted(e) {
		return this.#yr.has(e);
	}
	buildContainerQueryContainerHighlightConfig() {
		return {
			containerBorder: {
				color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
				pattern: "dashed",
			},
			descendantBorder: {
				color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
				pattern: "dashed",
			},
		};
	}
	highlightIsolatedElementInOverlay(e) {
		(this.#vr.set(e, this.buildIsolationModeHighlightConfig()),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting());
	}
	hideIsolatedElementInOverlay(e) {
		this.#vr.has(e) &&
			(this.#vr.delete(e),
			this.updateHighlightsInOverlay(),
			this.savePersistentHighlightSetting());
	}
	isIsolatedElementHighlighted(e) {
		return this.#vr.has(e);
	}
	buildIsolationModeHighlightConfig() {
		return {
			resizerColor: e.Color.IsolationModeHighlight.Resizer.toProtocolRGBA(),
			resizerHandleColor:
				e.Color.IsolationModeHighlight.ResizerHandle.toProtocolRGBA(),
			maskColor: e.Color.IsolationModeHighlight.Mask.toProtocolRGBA(),
		};
	}
	hideAllInOverlayWithoutSave() {
		(this.#br.clear(),
			this.#mr.clear(),
			this.#fr.clear(),
			this.#yr.clear(),
			this.#vr.clear(),
			this.updateHighlightsInOverlay());
	}
	refreshHighlights() {
		const e = this.updateHighlightsForDeletedNodes(this.#mr),
			t = this.updateHighlightsForDeletedNodes(this.#br),
			n = this.updateHighlightsForDeletedNodes(this.#fr),
			r = this.updateHighlightsForDeletedNodes(this.#yr),
			s = this.updateHighlightsForDeletedNodes(this.#vr);
		(t || e || n || r || s) &&
			(this.updateHighlightsInOverlay(), this.savePersistentHighlightSetting());
	}
	updateHighlightsForDeletedNodes(e) {
		let t = !1;
		for (const n of e.keys())
			null === this.#gr.getDOMModel().nodeForId(n) && (e.delete(n), (t = !0));
		return t;
	}
	resetOverlay() {
		for (const e of this.#mr.keys())
			this.#mr.set(e, this.buildGridHighlightConfig(e));
		for (const e of this.#br.keys())
			this.#br.set(e, this.buildFlexContainerHighlightConfig(e));
		for (const e of this.#fr.keys())
			this.#fr.set(e, this.buildScrollSnapContainerHighlightConfig(e));
		for (const e of this.#yr.keys())
			this.#yr.set(e, this.buildContainerQueryContainerHighlightConfig());
		for (const e of this.#vr.keys())
			this.#vr.set(e, this.buildIsolationModeHighlightConfig());
		this.updateHighlightsInOverlay();
	}
	updateHighlightsInOverlay() {
		const e =
			this.#mr.size > 0 ||
			this.#br.size > 0 ||
			this.#yr.size > 0 ||
			this.#vr.size > 0;
		(this.#gr.setShowViewportSizeOnResize(!e),
			this.updateGridHighlightsInOverlay(),
			this.updateFlexHighlightsInOverlay(),
			this.updateScrollSnapHighlightsInOverlay(),
			this.updateContainerQueryHighlightsInOverlay(),
			this.updateIsolatedElementHighlightsInOverlay());
	}
	updateGridHighlightsInOverlay() {
		const e = this.#gr,
			t = [];
		for (const [e, n] of this.#mr.entries())
			t.push({ nodeId: e, gridHighlightConfig: n });
		e.target()
			.overlayAgent()
			.invoke_setShowGridOverlays({ gridNodeHighlightConfigs: t });
	}
	updateFlexHighlightsInOverlay() {
		const e = this.#gr,
			t = [];
		for (const [e, n] of this.#br.entries())
			t.push({ nodeId: e, flexContainerHighlightConfig: n });
		e.target()
			.overlayAgent()
			.invoke_setShowFlexOverlays({ flexNodeHighlightConfigs: t });
	}
	updateScrollSnapHighlightsInOverlay() {
		const e = this.#gr,
			t = [];
		for (const [e, n] of this.#fr.entries())
			t.push({ nodeId: e, scrollSnapContainerHighlightConfig: n });
		e.target()
			.overlayAgent()
			.invoke_setShowScrollSnapOverlays({ scrollSnapHighlightConfigs: t });
	}
	updateContainerQueryHighlightsInOverlay() {
		const e = this.#gr,
			t = [];
		for (const [e, n] of this.#yr.entries())
			t.push({ nodeId: e, containerQueryContainerHighlightConfig: n });
		e.target()
			.overlayAgent()
			.invoke_setShowContainerQueryOverlays({
				containerQueryHighlightConfigs: t,
			});
	}
	updateIsolatedElementHighlightsInOverlay() {
		const e = this.#gr,
			t = [];
		for (const [e, n] of this.#vr.entries())
			t.push({ nodeId: e, isolationModeHighlightConfig: n });
		e.target()
			.overlayAgent()
			.invoke_setShowIsolatedElements({ isolatedElementHighlightConfigs: t });
	}
	async restoreHighlightsForDocument() {
		((this.#br = new Map()),
			(this.#mr = new Map()),
			(this.#fr = new Map()),
			(this.#yr = new Map()),
			(this.#vr = new Map()));
		const e = await this.#gr.getDOMModel().requestDocument(),
			n = e ? e.documentURL : t.DevToolsPath.EmptyUrlString;
		(await Promise.all(
			this.#pr.get().map(async (e) => {
				if (e.url === n)
					return this.#gr
						.getDOMModel()
						.pushNodeByPathToFrontend(e.path)
						.then((t) => {
							const n = this.#gr.getDOMModel().nodeForId(t);
							if (n)
								switch (e.type) {
									case "GRID":
										(this.#mr.set(n.id, this.buildGridHighlightConfig(n.id)),
											this.#Tr.onGridOverlayStateChanged({
												nodeId: n.id,
												enabled: !0,
											}));
										break;
									case "FLEX":
										(this.#br.set(
											n.id,
											this.buildFlexContainerHighlightConfig(n.id)
										),
											this.#Tr.onFlexOverlayStateChanged({
												nodeId: n.id,
												enabled: !0,
											}));
										break;
									case "CONTAINER_QUERY":
										(this.#yr.set(
											n.id,
											this.buildContainerQueryContainerHighlightConfig()
										),
											this.#Tr.onContainerQueryOverlayStateChanged({
												nodeId: n.id,
												enabled: !0,
											}));
										break;
									case "SCROLL_SNAP":
										(this.#fr.set(
											n.id,
											this.buildScrollSnapContainerHighlightConfig(n.id)
										),
											this.#Tr.onScrollSnapOverlayStateChanged({
												nodeId: n.id,
												enabled: !0,
											}));
										break;
									case "ISOLATED_ELEMENT":
										this.#vr.set(
											n.id,
											this.buildIsolationModeHighlightConfig()
										);
								}
						});
			})
		),
			this.updateHighlightsInOverlay());
	}
	currentUrl() {
		const e = this.#gr.getDOMModel().existingDocument();
		return e ? e.documentURL : t.DevToolsPath.EmptyUrlString;
	}
	getPersistentHighlightSettingForOneType(e, t) {
		const n = [];
		for (const r of e.keys()) {
			const e = this.#gr.getDOMModel().nodeForId(r);
			e && n.push({ url: this.currentUrl(), path: e.path(), type: t });
		}
		return n;
	}
	savePersistentHighlightSetting() {
		const e = this.currentUrl(),
			t = [
				...this.#pr.get().filter((t) => t.url !== e),
				...this.getPersistentHighlightSettingForOneType(this.#mr, "GRID"),
				...this.getPersistentHighlightSettingForOneType(this.#br, "FLEX"),
				...this.getPersistentHighlightSettingForOneType(
					this.#yr,
					"CONTAINER_QUERY"
				),
				...this.getPersistentHighlightSettingForOneType(
					this.#fr,
					"SCROLL_SNAP"
				),
				...this.getPersistentHighlightSettingForOneType(
					this.#vr,
					"ISOLATED_ELEMENT"
				),
			];
		this.#pr.set(t);
	}
}
var Zn = Object.freeze({ __proto__: null, OverlayPersistentHighlighter: Yn });
const er = { pausedInDebugger: "Paused in debugger" },
	tr = i.i18n.registerUIStrings("core/sdk/OverlayModel.ts", er),
	nr = i.i18n.getLocalizedString.bind(void 0, tr),
	rr = {
		mac: { x: 85, y: 0, width: 185, height: 40 },
		linux: { x: 0, y: 0, width: 196, height: 34 },
		windows: { x: 0, y: 0, width: 238, height: 33 },
	};
class sr extends c {
	#an;
	overlayAgent;
	#tr;
	#xr;
	#Mr;
	#Pr;
	#Lr;
	#Er;
	#Or;
	#Ar;
	#Nr;
	#Dr;
	#Fr;
	#Br;
	#Ur;
	#Hr;
	#qr;
	#_r;
	#zr;
	#jr;
	constructor(t) {
		(super(t),
			(this.#an = t.model(mr)),
			t.registerOverlayDispatcher(this),
			(this.overlayAgent = t.overlayAgent()),
			(this.#tr = t.model(Bn)),
			this.#tr &&
				(e.Settings.Settings.instance()
					.moduleSetting("disablePausedStateOverlay")
					.addChangeListener(this.updatePausedInDebuggerMessage, this),
				this.#tr.addEventListener(
					qn.DebuggerPaused,
					this.updatePausedInDebuggerMessage,
					this
				),
				this.#tr.addEventListener(
					qn.DebuggerResumed,
					this.updatePausedInDebuggerMessage,
					this
				),
				this.#tr.addEventListener(
					qn.GlobalObjectCleared,
					this.updatePausedInDebuggerMessage,
					this
				)),
			(this.#xr = !1),
			(this.#Mr = null),
			(this.#Pr = new or(this)),
			(this.#Lr = this.#Pr),
			(this.#Er =
				e.Settings.Settings.instance().moduleSetting("showPaintRects")),
			(this.#Or = e.Settings.Settings.instance().moduleSetting(
				"showLayoutShiftRegions"
			)),
			(this.#Ar =
				e.Settings.Settings.instance().moduleSetting("showAdHighlights")),
			(this.#Nr =
				e.Settings.Settings.instance().moduleSetting("showDebugBorders")),
			(this.#Dr =
				e.Settings.Settings.instance().moduleSetting("showFPSCounter")),
			(this.#Fr = e.Settings.Settings.instance().moduleSetting(
				"showScrollBottleneckRects"
			)),
			(this.#Br =
				e.Settings.Settings.instance().moduleSetting("showWebVitals")),
			(this.#Ur = []),
			(this.#Hr = !0),
			t.suspended() ||
				(this.overlayAgent.invoke_enable(), this.wireAgentToSettings()),
			(this.#qr = new Yn(this, {
				onGridOverlayStateChanged: ({ nodeId: e, enabled: t }) =>
					this.dispatchEventToListeners(ar.PersistentGridOverlayStateChanged, {
						nodeId: e,
						enabled: t,
					}),
				onFlexOverlayStateChanged: ({ nodeId: e, enabled: t }) =>
					this.dispatchEventToListeners(
						ar.PersistentFlexContainerOverlayStateChanged,
						{ nodeId: e, enabled: t }
					),
				onContainerQueryOverlayStateChanged: ({ nodeId: e, enabled: t }) =>
					this.dispatchEventToListeners(
						ar.PersistentContainerQueryOverlayStateChanged,
						{ nodeId: e, enabled: t }
					),
				onScrollSnapOverlayStateChanged: ({ nodeId: e, enabled: t }) =>
					this.dispatchEventToListeners(
						ar.PersistentScrollSnapOverlayStateChanged,
						{ nodeId: e, enabled: t }
					),
			})),
			this.#an.addEventListener(dr.NodeRemoved, () => {
				this.#qr && this.#qr.refreshHighlights();
			}),
			this.#an.addEventListener(dr.DocumentUpdated, () => {
				this.#qr &&
					(this.#qr.hideAllInOverlayWithoutSave(),
					t.suspended() || this.#qr.restoreHighlightsForDocument());
			}),
			(this.#_r = new lr(this)),
			(this.#zr = !1),
			(this.#jr = new ir(this.#an.cssModel())));
	}
	static highlightObjectAsDOMNode(e) {
		const t = e.runtimeModel().target().model(mr);
		t &&
			t.overlayModel().highlightInOverlay({ object: e, selectorList: void 0 });
	}
	static hideDOMNodeHighlight() {
		for (const e of $e.instance().models(sr)) e.delayedHideHighlight(0);
	}
	static async muteHighlight() {
		return Promise.all(
			$e
				.instance()
				.models(sr)
				.map((e) => e.suspendModel())
		);
	}
	static async unmuteHighlight() {
		return Promise.all(
			$e
				.instance()
				.models(sr)
				.map((e) => e.resumeModel())
		);
	}
	static highlightRect(e) {
		for (const t of $e.instance().models(sr)) t.highlightRect(e);
	}
	static clearHighlight() {
		for (const e of $e.instance().models(sr)) e.clearHighlight();
	}
	getDOMModel() {
		return this.#an;
	}
	highlightRect({
		x: e,
		y: t,
		width: n,
		height: r,
		color: s,
		outlineColor: i,
	}) {
		const a = s || { r: 255, g: 0, b: 255, a: 0.3 },
			o = i || { r: 255, g: 0, b: 255, a: 0.5 };
		return this.overlayAgent.invoke_highlightRect({
			x: e,
			y: t,
			width: n,
			height: r,
			color: a,
			outlineColor: o,
		});
	}
	clearHighlight() {
		return this.overlayAgent.invoke_hideHighlight();
	}
	async wireAgentToSettings() {
		((this.#Ur = [
			this.#Er.addChangeListener(() =>
				this.overlayAgent.invoke_setShowPaintRects({ result: this.#Er.get() })
			),
			this.#Or.addChangeListener(() =>
				this.overlayAgent.invoke_setShowLayoutShiftRegions({
					result: this.#Or.get(),
				})
			),
			this.#Ar.addChangeListener(() =>
				this.overlayAgent.invoke_setShowAdHighlights({ show: this.#Ar.get() })
			),
			this.#Nr.addChangeListener(() =>
				this.overlayAgent.invoke_setShowDebugBorders({ show: this.#Nr.get() })
			),
			this.#Dr.addChangeListener(() =>
				this.overlayAgent.invoke_setShowFPSCounter({ show: this.#Dr.get() })
			),
			this.#Fr.addChangeListener(() =>
				this.overlayAgent.invoke_setShowScrollBottleneckRects({
					show: this.#Fr.get(),
				})
			),
			this.#Br.addChangeListener(() =>
				this.overlayAgent.invoke_setShowWebVitals({ show: this.#Br.get() })
			),
		]),
			this.#Er.get() &&
				this.overlayAgent.invoke_setShowPaintRects({ result: !0 }),
			this.#Or.get() &&
				this.overlayAgent.invoke_setShowLayoutShiftRegions({ result: !0 }),
			this.#Ar.get() &&
				this.overlayAgent.invoke_setShowAdHighlights({ show: !0 }),
			this.#Nr.get() &&
				this.overlayAgent.invoke_setShowDebugBorders({ show: !0 }),
			this.#Dr.get() &&
				this.overlayAgent.invoke_setShowFPSCounter({ show: !0 }),
			this.#Fr.get() &&
				this.overlayAgent.invoke_setShowScrollBottleneckRects({ show: !0 }),
			this.#Br.get() && this.overlayAgent.invoke_setShowWebVitals({ show: !0 }),
			this.#tr && this.#tr.isPaused() && this.updatePausedInDebuggerMessage(),
			await this.overlayAgent.invoke_setShowViewportSizeOnResize({
				show: this.#Hr,
			}),
			this.#qr?.resetOverlay());
	}
	async suspendModel() {
		(e.EventTarget.removeEventListeners(this.#Ur),
			await this.overlayAgent.invoke_disable());
	}
	async resumeModel() {
		await Promise.all([
			this.overlayAgent.invoke_enable(),
			this.wireAgentToSettings(),
		]);
	}
	setShowViewportSizeOnResize(e) {
		this.#Hr !== e &&
			((this.#Hr = e),
			this.target().suspended() ||
				this.overlayAgent.invoke_setShowViewportSizeOnResize({ show: e }));
	}
	updatePausedInDebuggerMessage() {
		if (this.target().suspended()) return;
		const t =
			this.#tr &&
			this.#tr.isPaused() &&
			!e.Settings.Settings.instance()
				.moduleSetting("disablePausedStateOverlay")
				.get()
				? nr(er.pausedInDebugger)
				: void 0;
		this.overlayAgent.invoke_setPausedInDebuggerMessage({ message: t });
	}
	setHighlighter(e) {
		this.#Lr = e || this.#Pr;
	}
	async setInspectMode(e, t = !0) {
		(await this.#an.requestDocument(),
			(this.#xr = "none" !== e),
			this.dispatchEventToListeners(ar.InspectModeWillBeToggled, this),
			this.#Lr.setInspectMode(e, this.buildHighlightConfig("all", t)));
	}
	inspectModeEnabled() {
		return this.#xr;
	}
	highlightInOverlay(e, t, n) {
		if (this.#zr) return;
		this.#Mr && (clearTimeout(this.#Mr), (this.#Mr = null));
		const r = this.buildHighlightConfig(t);
		(void 0 !== n && (r.showInfo = n), this.#Lr.highlightInOverlay(e, r));
	}
	highlightInOverlayForTwoSeconds(e) {
		(this.highlightInOverlay(e), this.delayedHideHighlight(2e3));
	}
	highlightGridInPersistentOverlay(e) {
		this.#qr && this.#qr.highlightGridInOverlay(e);
	}
	isHighlightedGridInPersistentOverlay(e) {
		return !!this.#qr && this.#qr.isGridHighlighted(e);
	}
	hideGridInPersistentOverlay(e) {
		this.#qr && this.#qr.hideGridInOverlay(e);
	}
	highlightScrollSnapInPersistentOverlay(e) {
		this.#qr && this.#qr.highlightScrollSnapInOverlay(e);
	}
	isHighlightedScrollSnapInPersistentOverlay(e) {
		return !!this.#qr && this.#qr.isScrollSnapHighlighted(e);
	}
	hideScrollSnapInPersistentOverlay(e) {
		this.#qr && this.#qr.hideScrollSnapInOverlay(e);
	}
	highlightFlexContainerInPersistentOverlay(e) {
		this.#qr && this.#qr.highlightFlexInOverlay(e);
	}
	isHighlightedFlexContainerInPersistentOverlay(e) {
		return !!this.#qr && this.#qr.isFlexHighlighted(e);
	}
	hideFlexContainerInPersistentOverlay(e) {
		this.#qr && this.#qr.hideFlexInOverlay(e);
	}
	highlightContainerQueryInPersistentOverlay(e) {
		this.#qr && this.#qr.highlightContainerQueryInOverlay(e);
	}
	isHighlightedContainerQueryInPersistentOverlay(e) {
		return !!this.#qr && this.#qr.isContainerQueryHighlighted(e);
	}
	hideContainerQueryInPersistentOverlay(e) {
		this.#qr && this.#qr.hideContainerQueryInOverlay(e);
	}
	highlightSourceOrderInOverlay(t) {
		const n = {
			parentOutlineColor:
				e.Color.SourceOrderHighlight.ParentOutline.toProtocolRGBA(),
			childOutlineColor:
				e.Color.SourceOrderHighlight.ChildOutline.toProtocolRGBA(),
		};
		this.#_r.highlightSourceOrderInOverlay(t, n);
	}
	colorOfGridInPersistentOverlay(e) {
		return this.#qr ? this.#qr.colorOfGrid(e).asString("hex") : null;
	}
	setColorOfGridInPersistentOverlay(t, n) {
		if (!this.#qr) return;
		const r = e.Color.parse(n);
		r && (this.#qr.setColorOfGrid(t, r), this.#qr.resetOverlay());
	}
	colorOfFlexInPersistentOverlay(e) {
		return this.#qr ? this.#qr.colorOfFlex(e).asString("hex") : null;
	}
	setColorOfFlexInPersistentOverlay(t, n) {
		if (!this.#qr) return;
		const r = e.Color.parse(n);
		r && (this.#qr.setColorOfFlex(t, r), this.#qr.resetOverlay());
	}
	hideSourceOrderInOverlay() {
		this.#_r.hideSourceOrderHighlight();
	}
	setSourceOrderActive(e) {
		this.#zr = e;
	}
	sourceOrderModeActive() {
		return this.#zr;
	}
	highlightIsolatedElementInPersistentOverlay(e) {
		this.#qr && this.#qr.highlightIsolatedElementInOverlay(e);
	}
	hideIsolatedElementInPersistentOverlay(e) {
		this.#qr && this.#qr.hideIsolatedElementInOverlay(e);
	}
	isHighlightedIsolatedElementInPersistentOverlay(e) {
		return !!this.#qr && this.#qr.isIsolatedElementHighlighted(e);
	}
	delayedHideHighlight(e) {
		null === this.#Mr &&
			(this.#Mr = window.setTimeout(
				() => this.highlightInOverlay({ clear: !0 }),
				e
			));
	}
	highlightFrame(e) {
		(this.#Mr && (clearTimeout(this.#Mr), (this.#Mr = null)),
			this.#Lr.highlightFrame(e));
	}
	showHingeForDualScreen(e) {
		if (e) {
			const {
				x: t,
				y: n,
				width: r,
				height: s,
				contentColor: i,
				outlineColor: a,
			} = e;
			this.overlayAgent.invoke_setShowHinge({
				hingeConfig: {
					rect: { x: t, y: n, width: r, height: s },
					contentColor: i,
					outlineColor: a,
				},
			});
		} else this.overlayAgent.invoke_setShowHinge({});
	}
	setWindowControlsPlatform(e) {
		this.#jr.selectedPlatform = e;
	}
	setWindowControlsThemeColor(e) {
		this.#jr.themeColor = e;
	}
	getWindowControlsConfig() {
		return this.#jr.config;
	}
	async toggleWindowControlsToolbar(e) {
		const t = e ? { windowControlsOverlayConfig: this.#jr.config } : {},
			n = this.overlayAgent.invoke_setShowWindowControlsOverlay(t),
			r = this.#jr.toggleEmulatedOverlay(e);
		(await Promise.all([n, r]), this.setShowViewportSizeOnResize(!e));
	}
	buildHighlightConfig(t = "all", n = !1) {
		const r = e.Settings.Settings.instance()
				.moduleSetting("showMetricsRulers")
				.get(),
			s = {
				showInfo: "all" === t || "container-outline" === t,
				showRulers: r,
				showStyles: n,
				showAccessibilityInfo: n,
				showExtensionLines: r,
				gridHighlightConfig: {},
				flexContainerHighlightConfig: {},
				flexItemHighlightConfig: {},
				contrastAlgorithm: a.Runtime.experiments.isEnabled("APCA")
					? "apca"
					: "aa",
			};
		return (
			("all" !== t && "content" !== t) ||
				(s.contentColor = e.Color.PageHighlight.Content.toProtocolRGBA()),
			("all" !== t && "padding" !== t) ||
				(s.paddingColor = e.Color.PageHighlight.Padding.toProtocolRGBA()),
			("all" !== t && "border" !== t) ||
				(s.borderColor = e.Color.PageHighlight.Border.toProtocolRGBA()),
			("all" !== t && "margin" !== t) ||
				(s.marginColor = e.Color.PageHighlight.Margin.toProtocolRGBA()),
			"all" === t &&
				((s.eventTargetColor =
					e.Color.PageHighlight.EventTarget.toProtocolRGBA()),
				(s.shapeColor = e.Color.PageHighlight.Shape.toProtocolRGBA()),
				(s.shapeMarginColor =
					e.Color.PageHighlight.ShapeMargin.toProtocolRGBA()),
				(s.gridHighlightConfig = {
					rowGapColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					rowHatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
					columnGapColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					columnHatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
					rowLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					columnLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					rowLineDash: !0,
					columnLineDash: !0,
				}),
				(s.flexContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					itemSeparator: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dotted",
					},
					lineSeparator: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					mainDistributedSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
					crossDistributedSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
					rowGapSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
					columnGapSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
				}),
				(s.flexItemHighlightConfig = {
					baseSizeBox: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
					},
					baseSizeBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dotted",
					},
					flexibilityArrow: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					},
				})),
			t.endsWith("gap") &&
				((s.gridHighlightConfig = {
					gridBorderColor: e.Color.PageHighlight.GridBorder.toProtocolRGBA(),
					gridBorderDash: !0,
				}),
				("gap" !== t && "row-gap" !== t) ||
					((s.gridHighlightConfig.rowGapColor =
						e.Color.PageHighlight.GapBackground.toProtocolRGBA()),
					(s.gridHighlightConfig.rowHatchColor =
						e.Color.PageHighlight.GapHatch.toProtocolRGBA())),
				("gap" !== t && "column-gap" !== t) ||
					((s.gridHighlightConfig.columnGapColor =
						e.Color.PageHighlight.GapBackground.toProtocolRGBA()),
					(s.gridHighlightConfig.columnHatchColor =
						e.Color.PageHighlight.GapHatch.toProtocolRGBA()))),
			t.endsWith("gap") &&
				((s.flexContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
				}),
				("gap" !== t && "row-gap" !== t) ||
					(s.flexContainerHighlightConfig.rowGapSpace = {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					}),
				("gap" !== t && "column-gap" !== t) ||
					(s.flexContainerHighlightConfig.columnGapSpace = {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					})),
			"grid-areas" === t &&
				(s.gridHighlightConfig = {
					rowLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					columnLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					rowLineDash: !0,
					columnLineDash: !0,
					showAreaNames: !0,
					areaBorderColor:
						e.Color.PageHighlight.GridAreaBorder.toProtocolRGBA(),
				}),
			"grid-template-columns" === t &&
				((s.contentColor = e.Color.PageHighlight.Content.toProtocolRGBA()),
				(s.gridHighlightConfig = {
					columnLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					columnLineDash: !0,
				})),
			"grid-template-rows" === t &&
				((s.contentColor = e.Color.PageHighlight.Content.toProtocolRGBA()),
				(s.gridHighlightConfig = {
					rowLineColor: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					rowLineDash: !0,
				})),
			"justify-content" === t &&
				(s.flexContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					mainDistributedSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
				}),
			"align-content" === t &&
				(s.flexContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					crossDistributedSpace: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
						fillColor: e.Color.PageHighlight.GapBackground.toProtocolRGBA(),
					},
				}),
			"align-items" === t &&
				(s.flexContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					lineSeparator: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
					crossAlignment: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					},
				}),
			"flexibility" === t &&
				(s.flexItemHighlightConfig = {
					baseSizeBox: {
						hatchColor: e.Color.PageHighlight.GapHatch.toProtocolRGBA(),
					},
					baseSizeBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dotted",
					},
					flexibilityArrow: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
					},
				}),
			"container-outline" === t &&
				(s.containerQueryContainerHighlightConfig = {
					containerBorder: {
						color: e.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
						pattern: "dashed",
					},
				}),
			s
		);
	}
	nodeHighlightRequested({ nodeId: e }) {
		const t = this.#an.nodeForId(e);
		t && this.dispatchEventToListeners(ar.HighlightNodeRequested, t);
	}
	static setInspectNodeHandler(e) {
		sr.inspectNodeHandler = e;
	}
	inspectNodeRequested({ backendNodeId: t }) {
		const n = new ur(this.target(), t);
		(sr.inspectNodeHandler
			? n.resolvePromise().then((e) => {
					e && sr.inspectNodeHandler && sr.inspectNodeHandler(e);
				})
			: e.Revealer.reveal(n),
			this.dispatchEventToListeners(ar.ExitedInspectMode));
	}
	screenshotRequested({ viewport: e }) {
		(this.dispatchEventToListeners(ar.ScreenshotRequested, e),
			this.dispatchEventToListeners(ar.ExitedInspectMode));
	}
	inspectModeCanceled() {
		this.dispatchEventToListeners(ar.ExitedInspectMode);
	}
	static inspectNodeHandler = null;
	getOverlayAgent() {
		return this.overlayAgent;
	}
	async hasStyleSheetText(e) {
		return this.#jr.initializeStyleSheetText(e);
	}
}
class ir {
	#ee;
	#Wr;
	#Vr;
	#Gr;
	#Kr = { showCSS: !1, selectedPlatform: "Windows", themeColor: "#ffffff" };
	constructor(e) {
		this.#ee = e;
	}
	get selectedPlatform() {
		return this.#Kr.selectedPlatform;
	}
	set selectedPlatform(e) {
		this.#Kr.selectedPlatform = e;
	}
	get themeColor() {
		return this.#Kr.themeColor;
	}
	set themeColor(e) {
		this.#Kr.themeColor = e;
	}
	get config() {
		return this.#Kr;
	}
	async initializeStyleSheetText(e) {
		if (this.#Wr && e === this.#Gr) return !0;
		const t = this.#Qr(e);
		if (!t) return !1;
		if (((this.#Vr = this.#$r(t)), !this.#Vr)) return !1;
		const n = await this.#ee.getStyleSheetText(this.#Vr);
		return !!n && ((this.#Wr = n), (this.#Gr = e), !0);
	}
	async toggleEmulatedOverlay(e) {
		if (this.#Vr && this.#Wr)
			if (e) {
				const e = ir.#Xr(this.#Kr.selectedPlatform.toLowerCase(), this.#Wr);
				e && (await this.#ee.setStyleSheetText(this.#Vr, e, !1));
			} else await this.#ee.setStyleSheetText(this.#Vr, this.#Wr, !1);
	}
	static #Xr(e, t) {
		const n = rr[e];
		return ir.#Jr(n.x, n.y, n.width, n.height, t);
	}
	#Qr(t) {
		const n = e.ParsedURL.ParsedURL.extractOrigin(t),
			r = this.#ee
				.styleSheetHeaders()
				.find((e) => e.sourceURL && e.sourceURL.includes(n));
		return r?.sourceURL;
	}
	#$r(e) {
		const t = this.#ee.getStyleSheetIdsForURL(e);
		return t.length > 0 ? t[0] : void 0;
	}
	static #Jr(e, t, n, r, s) {
		if (!s) return;
		return s
			.replace(
				/: env\(titlebar-area-x(?:,[^)]*)?\);/g,
				`: env(titlebar-area-x, ${e}px);`
			)
			.replace(
				/: env\(titlebar-area-y(?:,[^)]*)?\);/g,
				`: env(titlebar-area-y, ${t}px);`
			)
			.replace(
				/: env\(titlebar-area-width(?:,[^)]*)?\);/g,
				`: env(titlebar-area-width, calc(100% - ${n}px));`
			)
			.replace(
				/: env\(titlebar-area-height(?:,[^)]*)?\);/g,
				`: env(titlebar-area-height, ${r}px);`
			);
	}
	transformStyleSheetforTesting(e, t, n, r, s) {
		return ir.#Jr(e, t, n, r, s);
	}
}
var ar;
!(function (e) {
	((e.InspectModeWillBeToggled = "InspectModeWillBeToggled"),
		(e.ExitedInspectMode = "InspectModeExited"),
		(e.HighlightNodeRequested = "HighlightNodeRequested"),
		(e.ScreenshotRequested = "ScreenshotRequested"),
		(e.PersistentGridOverlayStateChanged = "PersistentGridOverlayStateChanged"),
		(e.PersistentFlexContainerOverlayStateChanged =
			"PersistentFlexContainerOverlayStateChanged"),
		(e.PersistentScrollSnapOverlayStateChanged =
			"PersistentScrollSnapOverlayStateChanged"),
		(e.PersistentContainerQueryOverlayStateChanged =
			"PersistentContainerQueryOverlayStateChanged"));
})(ar || (ar = {}));
class or {
	#gr;
	constructor(e) {
		this.#gr = e;
	}
	highlightInOverlay(e, t) {
		const {
				node: n,
				deferredNode: r,
				object: s,
				selectorList: i,
			} = {
				node: void 0,
				deferredNode: void 0,
				object: void 0,
				selectorList: void 0,
				...e,
			},
			a = n ? n.id : void 0,
			o = r ? r.backendNodeId() : void 0,
			l = s ? s.objectId : void 0;
		a || o || l
			? this.#gr
					.target()
					.overlayAgent()
					.invoke_highlightNode({
						highlightConfig: t,
						nodeId: a,
						backendNodeId: o,
						objectId: l,
						selector: i,
					})
			: this.#gr.target().overlayAgent().invoke_hideHighlight();
	}
	async setInspectMode(e, t) {
		await this.#gr
			.target()
			.overlayAgent()
			.invoke_setInspectMode({ mode: e, highlightConfig: t });
	}
	highlightFrame(t) {
		this.#gr
			.target()
			.overlayAgent()
			.invoke_highlightFrame({
				frameId: t,
				contentColor: e.Color.PageHighlight.Content.toProtocolRGBA(),
				contentOutlineColor:
					e.Color.PageHighlight.ContentOutline.toProtocolRGBA(),
			});
	}
}
class lr {
	#gr;
	constructor(e) {
		this.#gr = e;
	}
	highlightSourceOrderInOverlay(e, t) {
		(this.#gr.setSourceOrderActive(!0),
			this.#gr.setShowViewportSizeOnResize(!1),
			this.#gr
				.getOverlayAgent()
				.invoke_highlightSourceOrder({ sourceOrderConfig: t, nodeId: e.id }));
	}
	hideSourceOrderHighlight() {
		(this.#gr.setSourceOrderActive(!1),
			this.#gr.setShowViewportSizeOnResize(!0),
			this.#gr.clearHighlight());
	}
}
c.register(sr, { capabilities: We.DOM, autostart: !0 });
var dr,
	cr = Object.freeze({
		__proto__: null,
		OverlayModel: sr,
		WindowControls: ir,
		get Events() {
			return ar;
		},
		SourceOrderHighlighter: lr,
	});
class hr {
	#Yr;
	#Zr;
	ownerDocument;
	#es;
	id;
	index;
	#ts;
	#ns;
	#rs;
	#ss;
	nodeValueInternal;
	#is;
	#as;
	#os;
	#ls;
	#ds;
	#cs;
	#hs;
	#us;
	#gs;
	assignedSlot;
	shadowRootsInternal;
	#ps;
	#ms;
	#fs;
	childNodeCountInternal;
	childrenInternal;
	nextSibling;
	previousSibling;
	firstChild;
	lastChild;
	parentNode;
	templateContentInternal;
	contentDocumentInternal;
	childDocumentPromiseForTesting;
	#bs;
	publicId;
	systemId;
	internalSubset;
	name;
	value;
	constructor(e) {
		((this.#Yr = e),
			(this.#Zr = this.#Yr.getAgent()),
			(this.index = void 0),
			(this.#hs = null),
			(this.#us = new Map()),
			(this.#gs = []),
			(this.assignedSlot = null),
			(this.shadowRootsInternal = []),
			(this.#ps = new Map()),
			(this.#ms = new Map()),
			(this.#fs = 0),
			(this.childrenInternal = null),
			(this.nextSibling = null),
			(this.previousSibling = null),
			(this.firstChild = null),
			(this.lastChild = null),
			(this.parentNode = null));
	}
	static create(e, t, n, r) {
		const s = new hr(e);
		return (s.init(t, n, r), s);
	}
	init(e, t, n) {
		if (
			((this.#Zr = this.#Yr.getAgent()),
			(this.ownerDocument = e),
			(this.#es = t),
			(this.id = n.nodeId),
			(this.#ts = n.backendNodeId),
			this.#Yr.registerNode(this),
			(this.#ns = n.nodeType),
			(this.#rs = n.nodeName),
			(this.#ss = n.localName),
			(this.nodeValueInternal = n.nodeValue),
			(this.#is = n.pseudoType),
			(this.#as = n.pseudoIdentifier),
			(this.#os = n.shadowRootType),
			(this.#ls = n.frameId || null),
			(this.#ds = n.xmlVersion),
			(this.#cs = Boolean(n.isSVG)),
			n.attributes && this.setAttributesPayload(n.attributes),
			(this.childNodeCountInternal = n.childNodeCount || 0),
			n.shadowRoots)
		)
			for (let e = 0; e < n.shadowRoots.length; ++e) {
				const t = n.shadowRoots[e],
					r = hr.create(this.#Yr, this.ownerDocument, !0, t);
				(this.shadowRootsInternal.push(r), (r.parentNode = this));
			}
		n.templateContent &&
			((this.templateContentInternal = hr.create(
				this.#Yr,
				this.ownerDocument,
				!0,
				n.templateContent
			)),
			(this.templateContentInternal.parentNode = this),
			(this.childrenInternal = []));
		const r = new Set(["EMBED", "IFRAME", "OBJECT", "PORTAL", "FENCEDFRAME"]);
		(n.contentDocument
			? ((this.contentDocumentInternal = new pr(this.#Yr, n.contentDocument)),
				(this.contentDocumentInternal.parentNode = this),
				(this.childrenInternal = []))
			: n.frameId &&
				r.has(n.nodeName) &&
				((this.childDocumentPromiseForTesting = this.requestChildDocument(
					n.frameId,
					this.#Yr.target()
				)),
				(this.childrenInternal = [])),
			n.importedDocument &&
				((this.#bs = hr.create(
					this.#Yr,
					this.ownerDocument,
					!0,
					n.importedDocument
				)),
				(this.#bs.parentNode = this),
				(this.childrenInternal = [])),
			n.distributedNodes && this.setDistributedNodePayloads(n.distributedNodes),
			n.assignedSlot && this.setAssignedSlot(n.assignedSlot),
			n.children && this.setChildrenPayload(n.children),
			this.setPseudoElements(n.pseudoElements),
			this.#ns === Node.ELEMENT_NODE
				? (this.ownerDocument &&
						!this.ownerDocument.documentElement &&
						"HTML" === this.#rs &&
						(this.ownerDocument.documentElement = this),
					this.ownerDocument &&
						!this.ownerDocument.body &&
						"BODY" === this.#rs &&
						(this.ownerDocument.body = this))
				: this.#ns === Node.DOCUMENT_TYPE_NODE
					? ((this.publicId = n.publicId),
						(this.systemId = n.systemId),
						(this.internalSubset = n.internalSubset))
					: this.#ns === Node.ATTRIBUTE_NODE &&
						((this.name = n.name), (this.value = n.value)));
	}
	async requestChildDocument(e, t) {
		const n = await Ze.instance().getOrWaitForFrame(e, t),
			r = n.resourceTreeModel()?.target().model(mr);
		return r?.requestDocument() || null;
	}
	isAdFrameNode() {
		if (this.isIframe() && this.#ls) {
			const e = Ze.instance().getFrame(this.#ls);
			return !!e && "none" !== e.adFrameType();
		}
		return !1;
	}
	isSVGNode() {
		return this.#cs;
	}
	isMediaNode() {
		return "AUDIO" === this.#rs || "VIDEO" === this.#rs;
	}
	isViewTransitionPseudoNode() {
		return (
			!!this.#is &&
			[
				"view-transition",
				"view-transition-group",
				"view-transition-image-pair",
				"view-transition-old",
				"view-transition-new",
			].includes(this.#is)
		);
	}
	creationStackTrace() {
		if (this.#hs) return this.#hs;
		const e = this.#Zr.invoke_getNodeStackTraces({ nodeId: this.id });
		return ((this.#hs = e.then((e) => e.creation || null)), this.#hs);
	}
	get subtreeMarkerCount() {
		return this.#fs;
	}
	domModel() {
		return this.#Yr;
	}
	backendNodeId() {
		return this.#ts;
	}
	children() {
		return this.childrenInternal ? this.childrenInternal.slice() : null;
	}
	setChildren(e) {
		this.childrenInternal = e;
	}
	hasAttributes() {
		return this.#ps.size > 0;
	}
	childNodeCount() {
		return this.childNodeCountInternal;
	}
	setChildNodeCount(e) {
		this.childNodeCountInternal = e;
	}
	hasShadowRoots() {
		return Boolean(this.shadowRootsInternal.length);
	}
	shadowRoots() {
		return this.shadowRootsInternal.slice();
	}
	templateContent() {
		return this.templateContentInternal || null;
	}
	contentDocument() {
		return this.contentDocumentInternal || null;
	}
	setContentDocument(e) {
		this.contentDocumentInternal = e;
	}
	isIframe() {
		return "IFRAME" === this.#rs;
	}
	isPortal() {
		return "PORTAL" === this.#rs;
	}
	importedDocument() {
		return this.#bs || null;
	}
	nodeType() {
		return this.#ns;
	}
	nodeName() {
		return this.#rs;
	}
	pseudoType() {
		return this.#is;
	}
	pseudoIdentifier() {
		return this.#as;
	}
	hasPseudoElements() {
		return this.#us.size > 0;
	}
	pseudoElements() {
		return this.#us;
	}
	beforePseudoElement() {
		return this.#us.get("before")?.at(-1);
	}
	afterPseudoElement() {
		return this.#us.get("after")?.at(-1);
	}
	markerPseudoElement() {
		return this.#us.get("marker")?.at(-1);
	}
	backdropPseudoElement() {
		return this.#us.get("backdrop")?.at(-1);
	}
	viewTransitionPseudoElements() {
		return [
			...(this.#us.get("view-transition") || []),
			...(this.#us.get("view-transition-group") || []),
			...(this.#us.get("view-transition-image-pair") || []),
			...(this.#us.get("view-transition-old") || []),
			...(this.#us.get("view-transition-new") || []),
		];
	}
	hasAssignedSlot() {
		return null !== this.assignedSlot;
	}
	isInsertionPoint() {
		return (
			!this.isXMLNode() &&
			("SHADOW" === this.#rs || "CONTENT" === this.#rs || "SLOT" === this.#rs)
		);
	}
	distributedNodes() {
		return this.#gs;
	}
	isInShadowTree() {
		return this.#es;
	}
	ancestorShadowHost() {
		const e = this.ancestorShadowRoot();
		return e ? e.parentNode : null;
	}
	ancestorShadowRoot() {
		if (!this.#es) return null;
		let e = this;
		for (; e && !e.isShadowRoot(); ) e = e.parentNode;
		return e;
	}
	ancestorUserAgentShadowRoot() {
		const e = this.ancestorShadowRoot();
		return e && e.shadowRootType() === hr.ShadowRootTypes.UserAgent ? e : null;
	}
	isShadowRoot() {
		return Boolean(this.#os);
	}
	shadowRootType() {
		return this.#os || null;
	}
	nodeNameInCorrectCase() {
		const e = this.shadowRootType();
		return e
			? "#shadow-root (" + e + ")"
			: this.localName()
				? this.localName().length !== this.nodeName().length
					? this.nodeName()
					: this.localName()
				: this.nodeName();
	}
	setNodeName(e, t) {
		this.#Zr.invoke_setNodeName({ nodeId: this.id, name: e }).then((e) => {
			(e.getError() || this.#Yr.markUndoableState(),
				t && t(e.getError() || null, this.#Yr.nodeForId(e.nodeId)));
		});
	}
	localName() {
		return this.#ss;
	}
	nodeValue() {
		return this.nodeValueInternal;
	}
	setNodeValueInternal(e) {
		this.nodeValueInternal = e;
	}
	setNodeValue(e, t) {
		this.#Zr.invoke_setNodeValue({ nodeId: this.id, value: e }).then((e) => {
			(e.getError() || this.#Yr.markUndoableState(),
				t && t(e.getError() || null));
		});
	}
	getAttribute(e) {
		const t = this.#ps.get(e);
		return t ? t.value : void 0;
	}
	setAttribute(e, t, n) {
		this.#Zr
			.invoke_setAttributesAsText({ nodeId: this.id, text: t, name: e })
			.then((e) => {
				(e.getError() || this.#Yr.markUndoableState(),
					n && n(e.getError() || null));
			});
	}
	setAttributeValue(e, t, n) {
		this.#Zr
			.invoke_setAttributeValue({ nodeId: this.id, name: e, value: t })
			.then((e) => {
				(e.getError() || this.#Yr.markUndoableState(),
					n && n(e.getError() || null));
			});
	}
	setAttributeValuePromise(e, t) {
		return new Promise((n) => this.setAttributeValue(e, t, n));
	}
	attributes() {
		return [...this.#ps.values()];
	}
	async removeAttribute(e) {
		(
			await this.#Zr.invoke_removeAttribute({ nodeId: this.id, name: e })
		).getError() || (this.#ps.delete(e), this.#Yr.markUndoableState());
	}
	getChildNodes(e) {
		this.childrenInternal
			? e(this.children())
			: this.#Zr.invoke_requestChildNodes({ nodeId: this.id }).then((t) => {
					e(t.getError() ? null : this.children());
				});
	}
	async getSubtree(e, t) {
		return (
			await this.#Zr.invoke_requestChildNodes({
				nodeId: this.id,
				depth: e,
				pierce: t,
			})
		).getError()
			? null
			: this.childrenInternal;
	}
	async getOuterHTML() {
		const { outerHTML: e } = await this.#Zr.invoke_getOuterHTML({
			nodeId: this.id,
		});
		return e;
	}
	setOuterHTML(e, t) {
		this.#Zr
			.invoke_setOuterHTML({ nodeId: this.id, outerHTML: e })
			.then((e) => {
				(e.getError() || this.#Yr.markUndoableState(),
					t && t(e.getError() || null));
			});
	}
	removeNode(e) {
		return this.#Zr.invoke_removeNode({ nodeId: this.id }).then((t) => {
			(t.getError() || this.#Yr.markUndoableState(),
				e && e(t.getError() || null));
		});
	}
	async copyNode() {
		const { outerHTML: e } = await this.#Zr.invoke_getOuterHTML({
			nodeId: this.id,
		});
		return (
			null !== e &&
				o.InspectorFrontendHost.InspectorFrontendHostInstance.copyText(e),
			e
		);
	}
	path() {
		function e(e) {
			return (
				(void 0 !== e.index || (e.isShadowRoot() && e.parentNode)) &&
				e.#rs.length
			);
		}
		const t = [];
		let n = this;
		for (; n && e(n); ) {
			const e =
				"number" == typeof n.index
					? n.index
					: n.shadowRootType() === hr.ShadowRootTypes.UserAgent
						? "u"
						: "a";
			(t.push([e, n.#rs]), (n = n.parentNode));
		}
		return (t.reverse(), t.join(","));
	}
	isAncestor(e) {
		if (!e) return !1;
		let t = e.parentNode;
		for (; t; ) {
			if (this === t) return !0;
			t = t.parentNode;
		}
		return !1;
	}
	isDescendant(e) {
		return null !== e && e.isAncestor(this);
	}
	frameOwnerFrameId() {
		return this.#ls;
	}
	frameId() {
		let e = this.parentNode || this;
		for (; !e.#ls && e.parentNode; ) e = e.parentNode;
		return e.#ls;
	}
	setAttributesPayload(e) {
		let t = !this.#ps || e.length !== 2 * this.#ps.size;
		const n = this.#ps || new Map();
		this.#ps = new Map();
		for (let r = 0; r < e.length; r += 2) {
			const s = e[r],
				i = e[r + 1];
			if ((this.addAttribute(s, i), t)) continue;
			const a = n.get(s);
			(a && a.value === i) || (t = !0);
		}
		return t;
	}
	insertChild(e, t) {
		if (!this.childrenInternal)
			throw new Error("DOMNode._children is expected to not be null.");
		const n = hr.create(this.#Yr, this.ownerDocument, this.#es, t);
		return (
			this.childrenInternal.splice(
				e ? this.childrenInternal.indexOf(e) + 1 : 0,
				0,
				n
			),
			this.renumber(),
			n
		);
	}
	removeChild(e) {
		const t = e.pseudoType();
		if (t) {
			const n = this.#us.get(t)?.filter((t) => t !== e);
			n && n.length > 0 ? this.#us.set(t, n) : this.#us.delete(t);
		} else {
			const t = this.shadowRootsInternal.indexOf(e);
			if (-1 !== t) this.shadowRootsInternal.splice(t, 1);
			else {
				if (!this.childrenInternal)
					throw new Error("DOMNode._children is expected to not be null.");
				if (-1 === this.childrenInternal.indexOf(e))
					throw new Error(
						"DOMNode._children is expected to contain the node to be removed."
					);
				this.childrenInternal.splice(this.childrenInternal.indexOf(e), 1);
			}
		}
		((e.parentNode = null),
			(this.#fs -= e.#fs),
			e.#fs && this.#Yr.dispatchEventToListeners(dr.MarkersChanged, this),
			this.renumber());
	}
	setChildrenPayload(e) {
		this.childrenInternal = [];
		for (let t = 0; t < e.length; ++t) {
			const n = e[t],
				r = hr.create(this.#Yr, this.ownerDocument, this.#es, n);
			this.childrenInternal.push(r);
		}
		this.renumber();
	}
	setPseudoElements(e) {
		if (e)
			for (let t = 0; t < e.length; ++t) {
				const n = hr.create(this.#Yr, this.ownerDocument, this.#es, e[t]);
				n.parentNode = this;
				const r = n.pseudoType();
				if (!r)
					throw new Error("DOMNode.pseudoType() is expected to be defined.");
				const s = this.#us.get(r);
				s ? s.push(n) : this.#us.set(r, [n]);
			}
	}
	setDistributedNodePayloads(e) {
		this.#gs = [];
		for (const t of e)
			this.#gs.push(
				new gr(this.#Yr.target(), t.backendNodeId, t.nodeType, t.nodeName)
			);
	}
	setAssignedSlot(e) {
		this.assignedSlot = new gr(
			this.#Yr.target(),
			e.backendNodeId,
			e.nodeType,
			e.nodeName
		);
	}
	renumber() {
		if (!this.childrenInternal)
			throw new Error("DOMNode._children is expected to not be null.");
		if (
			((this.childNodeCountInternal = this.childrenInternal.length),
			0 === this.childNodeCountInternal)
		)
			return ((this.firstChild = null), void (this.lastChild = null));
		((this.firstChild = this.childrenInternal[0]),
			(this.lastChild =
				this.childrenInternal[this.childNodeCountInternal - 1]));
		for (let e = 0; e < this.childNodeCountInternal; ++e) {
			const t = this.childrenInternal[e];
			((t.index = e),
				(t.nextSibling =
					e + 1 < this.childNodeCountInternal
						? this.childrenInternal[e + 1]
						: null),
				(t.previousSibling = e - 1 >= 0 ? this.childrenInternal[e - 1] : null),
				(t.parentNode = this));
		}
	}
	addAttribute(e, t) {
		const n = { name: e, value: t, _node: this };
		this.#ps.set(e, n);
	}
	setAttributeInternal(e, t) {
		const n = this.#ps.get(e);
		n ? (n.value = t) : this.addAttribute(e, t);
	}
	removeAttributeInternal(e) {
		this.#ps.delete(e);
	}
	copyTo(e, t, n) {
		this.#Zr
			.invoke_copyTo({
				nodeId: this.id,
				targetNodeId: e.id,
				insertBeforeNodeId: t ? t.id : void 0,
			})
			.then((e) => {
				(e.getError() || this.#Yr.markUndoableState(),
					n && n(e.getError() || null, this.#Yr.nodeForId(e.nodeId)));
			});
	}
	moveTo(e, t, n) {
		this.#Zr
			.invoke_moveTo({
				nodeId: this.id,
				targetNodeId: e.id,
				insertBeforeNodeId: t ? t.id : void 0,
			})
			.then((e) => {
				(e.getError() || this.#Yr.markUndoableState(),
					n && n(e.getError() || null, this.#Yr.nodeForId(e.nodeId)));
			});
	}
	isXMLNode() {
		return Boolean(this.#ds);
	}
	setMarker(e, t) {
		if (null !== t) {
			if (this.parentNode && !this.#ms.has(e))
				for (let e = this; e; e = e.parentNode) ++e.#fs;
			this.#ms.set(e, t);
			for (let e = this; e; e = e.parentNode)
				this.#Yr.dispatchEventToListeners(dr.MarkersChanged, e);
		} else {
			if (!this.#ms.has(e)) return;
			this.#ms.delete(e);
			for (let e = this; e; e = e.parentNode) --e.#fs;
			for (let e = this; e; e = e.parentNode)
				this.#Yr.dispatchEventToListeners(dr.MarkersChanged, e);
		}
	}
	marker(e) {
		return this.#ms.get(e) || null;
	}
	getMarkerKeysForTest() {
		return [...this.#ms.keys()];
	}
	traverseMarkers(e) {
		!(function t(n) {
			if (n.#fs) {
				for (const t of n.#ms.keys()) e(n, t);
				if (n.childrenInternal) for (const e of n.childrenInternal) t(e);
			}
		})(this);
	}
	resolveURL(t) {
		if (!t) return t;
		for (let n = this; n; n = n.parentNode)
			if (n instanceof pr && n.baseURL)
				return e.ParsedURL.ParsedURL.completeURL(n.baseURL, t);
		return null;
	}
	highlight(e) {
		this.#Yr
			.overlayModel()
			.highlightInOverlay({ node: this, selectorList: void 0 }, e);
	}
	highlightForTwoSeconds() {
		this.#Yr
			.overlayModel()
			.highlightInOverlayForTwoSeconds({ node: this, selectorList: void 0 });
	}
	async resolveToObject(e) {
		const { object: t } = await this.#Zr.invoke_resolveNode({
			nodeId: this.id,
			backendNodeId: void 0,
			objectGroup: e,
		});
		return (t && this.#Yr.runtimeModelInternal.createRemoteObject(t)) || null;
	}
	async boxModel() {
		const { model: e } = await this.#Zr.invoke_getBoxModel({ nodeId: this.id });
		return e;
	}
	async setAsInspectedNode() {
		let e = this;
		for (e && e.pseudoType() && (e = e.parentNode); e; ) {
			let t = e.ancestorUserAgentShadowRoot();
			if (!t) break;
			if (((t = e.ancestorShadowHost()), !t)) break;
			e = t;
		}
		if (!e)
			throw new Error(
				"In DOMNode.setAsInspectedNode: node is expected to not be null."
			);
		await this.#Zr.invoke_setInspectedNode({ nodeId: e.id });
	}
	enclosingElementOrSelf() {
		let e = this;
		return (
			e &&
				e.nodeType() === Node.TEXT_NODE &&
				e.parentNode &&
				(e = e.parentNode),
			e && e.nodeType() !== Node.ELEMENT_NODE && (e = null),
			e
		);
	}
	async scrollIntoView() {
		const e = this.enclosingElementOrSelf();
		if (!e) return;
		const t = await e.resolveToObject();
		t &&
			(t.callFunction(function () {
				this.scrollIntoViewIfNeeded(!0);
			}),
			t.release(),
			e.highlightForTwoSeconds());
	}
	async focus() {
		const e = this.enclosingElementOrSelf();
		if (!e) throw new Error("DOMNode.focus expects node to not be null.");
		const t = await e.resolveToObject();
		t &&
			(await t.callFunction(function () {
				this.focus();
			}),
			t.release(),
			e.highlightForTwoSeconds(),
			await this.#Yr.target().pageAgent().invoke_bringToFront());
	}
	simpleSelector() {
		const e = this.localName() || this.nodeName().toLowerCase();
		if (this.nodeType() !== Node.ELEMENT_NODE) return e;
		const t = this.getAttribute("type"),
			n = this.getAttribute("id"),
			r = this.getAttribute("class");
		if ("input" === e && t && !n && !r)
			return e + '[type="' + CSS.escape(t) + '"]';
		if (n) return e + "#" + CSS.escape(n);
		if (r) {
			return (
				("div" === e ? "" : e) +
				"." +
				r
					.trim()
					.split(/\s+/g)
					.map((e) => CSS.escape(e))
					.join(".")
			);
		}
		return this.pseudoIdentifier() ? `${e}(${this.pseudoIdentifier()})` : e;
	}
}
!(function (e) {
	let t;
	!(function (e) {
		((e.UserAgent = "user-agent"), (e.Open = "open"), (e.Closed = "closed"));
	})((t = e.ShadowRootTypes || (e.ShadowRootTypes = {})));
})(hr || (hr = {}));
class ur {
	#Yr;
	#ts;
	constructor(e, t) {
		((this.#Yr = e.model(mr)), (this.#ts = t));
	}
	resolve(e) {
		this.resolvePromise().then(e);
	}
	async resolvePromise() {
		const e = await this.#Yr.pushNodesByBackendIdsToFrontend(
			new Set([this.#ts])
		);
		return (e && e.get(this.#ts)) || null;
	}
	backendNodeId() {
		return this.#ts;
	}
	domModel() {
		return this.#Yr;
	}
	highlight() {
		this.#Yr
			.overlayModel()
			.highlightInOverlay({ deferredNode: this, selectorList: void 0 });
	}
}
class gr {
	nodeType;
	nodeName;
	deferredNode;
	constructor(e, t, n, r) {
		((this.nodeType = n),
			(this.nodeName = r),
			(this.deferredNode = new ur(e, t)));
	}
}
class pr extends hr {
	body;
	documentElement;
	documentURL;
	baseURL;
	constructor(e, t) {
		(super(e),
			(this.body = null),
			(this.documentElement = null),
			this.init(this, !1, t),
			(this.documentURL = t.documentURL || ""),
			(this.baseURL = t.baseURL || ""));
	}
}
class mr extends c {
	agent;
	idToDOMNode = new Map();
	#ys;
	#vs;
	runtimeModelInternal;
	#Is;
	#ks;
	#Ss;
	#ws;
	#Cs;
	constructor(e) {
		(super(e),
			(this.agent = e.domAgent()),
			(this.#ys = null),
			(this.#vs = new Set()),
			e.registerDOMDispatcher(new fr(this)),
			(this.runtimeModelInternal = e.model(yn)),
			(this.#ks = null),
			e.suspended() || this.agent.invoke_enable({}),
			a.Runtime.experiments.isEnabled("captureNodeCreationStacks") &&
				this.agent.invoke_setNodeStackTracesEnabled({ enable: !0 }));
	}
	runtimeModel() {
		return this.runtimeModelInternal;
	}
	cssModel() {
		return this.target().model(nn);
	}
	overlayModel() {
		return this.target().model(sr);
	}
	static cancelSearch() {
		for (const e of $e.instance().models(mr)) e.cancelSearch();
	}
	scheduleMutationEvent(e) {
		this.hasEventListeners(dr.DOMMutated) &&
			((this.#Is = (this.#Is || 0) + 1),
			Promise.resolve().then(
				function (e, t) {
					if (!this.hasEventListeners(dr.DOMMutated) || this.#Is !== t) return;
					this.dispatchEventToListeners(dr.DOMMutated, e);
				}.bind(this, e, this.#Is)
			));
	}
	requestDocument() {
		return this.#ys
			? Promise.resolve(this.#ys)
			: (this.#ks || (this.#ks = this.requestDocumentInternal()), this.#ks);
	}
	async getOwnerNodeForFrame(e) {
		const t = await this.agent.invoke_getFrameOwner({ frameId: e });
		return t.getError() ? null : new ur(this.target(), t.backendNodeId);
	}
	async requestDocumentInternal() {
		const e = await this.agent.invoke_getDocument({});
		if (e.getError()) return null;
		const { root: t } = e;
		if (((this.#ks = null), t && this.setDocument(t), !this.#ys))
			return (console.error("No document"), null);
		const n = this.parentModel();
		if (n && !this.#Ss) {
			await n.requestDocument();
			const e = this.target().model(Pr)?.mainFrame;
			if (e) {
				const t = await n.agent.invoke_getFrameOwner({ frameId: e.id });
				!t.getError() && t.nodeId && (this.#Ss = n.nodeForId(t.nodeId));
			}
		}
		if (this.#Ss) {
			const e = this.#Ss.contentDocument();
			(this.#Ss.setContentDocument(this.#ys),
				this.#Ss.setChildren([]),
				this.#ys
					? ((this.#ys.parentNode = this.#Ss),
						this.dispatchEventToListeners(dr.NodeInserted, this.#ys))
					: e &&
						this.dispatchEventToListeners(dr.NodeRemoved, {
							node: e,
							parent: this.#Ss,
						}));
		}
		return this.#ys;
	}
	existingDocument() {
		return this.#ys;
	}
	async pushNodeToFrontend(e) {
		await this.requestDocument();
		const { nodeId: t } = await this.agent.invoke_requestNode({ objectId: e });
		return t ? this.nodeForId(t) : null;
	}
	pushNodeByPathToFrontend(e) {
		return this.requestDocument()
			.then(() => this.agent.invoke_pushNodeByPathToFrontend({ path: e }))
			.then(({ nodeId: e }) => e);
	}
	async pushNodesByBackendIdsToFrontend(e) {
		await this.requestDocument();
		const t = [...e],
			{ nodeIds: n } = await this.agent.invoke_pushNodesByBackendIdsToFrontend({
				backendNodeIds: t,
			});
		if (!n) return null;
		const r = new Map();
		for (let e = 0; e < n.length; ++e)
			n[e] && r.set(t[e], this.nodeForId(n[e]));
		return r;
	}
	attributeModified(e, t, n) {
		const r = this.idToDOMNode.get(e);
		r &&
			(r.setAttributeInternal(t, n),
			this.dispatchEventToListeners(dr.AttrModified, { node: r, name: t }),
			this.scheduleMutationEvent(r));
	}
	attributeRemoved(e, t) {
		const n = this.idToDOMNode.get(e);
		n &&
			(n.removeAttributeInternal(t),
			this.dispatchEventToListeners(dr.AttrRemoved, { node: n, name: t }),
			this.scheduleMutationEvent(n));
	}
	inlineStyleInvalidated(e) {
		(t.SetUtilities.addAll(this.#vs, e),
			this.#ws ||
				(this.#ws = window.setTimeout(this.loadNodeAttributes.bind(this), 20)));
	}
	loadNodeAttributes() {
		this.#ws = void 0;
		for (const e of this.#vs)
			this.agent
				.invoke_getAttributes({ nodeId: e })
				.then(({ attributes: t }) => {
					if (!t) return;
					const n = this.idToDOMNode.get(e);
					n &&
						n.setAttributesPayload(t) &&
						(this.dispatchEventToListeners(dr.AttrModified, {
							node: n,
							name: "style",
						}),
						this.scheduleMutationEvent(n));
				});
		this.#vs.clear();
	}
	characterDataModified(e, t) {
		const n = this.idToDOMNode.get(e);
		n
			? (n.setNodeValueInternal(t),
				this.dispatchEventToListeners(dr.CharacterDataModified, n),
				this.scheduleMutationEvent(n))
			: console.error("nodeId could not be resolved to a node");
	}
	nodeForId(e) {
		return (e && this.idToDOMNode.get(e)) || null;
	}
	documentUpdated() {
		const e = Boolean(this.#ys);
		(this.setDocument(null),
			this.parentModel() && e && !this.#ks && this.requestDocument());
	}
	setDocument(e) {
		((this.idToDOMNode = new Map()),
			(this.#ys = e && "nodeId" in e ? new pr(this, e) : null),
			yr.instance().dispose(this),
			this.parentModel() ||
				this.dispatchEventToListeners(dr.DocumentUpdated, this));
	}
	setDocumentForTest(e) {
		this.setDocument(e);
	}
	setDetachedRoot(e) {
		"#document" === e.nodeName ? new pr(this, e) : hr.create(this, null, !1, e);
	}
	setChildNodes(e, t) {
		if (!e && t.length) return void this.setDetachedRoot(t[0]);
		const n = this.idToDOMNode.get(e);
		n?.setChildrenPayload(t);
	}
	childNodeCountUpdated(e, t) {
		const n = this.idToDOMNode.get(e);
		n
			? (n.setChildNodeCount(t),
				this.dispatchEventToListeners(dr.ChildNodeCountUpdated, n),
				this.scheduleMutationEvent(n))
			: console.error("nodeId could not be resolved to a node");
	}
	childNodeInserted(e, t, n) {
		const r = this.idToDOMNode.get(e),
			s = this.idToDOMNode.get(t);
		if (!r)
			return void console.error("parentId could not be resolved to a node");
		const i = r.insertChild(s, n);
		(this.idToDOMNode.set(i.id, i),
			this.dispatchEventToListeners(dr.NodeInserted, i),
			this.scheduleMutationEvent(i));
	}
	childNodeRemoved(e, t) {
		const n = this.idToDOMNode.get(e),
			r = this.idToDOMNode.get(t);
		n && r
			? (n.removeChild(r),
				this.unbind(r),
				this.dispatchEventToListeners(dr.NodeRemoved, { node: r, parent: n }),
				this.scheduleMutationEvent(r))
			: console.error("parentId or nodeId could not be resolved to a node");
	}
	shadowRootPushed(e, t) {
		const n = this.idToDOMNode.get(e);
		if (!n) return;
		const r = hr.create(this, n.ownerDocument, !0, t);
		((r.parentNode = n),
			this.idToDOMNode.set(r.id, r),
			n.shadowRootsInternal.unshift(r),
			this.dispatchEventToListeners(dr.NodeInserted, r),
			this.scheduleMutationEvent(r));
	}
	shadowRootPopped(e, t) {
		const n = this.idToDOMNode.get(e);
		if (!n) return;
		const r = this.idToDOMNode.get(t);
		r &&
			(n.removeChild(r),
			this.unbind(r),
			this.dispatchEventToListeners(dr.NodeRemoved, { node: r, parent: n }),
			this.scheduleMutationEvent(r));
	}
	pseudoElementAdded(e, t) {
		const n = this.idToDOMNode.get(e);
		if (!n) return;
		const r = hr.create(this, n.ownerDocument, !1, t);
		((r.parentNode = n), this.idToDOMNode.set(r.id, r));
		const s = r.pseudoType();
		if (!s)
			throw new Error(
				"DOMModel._pseudoElementAdded expects pseudoType to be defined."
			);
		const i = n.pseudoElements().get(s);
		(i ? i.push(r) : n.pseudoElements().set(s, [r]),
			this.dispatchEventToListeners(dr.NodeInserted, r),
			this.scheduleMutationEvent(r));
	}
	topLayerElementsUpdated() {
		this.dispatchEventToListeners(dr.TopLayerElementsChanged);
	}
	pseudoElementRemoved(e, t) {
		const n = this.idToDOMNode.get(e);
		if (!n) return;
		const r = this.idToDOMNode.get(t);
		r &&
			(n.removeChild(r),
			this.unbind(r),
			this.dispatchEventToListeners(dr.NodeRemoved, { node: r, parent: n }),
			this.scheduleMutationEvent(r));
	}
	distributedNodesUpdated(e, t) {
		const n = this.idToDOMNode.get(e);
		n &&
			(n.setDistributedNodePayloads(t),
			this.dispatchEventToListeners(dr.DistributedNodesChanged, n),
			this.scheduleMutationEvent(n));
	}
	unbind(e) {
		this.idToDOMNode.delete(e.id);
		const t = e.children();
		for (let e = 0; t && e < t.length; ++e) this.unbind(t[e]);
		for (let t = 0; t < e.shadowRootsInternal.length; ++t)
			this.unbind(e.shadowRootsInternal[t]);
		const n = e.pseudoElements();
		for (const e of n.values()) for (const t of e) this.unbind(t);
		const r = e.templateContent();
		r && this.unbind(r);
	}
	async getNodesByStyle(e, t = !1) {
		if ((await this.requestDocument(), !this.#ys))
			throw new Error("DOMModel.getNodesByStyle expects to have a document.");
		const n = await this.agent.invoke_getNodesForSubtreeByStyle({
			nodeId: this.#ys.id,
			computedStyles: e,
			pierce: t,
		});
		if (n.getError()) throw n.getError();
		return n.nodeIds;
	}
	async performSearch(e, t) {
		const n = await this.agent.invoke_performSearch({
			query: e,
			includeUserAgentShadowDOM: t,
		});
		return (
			n.getError() || (this.#Cs = n.searchId),
			n.getError() ? 0 : n.resultCount
		);
	}
	async searchResult(e) {
		if (!this.#Cs) return null;
		const { nodeIds: t } = await this.agent.invoke_getSearchResults({
			searchId: this.#Cs,
			fromIndex: e,
			toIndex: e + 1,
		});
		return t && 1 === t.length ? this.nodeForId(t[0]) : null;
	}
	cancelSearch() {
		this.#Cs &&
			(this.agent.invoke_discardSearchResults({ searchId: this.#Cs }),
			(this.#Cs = void 0));
	}
	classNamesPromise(e) {
		return this.agent
			.invoke_collectClassNamesFromSubtree({ nodeId: e })
			.then(({ classNames: e }) => e || []);
	}
	querySelector(e, t) {
		return this.agent
			.invoke_querySelector({ nodeId: e, selector: t })
			.then(({ nodeId: e }) => e);
	}
	querySelectorAll(e, t) {
		return this.agent
			.invoke_querySelectorAll({ nodeId: e, selector: t })
			.then(({ nodeIds: e }) => e);
	}
	getTopLayerElements() {
		return this.agent.invoke_getTopLayerElements().then(({ nodeIds: e }) => e);
	}
	markUndoableState(e) {
		yr.instance().markUndoableState(this, e || !1);
	}
	async nodeForLocation(e, t, n) {
		const r = await this.agent.invoke_getNodeForLocation({
			x: e,
			y: t,
			includeUserAgentShadowDOM: n,
		});
		return r.getError() || !r.nodeId ? null : this.nodeForId(r.nodeId);
	}
	async getContainerForNode(e, t, n, r) {
		const { nodeId: s } = await this.agent.invoke_getContainerForNode({
			nodeId: e,
			containerName: t,
			physicalAxes: n,
			logicalAxes: r,
		});
		return s ? this.nodeForId(s) : null;
	}
	pushObjectAsNodeToFrontend(e) {
		return e.isNode() && e.objectId
			? this.pushNodeToFrontend(e.objectId)
			: Promise.resolve(null);
	}
	suspendModel() {
		return this.agent.invoke_disable().then(() => this.setDocument(null));
	}
	async resumeModel() {
		await this.agent.invoke_enable({});
	}
	dispose() {
		yr.instance().dispose(this);
	}
	parentModel() {
		const e = this.target().parentTarget();
		return e ? e.model(mr) : null;
	}
	getAgent() {
		return this.agent;
	}
	registerNode(e) {
		this.idToDOMNode.set(e.id, e);
	}
}
!(function (e) {
	((e.AttrModified = "AttrModified"),
		(e.AttrRemoved = "AttrRemoved"),
		(e.CharacterDataModified = "CharacterDataModified"),
		(e.DOMMutated = "DOMMutated"),
		(e.NodeInserted = "NodeInserted"),
		(e.NodeRemoved = "NodeRemoved"),
		(e.DocumentUpdated = "DocumentUpdated"),
		(e.ChildNodeCountUpdated = "ChildNodeCountUpdated"),
		(e.DistributedNodesChanged = "DistributedNodesChanged"),
		(e.MarkersChanged = "MarkersChanged"),
		(e.TopLayerElementsChanged = "TopLayerElementsChanged"));
})(dr || (dr = {}));
class fr {
	#an;
	constructor(e) {
		this.#an = e;
	}
	documentUpdated() {
		this.#an.documentUpdated();
	}
	attributeModified({ nodeId: e, name: t, value: n }) {
		this.#an.attributeModified(e, t, n);
	}
	attributeRemoved({ nodeId: e, name: t }) {
		this.#an.attributeRemoved(e, t);
	}
	inlineStyleInvalidated({ nodeIds: e }) {
		this.#an.inlineStyleInvalidated(e);
	}
	characterDataModified({ nodeId: e, characterData: t }) {
		this.#an.characterDataModified(e, t);
	}
	setChildNodes({ parentId: e, nodes: t }) {
		this.#an.setChildNodes(e, t);
	}
	childNodeCountUpdated({ nodeId: e, childNodeCount: t }) {
		this.#an.childNodeCountUpdated(e, t);
	}
	childNodeInserted({ parentNodeId: e, previousNodeId: t, node: n }) {
		this.#an.childNodeInserted(e, t, n);
	}
	childNodeRemoved({ parentNodeId: e, nodeId: t }) {
		this.#an.childNodeRemoved(e, t);
	}
	shadowRootPushed({ hostId: e, root: t }) {
		this.#an.shadowRootPushed(e, t);
	}
	shadowRootPopped({ hostId: e, rootId: t }) {
		this.#an.shadowRootPopped(e, t);
	}
	pseudoElementAdded({ parentId: e, pseudoElement: t }) {
		this.#an.pseudoElementAdded(e, t);
	}
	pseudoElementRemoved({ parentId: e, pseudoElementId: t }) {
		this.#an.pseudoElementRemoved(e, t);
	}
	distributedNodesUpdated({ insertionPointId: e, distributedNodes: t }) {
		this.#an.distributedNodesUpdated(e, t);
	}
	topLayerElementsUpdated() {
		this.#an.topLayerElementsUpdated();
	}
}
let br;
class yr {
	#Rs;
	#ur;
	#Ts;
	constructor() {
		((this.#Rs = []), (this.#ur = 0), (this.#Ts = null));
	}
	static instance(e = { forceNew: null }) {
		const { forceNew: t } = e;
		return ((br && !t) || (br = new yr()), br);
	}
	async markUndoableState(e, t) {
		(this.#Ts &&
			e !== this.#Ts &&
			(this.#Ts.markUndoableState(), (this.#Ts = null)),
			(t && this.#Ts === e) ||
				((this.#Rs = this.#Rs.slice(0, this.#ur)),
				this.#Rs.push(e),
				(this.#ur = this.#Rs.length),
				t
					? (this.#Ts = e)
					: (await e.getAgent().invoke_markUndoableState(),
						(this.#Ts = null))));
	}
	async undo() {
		if (0 === this.#ur) return Promise.resolve();
		(--this.#ur,
			(this.#Ts = null),
			await this.#Rs[this.#ur].getAgent().invoke_undo());
	}
	async redo() {
		if (this.#ur >= this.#Rs.length) return Promise.resolve();
		(++this.#ur,
			(this.#Ts = null),
			await this.#Rs[this.#ur - 1].getAgent().invoke_redo());
	}
	dispose(e) {
		let n = 0;
		for (let t = 0; t < this.#ur; ++t) this.#Rs[t] === e && ++n;
		(t.ArrayUtilities.removeElement(this.#Rs, e),
			(this.#ur -= n),
			this.#Ts === e && (this.#Ts = null));
	}
}
c.register(mr, { capabilities: We.DOM, autostart: !0 });
var vr = Object.freeze({
	__proto__: null,
	get DOMNode() {
		return hr;
	},
	DeferredDOMNode: ur,
	DOMNodeShortcut: gr,
	DOMDocument: pr,
	DOMModel: mr,
	get Events() {
		return dr;
	},
	DOMModelUndoStack: yr,
});
class Ir {
	#dn;
	#xs;
	#Ms;
	#Ps;
	#Ls;
	#Es;
	#Os;
	#As;
	#Ns;
	#Ds;
	#Fs;
	#Bs;
	#Us;
	#Hs;
	#qs;
	#_s;
	constructor(n, r, s, i, a, o, l, d, c, h) {
		((this.#dn = n),
			(this.#xs = r),
			(this.url = s),
			(this.#Ps = i),
			(this.#Ls = a),
			(this.#Es = o),
			(this.#Os = l || e.ResourceType.resourceTypes.Other),
			(this.#As = d),
			(this.#Ns = !1),
			(this.#Ds = c && t.DateUtilities.isValid(c) ? c : null),
			(this.#Fs = h),
			(this.#Hs = []),
			this.#xs &&
				!this.#xs.finished &&
				this.#xs.addEventListener(
					Jr.FinishedLoading,
					this.requestFinished,
					this
				));
	}
	lastModified() {
		if (this.#Ds || !this.#xs) return this.#Ds;
		const e = this.#xs.responseLastModified(),
			n = e ? new Date(e) : null;
		return ((this.#Ds = n && t.DateUtilities.isValid(n) ? n : null), this.#Ds);
	}
	contentSize() {
		return "number" != typeof this.#Fs && this.#xs
			? this.#xs.resourceSize
			: this.#Fs;
	}
	get request() {
		return this.#xs;
	}
	get url() {
		return this.#Ms;
	}
	set url(t) {
		((this.#Ms = t), (this.#qs = new e.ParsedURL.ParsedURL(t)));
	}
	get parsedURL() {
		return this.#qs;
	}
	get documentURL() {
		return this.#Ps;
	}
	get frameId() {
		return this.#Ls;
	}
	get loaderId() {
		return this.#Es;
	}
	get displayName() {
		return this.#qs ? this.#qs.displayName : "";
	}
	resourceType() {
		return this.#xs ? this.#xs.resourceType() : this.#Os;
	}
	get mimeType() {
		return this.#xs ? this.#xs.mimeType : this.#As;
	}
	get content() {
		return this.#Bs;
	}
	get isGenerated() {
		return this.#Ns;
	}
	set isGenerated(e) {
		this.#Ns = e;
	}
	contentURL() {
		return this.#Ms;
	}
	contentType() {
		return this.resourceType() === e.ResourceType.resourceTypes.Document &&
			-1 !== this.mimeType.indexOf("javascript")
			? e.ResourceType.resourceTypes.Script
			: this.resourceType();
	}
	async requestContent() {
		return void 0 !== this.#Bs
			? { content: this.#Bs, isEncoded: this.#Us }
			: new Promise((e) => {
					(this.#Hs.push(e),
						(this.#xs && !this.#xs.finished) || this.innerRequestContent());
				});
	}
	canonicalMimeType() {
		return this.contentType().canonicalMimeType() || this.mimeType;
	}
	async searchInContent(e, t, n) {
		if (!this.frameId) return [];
		if (this.request) return this.request.searchInContent(e, t, n);
		const r = await this.#dn
			.target()
			.pageAgent()
			.invoke_searchInResource({
				frameId: this.frameId,
				url: this.url,
				query: e,
				caseSensitive: t,
				isRegex: n,
			});
		return s.TextUtils.performSearchInSearchMatches(r.result || [], e, t, n);
	}
	async populateImageSource(e) {
		const { content: t } = await this.requestContent(),
			n = this.#Us;
		e.src = s.ContentProvider.contentAsDataURL(t, this.#As, n) || this.#Ms;
	}
	requestFinished() {
		(this.#xs &&
			this.#xs.removeEventListener(
				Jr.FinishedLoading,
				this.requestFinished,
				this
			),
			this.#Hs.length && this.innerRequestContent());
	}
	async innerRequestContent() {
		if (this.#_s) return;
		this.#_s = !0;
		let e = null;
		if (this.request) {
			const t = await this.request.contentData();
			if (!D.isError(t)) {
				const { isEncoded: n, content: r } = t.asDeferedContent();
				((this.#Bs = r),
					(this.#Us = n),
					(e = { content: r ?? "", isEncoded: n }));
			}
		}
		if (!e) {
			const t = await this.#dn
					.target()
					.pageAgent()
					.invoke_getResourceContent({ frameId: this.frameId, url: this.url }),
				n = t.getError();
			(n
				? ((this.#Bs = null), (e = { content: null, error: n, isEncoded: !1 }))
				: ((this.#Bs = t.content),
					(e = { content: t.content, isEncoded: t.base64Encoded })),
				(this.#Us = t.base64Encoded));
		}
		null === this.#Bs && (this.#Us = !1);
		for (const t of this.#Hs.splice(0)) t(e);
		this.#_s = void 0;
	}
	hasTextContent() {
		return (
			!!this.#Os.isTextType() ||
			(this.#Os === e.ResourceType.resourceTypes.Other &&
				Boolean(this.#Bs) &&
				!this.#Us)
		);
	}
	frame() {
		return this.#Ls ? this.#dn.frameForId(this.#Ls) : null;
	}
	statusCode() {
		return this.#xs ? this.#xs.statusCode : 0;
	}
}
var kr,
	Sr = Object.freeze({ __proto__: null, Resource: Ir });
class wr extends c {
	#zs;
	#js;
	#Ws;
	constructor(e) {
		(super(e), (this.#zs = ""), (this.#js = ""), (this.#Ws = new Set()));
	}
	updateSecurityOrigins(e) {
		const t = this.#Ws;
		this.#Ws = e;
		for (const e of t)
			this.#Ws.has(e) ||
				this.dispatchEventToListeners(kr.SecurityOriginRemoved, e);
		for (const e of this.#Ws)
			t.has(e) || this.dispatchEventToListeners(kr.SecurityOriginAdded, e);
	}
	securityOrigins() {
		return [...this.#Ws];
	}
	mainSecurityOrigin() {
		return this.#zs;
	}
	unreachableMainSecurityOrigin() {
		return this.#js;
	}
	setMainSecurityOrigin(e, t) {
		((this.#zs = e),
			(this.#js = t || null),
			this.dispatchEventToListeners(kr.MainSecurityOriginChanged, {
				mainSecurityOrigin: this.#zs,
				unreachableMainSecurityOrigin: this.#js,
			}));
	}
}
(!(function (e) {
	((e.SecurityOriginAdded = "SecurityOriginAdded"),
		(e.SecurityOriginRemoved = "SecurityOriginRemoved"),
		(e.MainSecurityOriginChanged = "MainSecurityOriginChanged"));
})(kr || (kr = {})),
	c.register(wr, { capabilities: We.None, autostart: !1 }));
var Cr,
	Rr = Object.freeze({
		__proto__: null,
		SecurityOriginManager: wr,
		get Events() {
			return kr;
		},
	});
class Tr extends c {
	#Vs;
	#Gs;
	constructor(e) {
		(super(e), (this.#Vs = ""), (this.#Gs = new Set()));
	}
	updateStorageKeys(e) {
		const t = this.#Gs;
		this.#Gs = e;
		for (const e of t)
			this.#Gs.has(e) || this.dispatchEventToListeners(Cr.StorageKeyRemoved, e);
		for (const e of this.#Gs)
			t.has(e) || this.dispatchEventToListeners(Cr.StorageKeyAdded, e);
	}
	storageKeys() {
		return [...this.#Gs];
	}
	mainStorageKey() {
		return this.#Vs;
	}
	setMainStorageKey(e) {
		((this.#Vs = e),
			this.dispatchEventToListeners(Cr.MainStorageKeyChanged, {
				mainStorageKey: this.#Vs,
			}));
	}
}
(!(function (e) {
	((e.StorageKeyAdded = "StorageKeyAdded"),
		(e.StorageKeyRemoved = "StorageKeyRemoved"),
		(e.MainStorageKeyChanged = "MainStorageKeyChanged"));
})(Cr || (Cr = {})),
	c.register(Tr, { capabilities: We.None, autostart: !1 }));
var xr,
	Mr = Object.freeze({
		__proto__: null,
		StorageKeyManager: Tr,
		parseStorageKey: function (t) {
			const n = t.split("^"),
				r = {
					origin: e.ParsedURL.ParsedURL.extractOrigin(n[0]),
					components: new Map(),
				};
			for (let e = 1; e < n.length; ++e)
				r.components.set(n[e].charAt(0), n[e].substring(1));
			return r;
		},
		get Events() {
			return Cr;
		},
	});
class Pr extends c {
	agent;
	storageAgent;
	#Ks;
	#Qs;
	framesInternal;
	#$s;
	#Xs;
	#Js;
	isInterstitialShowing;
	mainFrame;
	#Ys;
	constructor(e) {
		super(e);
		const t = e.model(kt);
		(t &&
			(t.addEventListener(St.RequestFinished, this.onRequestFinished, this),
			t.addEventListener(
				St.RequestUpdateDropped,
				this.onRequestUpdateDropped,
				this
			)),
			(this.agent = e.pageAgent()),
			(this.storageAgent = e.storageAgent()),
			this.agent.invoke_enable(),
			(this.#Ks = e.model(wr)),
			(this.#Qs = e.model(Tr)),
			(this.#Ys = new Set()),
			e.registerPageDispatcher(new Er(this)),
			(this.framesInternal = new Map()),
			(this.#$s = !1),
			(this.#Xs = null),
			(this.#Js = 0),
			(this.isInterstitialShowing = !1),
			(this.mainFrame = null),
			this.#Zs());
	}
	async #Zs() {
		return this.agent.invoke_getResourceTree().then((e) => {
			(this.processCachedResources(e.getError() ? null : e.frameTree),
				this.mainFrame && this.processPendingEvents(this.mainFrame));
		});
	}
	static frameForRequest(e) {
		const t = kt.forRequest(e),
			n = t ? t.target().model(Pr) : null;
		return n && e.frameId ? n.frameForId(e.frameId) : null;
	}
	static frames() {
		const e = [];
		for (const t of $e.instance().models(Pr)) e.push(...t.frames());
		return e;
	}
	static resourceForURL(e) {
		for (const t of $e.instance().models(Pr)) {
			const n = t.mainFrame,
				r = n ? n.resourceForURL(e) : null;
			if (r) return r;
		}
		return null;
	}
	static reloadAllPages(e, t) {
		for (const n of $e.instance().models(Pr))
			n.target().parentTarget()?.type() !== je.Frame && n.reloadPage(e, t);
	}
	async storageKeyForFrame(e) {
		if (!this.framesInternal.has(e)) return null;
		const t = await this.storageAgent.invoke_getStorageKeyForFrame({
			frameId: e,
		});
		return "Frame tree node for given frame not found" === t.getError()
			? null
			: t.storageKey;
	}
	domModel() {
		return this.target().model(mr);
	}
	processCachedResources(e) {
		(e &&
			":" !== e.frame.url &&
			(this.dispatchEventToListeners(xr.WillLoadCachedResources),
			this.addFramesRecursively(null, e),
			this.target().setInspectedURL(e.frame.url)),
			(this.#$s = !0));
		const t = this.target().model(yn);
		(t &&
			(t.setExecutionContextComparator(
				this.executionContextComparator.bind(this)
			),
			t.fireExecutionContextOrderChanged()),
			this.dispatchEventToListeners(xr.CachedResourcesLoaded, this));
	}
	cachedResourcesLoaded() {
		return this.#$s;
	}
	addFrame(e, t) {
		(this.framesInternal.set(e.id, e),
			e.isMainFrame() && (this.mainFrame = e),
			this.dispatchEventToListeners(xr.FrameAdded, e),
			this.updateSecurityOrigins(),
			this.updateStorageKeys());
	}
	frameAttached(e, t, n) {
		const r = (t && this.framesInternal.get(t)) || null;
		if (!this.#$s && r) return null;
		if (this.framesInternal.has(e)) return null;
		const s = new Lr(this, r, e, null, n || null);
		return (
			t && !r && (s.crossTargetParentFrameId = t),
			s.isMainFrame() &&
				this.mainFrame &&
				this.frameDetached(this.mainFrame.id, !1),
			this.addFrame(s, !0),
			s
		);
	}
	frameNavigated(e, t) {
		const n = (e.parentId && this.framesInternal.get(e.parentId)) || null;
		if (!this.#$s && n) return;
		let r = this.framesInternal.get(e.id) || null;
		if (
			!r &&
			((r = this.frameAttached(e.id, e.parentId || null)),
			console.assert(Boolean(r)),
			!r)
		)
			return;
		(this.dispatchEventToListeners(xr.FrameWillNavigate, r),
			r.navigate(e),
			t &&
				(r.backForwardCacheDetails.restoredFromCache =
					"BackForwardCacheRestore" === t),
			r.isMainFrame() && this.target().setInspectedURL(r.url),
			this.dispatchEventToListeners(xr.FrameNavigated, r),
			r.isPrimaryFrame() && this.primaryPageChanged(r, "Navigation"));
		const s = r.resources();
		for (let e = 0; e < s.length; ++e)
			this.dispatchEventToListeners(xr.ResourceAdded, s[e]);
		(this.updateSecurityOrigins(),
			this.updateStorageKeys(),
			r.backForwardCacheDetails.restoredFromCache &&
				(Ze.instance().modelRemoved(this),
				Ze.instance().modelAdded(this),
				this.#Zs()));
	}
	primaryPageChanged(e, t) {
		(this.processPendingEvents(e),
			this.dispatchEventToListeners(xr.PrimaryPageChanged, {
				frame: e,
				type: t,
			}));
		const n = this.target().model(kt);
		n && e.isOutermostFrame() && n.clearRequests();
	}
	documentOpened(t) {
		this.frameNavigated(t, void 0);
		const n = this.framesInternal.get(t.id);
		if (n && !n.getResourcesMap().get(t.url)) {
			const r = this.createResourceFromFramePayload(
				t,
				t.url,
				e.ResourceType.resourceTypes.Document,
				t.mimeType,
				null,
				null
			);
			((r.isGenerated = !0), n.addResource(r));
		}
	}
	frameDetached(e, t) {
		if (!this.#$s) return;
		const n = this.framesInternal.get(e);
		if (!n) return;
		const r = n.sameTargetParentFrame();
		(r ? r.removeChildFrame(n, t) : n.remove(t),
			this.updateSecurityOrigins(),
			this.updateStorageKeys());
	}
	onRequestFinished(e) {
		if (!this.#$s) return;
		const t = e.data;
		if (t.failed) return;
		const n = t.frameId ? this.framesInternal.get(t.frameId) : null;
		n && n.addRequest(t);
	}
	onRequestUpdateDropped(t) {
		if (!this.#$s) return;
		const n = t.data,
			r = n.frameId;
		if (!r) return;
		const s = this.framesInternal.get(r);
		if (!s) return;
		const i = n.url;
		if (s.getResourcesMap().get(i)) return;
		const a = new Ir(
			this,
			null,
			i,
			s.url,
			r,
			n.loaderId,
			e.ResourceType.resourceTypes[n.resourceType],
			n.mimeType,
			n.lastModified,
			null
		);
		s.addResource(a);
	}
	frameForId(e) {
		return this.framesInternal.get(e) || null;
	}
	forAllResources(e) {
		return !!this.mainFrame && this.mainFrame.callForFrameResources(e);
	}
	frames() {
		return [...this.framesInternal.values()];
	}
	resourceForURL(e) {
		return this.mainFrame ? this.mainFrame.resourceForURL(e) : null;
	}
	addFramesRecursively(t, n) {
		const r = n.frame;
		let s = this.framesInternal.get(r.id);
		(s || (s = new Lr(this, t, r.id, r, null)),
			!t && r.parentId && (s.crossTargetParentFrameId = r.parentId),
			this.addFrame(s));
		for (const e of n.childFrames || []) this.addFramesRecursively(s, e);
		for (let t = 0; t < n.resources.length; ++t) {
			const i = n.resources[t],
				a = this.createResourceFromFramePayload(
					r,
					i.url,
					e.ResourceType.resourceTypes[i.type],
					i.mimeType,
					i.lastModified || null,
					i.contentSize || null
				);
			s.addResource(a);
		}
		if (!s.getResourcesMap().get(r.url)) {
			const t = this.createResourceFromFramePayload(
				r,
				r.url,
				e.ResourceType.resourceTypes.Document,
				r.mimeType,
				null,
				null
			);
			s.addResource(t);
		}
	}
	createResourceFromFramePayload(e, t, n, r, s, i) {
		const a = "number" == typeof s ? new Date(1e3 * s) : null;
		return new Ir(this, null, t, e.url, e.id, e.loaderId, n, r, a, i);
	}
	suspendReload() {
		this.#Js++;
	}
	resumeReload() {
		if (
			(this.#Js--,
			console.assert(
				this.#Js >= 0,
				"Unbalanced call to ResourceTreeModel.resumeReload()"
			),
			!this.#Js && this.#Xs)
		) {
			const { ignoreCache: e, scriptToEvaluateOnLoad: t } = this.#Xs;
			this.reloadPage(e, t);
		}
	}
	reloadPage(e, t) {
		if (
			(this.#Xs || this.dispatchEventToListeners(xr.PageReloadRequested, this),
			this.#Js)
		)
			return void (this.#Xs = { ignoreCache: e, scriptToEvaluateOnLoad: t });
		this.#Xs = null;
		const n = this.target().model(kt);
		(n && n.clearRequests(),
			this.dispatchEventToListeners(xr.WillReloadPage),
			this.agent.invoke_reload({ ignoreCache: e, scriptToEvaluateOnLoad: t }));
	}
	navigate(e) {
		return this.agent.invoke_navigate({ url: e });
	}
	async navigationHistory() {
		const e = await this.agent.invoke_getNavigationHistory();
		return e.getError()
			? null
			: { currentIndex: e.currentIndex, entries: e.entries };
	}
	navigateToHistoryEntry(e) {
		this.agent.invoke_navigateToHistoryEntry({ entryId: e.id });
	}
	setLifecycleEventsEnabled(e) {
		return this.agent.invoke_setLifecycleEventsEnabled({ enabled: e });
	}
	async fetchAppManifest() {
		const e = await this.agent.invoke_getAppManifest();
		return e.getError()
			? { url: e.url, data: null, errors: [] }
			: { url: e.url, data: e.data || null, errors: e.errors };
	}
	async getInstallabilityErrors() {
		return (
			(await this.agent.invoke_getInstallabilityErrors())
				.installabilityErrors || []
		);
	}
	async getAppId() {
		return this.agent.invoke_getAppId();
	}
	executionContextComparator(e, t) {
		function n(e) {
			let t = e;
			const n = [];
			for (; t; ) (n.push(t), (t = t.sameTargetParentFrame()));
			return n.reverse();
		}
		if (e.target() !== t.target()) return Sn.comparator(e, t);
		const r = e.frameId ? n(this.frameForId(e.frameId)) : [],
			s = t.frameId ? n(this.frameForId(t.frameId)) : [];
		let i, a;
		for (let e = 0; ; e++)
			if (!r[e] || !s[e] || r[e] !== s[e]) {
				((i = r[e]), (a = s[e]));
				break;
			}
		return !i && a
			? -1
			: !a && i
				? 1
				: i && a
					? i.id.localeCompare(a.id)
					: Sn.comparator(e, t);
	}
	getSecurityOriginData() {
		const t = new Set();
		let n = null,
			r = null;
		for (const s of this.framesInternal.values()) {
			const i = s.securityOrigin;
			if (i && (t.add(i), s.isMainFrame() && ((n = i), s.unreachableUrl()))) {
				r = new e.ParsedURL.ParsedURL(s.unreachableUrl()).securityOrigin();
			}
		}
		return {
			securityOrigins: t,
			mainSecurityOrigin: n,
			unreachableMainSecurityOrigin: r,
		};
	}
	async getStorageKeyData() {
		const e = new Set();
		let t = null;
		for (const { isMainFrame: n, storageKey: r } of await Promise.all(
			[...this.framesInternal.values()].map((e) =>
				e
					.getStorageKey(!1)
					.then((t) => ({ isMainFrame: e.isMainFrame(), storageKey: t }))
			)
		))
			(n && (t = r), r && e.add(r));
		return { storageKeys: e, mainStorageKey: t };
	}
	updateSecurityOrigins() {
		const e = this.getSecurityOriginData();
		(this.#Ks.setMainSecurityOrigin(
			e.mainSecurityOrigin || "",
			e.unreachableMainSecurityOrigin || ""
		),
			this.#Ks.updateSecurityOrigins(e.securityOrigins));
	}
	async updateStorageKeys() {
		const e = await this.getStorageKeyData();
		(this.#Qs.setMainStorageKey(e.mainStorageKey || ""),
			this.#Qs.updateStorageKeys(e.storageKeys));
	}
	async getMainStorageKey() {
		return this.mainFrame ? this.mainFrame.getStorageKey(!1) : null;
	}
	getMainSecurityOrigin() {
		const e = this.getSecurityOriginData();
		return e.mainSecurityOrigin || e.unreachableMainSecurityOrigin;
	}
	onBackForwardCacheNotUsed(e) {
		this.mainFrame &&
		this.mainFrame.id === e.frameId &&
		this.mainFrame.loaderId === e.loaderId
			? (this.mainFrame.setBackForwardCacheDetails(e),
				this.dispatchEventToListeners(
					xr.BackForwardCacheDetailsUpdated,
					this.mainFrame
				))
			: this.#Ys.add(e);
	}
	processPendingEvents(e) {
		if (e.isMainFrame())
			for (const t of this.#Ys)
				if (e.id === t.frameId && e.loaderId === t.loaderId) {
					(e.setBackForwardCacheDetails(t), this.#Ys.delete(t));
					break;
				}
	}
}
!(function (e) {
	((e.FrameAdded = "FrameAdded"),
		(e.FrameNavigated = "FrameNavigated"),
		(e.FrameDetached = "FrameDetached"),
		(e.FrameResized = "FrameResized"),
		(e.FrameWillNavigate = "FrameWillNavigate"),
		(e.PrimaryPageChanged = "PrimaryPageChanged"),
		(e.ResourceAdded = "ResourceAdded"),
		(e.WillLoadCachedResources = "WillLoadCachedResources"),
		(e.CachedResourcesLoaded = "CachedResourcesLoaded"),
		(e.DOMContentLoaded = "DOMContentLoaded"),
		(e.LifecycleEvent = "LifecycleEvent"),
		(e.Load = "Load"),
		(e.PageReloadRequested = "PageReloadRequested"),
		(e.WillReloadPage = "WillReloadPage"),
		(e.InterstitialShown = "InterstitialShown"),
		(e.InterstitialHidden = "InterstitialHidden"),
		(e.BackForwardCacheDetailsUpdated = "BackForwardCacheDetailsUpdated"),
		(e.JavaScriptDialogOpening = "JavaScriptDialogOpening"));
})(xr || (xr = {}));
class Lr {
	#gr;
	#ei;
	#Oe;
	crossTargetParentFrameId;
	#Es;
	#p;
	#Ms;
	#ti;
	#ni;
	#ri;
	#si;
	#ii;
	#ai;
	#oi;
	#li;
	#di;
	#ci;
	#hi;
	resourcesMap;
	backForwardCacheDetails = {
		restoredFromCache: void 0,
		explanations: [],
		explanationsTree: void 0,
	};
	constructor(e, n, r, s, i) {
		((this.#gr = e),
			(this.#ei = n),
			(this.#Oe = r),
			(this.crossTargetParentFrameId = null),
			(this.#Es = s?.loaderId || ""),
			(this.#p = s && s.name),
			(this.#Ms = (s && s.url) || t.DevToolsPath.EmptyUrlString),
			(this.#ti = (s && s.domainAndRegistry) || ""),
			(this.#ni = s && s.securityOrigin),
			(this.#si = (s && s.unreachableUrl) || t.DevToolsPath.EmptyUrlString),
			(this.#ii = s?.adFrameStatus),
			(this.#ai = s && s.secureContextType),
			(this.#oi = s && s.crossOriginIsolatedContextType),
			(this.#li = s && s.gatedAPIFeatures),
			(this.#di = i),
			(this.#ci = null),
			(this.#hi = new Set()),
			(this.resourcesMap = new Map()),
			this.#ei && this.#ei.#hi.add(this));
	}
	isSecureContext() {
		return null !== this.#ai && this.#ai.startsWith("Secure");
	}
	getSecureContextType() {
		return this.#ai;
	}
	isCrossOriginIsolated() {
		return null !== this.#oi && this.#oi.startsWith("Isolated");
	}
	getCrossOriginIsolatedContextType() {
		return this.#oi;
	}
	getGatedAPIFeatures() {
		return this.#li;
	}
	getCreationStackTraceData() {
		return {
			creationStackTrace: this.#di,
			creationStackTraceTarget: this.#ci || this.resourceTreeModel().target(),
		};
	}
	navigate(e) {
		((this.#Es = e.loaderId),
			(this.#p = e.name),
			(this.#Ms = e.url),
			(this.#ti = e.domainAndRegistry),
			(this.#ni = e.securityOrigin),
			this.getStorageKey(!0),
			(this.#si = e.unreachableUrl || t.DevToolsPath.EmptyUrlString),
			(this.#ii = e?.adFrameStatus),
			(this.#ai = e.secureContextType),
			(this.#oi = e.crossOriginIsolatedContextType),
			(this.#li = e.gatedAPIFeatures),
			(this.backForwardCacheDetails = {
				restoredFromCache: void 0,
				explanations: [],
				explanationsTree: void 0,
			}));
		const n = this.resourcesMap.get(this.#Ms);
		(this.resourcesMap.clear(),
			this.removeChildFrames(),
			n && n.loaderId === this.#Es && this.addResource(n));
	}
	resourceTreeModel() {
		return this.#gr;
	}
	get id() {
		return this.#Oe;
	}
	get name() {
		return this.#p || "";
	}
	get url() {
		return this.#Ms;
	}
	domainAndRegistry() {
		return this.#ti;
	}
	async getAdScriptId(e) {
		return (
			(await this.#gr.agent.invoke_getAdScriptId({ frameId: e })).adScriptId ||
			null
		);
	}
	get securityOrigin() {
		return this.#ni;
	}
	getStorageKey(e) {
		return (
			(this.#ri && !e) || (this.#ri = this.#gr.storageKeyForFrame(this.#Oe)),
			this.#ri
		);
	}
	unreachableUrl() {
		return this.#si;
	}
	get loaderId() {
		return this.#Es;
	}
	adFrameType() {
		return this.#ii?.adFrameType || "none";
	}
	adFrameStatus() {
		return this.#ii;
	}
	get childFrames() {
		return [...this.#hi];
	}
	sameTargetParentFrame() {
		return this.#ei;
	}
	crossTargetParentFrame() {
		if (!this.crossTargetParentFrameId) return null;
		const e = this.#gr.target().parentTarget();
		if (e?.type() !== je.Frame) return null;
		const t = e.model(Pr);
		return (t && t.framesInternal.get(this.crossTargetParentFrameId)) || null;
	}
	parentFrame() {
		return this.sameTargetParentFrame() || this.crossTargetParentFrame();
	}
	isMainFrame() {
		return !this.#ei;
	}
	isOutermostFrame() {
		return (
			this.#gr.target().parentTarget()?.type() !== je.Frame &&
			!this.#ei &&
			!this.crossTargetParentFrameId
		);
	}
	isPrimaryFrame() {
		return !this.#ei && this.#gr.target() === $e.instance().primaryPageTarget();
	}
	removeChildFrame(e, t) {
		(this.#hi.delete(e), e.remove(t));
	}
	removeChildFrames() {
		const e = this.#hi;
		this.#hi = new Set();
		for (const t of e) t.remove(!1);
	}
	remove(e) {
		(this.removeChildFrames(),
			this.#gr.framesInternal.delete(this.id),
			this.#gr.dispatchEventToListeners(xr.FrameDetached, {
				frame: this,
				isSwap: e,
			}));
	}
	addResource(e) {
		this.resourcesMap.get(e.url) !== e &&
			(this.resourcesMap.set(e.url, e),
			this.#gr.dispatchEventToListeners(xr.ResourceAdded, e));
	}
	addRequest(e) {
		let t = this.resourcesMap.get(e.url());
		(t && t.request === e) ||
			((t = new Ir(
				this.#gr,
				e,
				e.url(),
				e.documentURL,
				e.frameId,
				e.loaderId,
				e.resourceType(),
				e.mimeType,
				null,
				null
			)),
			this.resourcesMap.set(t.url, t),
			this.#gr.dispatchEventToListeners(xr.ResourceAdded, t));
	}
	resources() {
		return Array.from(this.resourcesMap.values());
	}
	resourceForURL(e) {
		const t = this.resourcesMap.get(e);
		if (t) return t;
		for (const t of this.#hi) {
			const n = t.resourceForURL(e);
			if (n) return n;
		}
		return null;
	}
	callForFrameResources(e) {
		for (const t of this.resourcesMap.values()) if (e(t)) return !0;
		for (const t of this.#hi) if (t.callForFrameResources(e)) return !0;
		return !1;
	}
	displayName() {
		if (this.isOutermostFrame()) return i.i18n.lockedString("top");
		const t = new e.ParsedURL.ParsedURL(this.#Ms).displayName;
		return t
			? this.#p
				? this.#p + " (" + t + ")"
				: t
			: i.i18n.lockedString("iframe");
	}
	async getOwnerDeferredDOMNode() {
		const e = this.parentFrame();
		return e
			? e.resourceTreeModel().domModel().getOwnerNodeForFrame(this.#Oe)
			: null;
	}
	async getOwnerDOMNodeOrDocument() {
		const e = await this.getOwnerDeferredDOMNode();
		return e
			? e.resolvePromise()
			: this.isOutermostFrame()
				? this.resourceTreeModel().domModel().requestDocument()
				: null;
	}
	async highlight() {
		const e = this.parentFrame(),
			t = this.resourceTreeModel().target().parentTarget(),
			n = async (e) => {
				const t = await e.getOwnerNodeForFrame(this.#Oe);
				t &&
					e
						.overlayModel()
						.highlightInOverlay(
							{ deferredNode: t, selectorList: "" },
							"all",
							!0
						);
			};
		if (e) return n(e.resourceTreeModel().domModel());
		if (t?.type() === je.Frame) {
			const e = t.model(mr);
			if (e) return n(e);
		}
		const r = await this.resourceTreeModel().domModel().requestDocument();
		r &&
			this.resourceTreeModel()
				.domModel()
				.overlayModel()
				.highlightInOverlay({ node: r, selectorList: "" }, "all", !0);
	}
	async getPermissionsPolicyState() {
		const e = await this.resourceTreeModel()
			.target()
			.pageAgent()
			.invoke_getPermissionsPolicyState({ frameId: this.#Oe });
		return e.getError() ? null : e.states;
	}
	async getOriginTrials() {
		const e = await this.resourceTreeModel()
			.target()
			.pageAgent()
			.invoke_getOriginTrials({ frameId: this.#Oe });
		return e.getError() ? [] : e.originTrials;
	}
	setCreationStackTrace(e) {
		((this.#di = e.creationStackTrace),
			(this.#ci = e.creationStackTraceTarget));
	}
	setBackForwardCacheDetails(e) {
		((this.backForwardCacheDetails.restoredFromCache = !1),
			(this.backForwardCacheDetails.explanations = e.notRestoredExplanations),
			(this.backForwardCacheDetails.explanationsTree =
				e.notRestoredExplanationsTree));
	}
	getResourcesMap() {
		return this.resourcesMap;
	}
}
class Er {
	#dn;
	constructor(e) {
		this.#dn = e;
	}
	backForwardCacheNotUsed(e) {
		this.#dn.onBackForwardCacheNotUsed(e);
	}
	domContentEventFired({ timestamp: e }) {
		this.#dn.dispatchEventToListeners(xr.DOMContentLoaded, e);
	}
	loadEventFired({ timestamp: e }) {
		this.#dn.dispatchEventToListeners(xr.Load, {
			resourceTreeModel: this.#dn,
			loadTime: e,
		});
	}
	lifecycleEvent({ frameId: e, name: t }) {
		this.#dn.dispatchEventToListeners(xr.LifecycleEvent, {
			frameId: e,
			name: t,
		});
	}
	frameAttached({ frameId: e, parentFrameId: t, stack: n }) {
		this.#dn.frameAttached(e, t, n);
	}
	frameNavigated({ frame: e, type: t }) {
		this.#dn.frameNavigated(e, t);
	}
	documentOpened({ frame: e }) {
		this.#dn.documentOpened(e);
	}
	frameDetached({ frameId: e, reason: t }) {
		this.#dn.frameDetached(e, "swap" === t);
	}
	frameStartedLoading({}) {}
	frameStoppedLoading({}) {}
	frameRequestedNavigation({}) {}
	frameScheduledNavigation({}) {}
	frameClearedScheduledNavigation({}) {}
	navigatedWithinDocument({}) {}
	frameResized() {
		this.#dn.dispatchEventToListeners(xr.FrameResized);
	}
	javascriptDialogOpening(e) {
		(this.#dn.dispatchEventToListeners(xr.JavaScriptDialogOpening, e),
			e.hasBrowserHandler ||
				this.#dn.agent.invoke_handleJavaScriptDialog({ accept: !1 }));
	}
	javascriptDialogClosed({}) {}
	screencastFrame({}) {}
	screencastVisibilityChanged({}) {}
	interstitialShown() {
		((this.#dn.isInterstitialShowing = !0),
			this.#dn.dispatchEventToListeners(xr.InterstitialShown));
	}
	interstitialHidden() {
		((this.#dn.isInterstitialShowing = !1),
			this.#dn.dispatchEventToListeners(xr.InterstitialHidden));
	}
	windowOpen({}) {}
	compilationCacheProduced({}) {}
	fileChooserOpened({}) {}
	downloadWillBegin({}) {}
	downloadProgress() {}
}
c.register(Pr, { capabilities: We.DOM, autostart: !0, early: !0 });
var Or = Object.freeze({
	__proto__: null,
	ResourceTreeModel: Pr,
	get Events() {
		return xr;
	},
	ResourceTreeFrame: Lr,
	PageDispatcher: Er,
});
class Ar extends c {
	#ui;
	#gi;
	constructor(e) {
		(super(e), (this.#ui = new Map()), (this.#gi = new Map()));
	}
	addBlockedCookie(e, t) {
		const n = e.key(),
			r = this.#ui.get(n);
		(this.#ui.set(n, e),
			t ? this.#gi.set(e, t) : this.#gi.delete(e),
			r && this.#gi.delete(r));
	}
	getCookieToBlockedReasonsMap() {
		return this.#gi;
	}
	async getCookies(e) {
		const t = await this.target().networkAgent().invoke_getCookies({ urls: e });
		if (t.getError()) return [];
		return t.cookies
			.map(U.fromProtocolCookie)
			.concat(Array.from(this.#ui.values()));
	}
	async deleteCookie(e) {
		await this.deleteCookies([e]);
	}
	async clear(e, t) {
		const n = await this.getCookiesForDomain(e || null);
		if (t) {
			const e = n.filter((e) => e.matchesSecurityOrigin(t));
			await this.deleteCookies(e);
		} else await this.deleteCookies(n);
	}
	async saveCookie(e) {
		let t,
			n = e.domain();
		(n.startsWith(".") || (n = ""),
			e.expires() && (t = Math.floor(Date.parse(`${e.expires()}`) / 1e3)));
		const r = a.Runtime.experiments.isEnabled("experimentalCookieFeatures"),
			s = {
				name: e.name(),
				value: e.value(),
				url: e.url() || void 0,
				domain: n,
				path: e.path(),
				secure: e.secure(),
				httpOnly: e.httpOnly(),
				sameSite: e.sameSite(),
				expires: t,
				priority: e.priority(),
				partitionKey: e.partitionKey(),
				sourceScheme: r
					? e.sourceScheme()
					: ((i = e.sourceScheme()), "Unset" === i ? i : void 0),
				sourcePort: r ? e.sourcePort() : void 0,
			};
		var i;
		const o = await this.target().networkAgent().invoke_setCookie(s);
		return !(o.getError() || !o.success) && o.success;
	}
	getCookiesForDomain(t) {
		const n = [];
		const r = this.target().model(Pr);
		return (
			r &&
				(r.mainFrame &&
					r.mainFrame.unreachableUrl() &&
					n.push(r.mainFrame.unreachableUrl()),
				r.forAllResources(function (r) {
					const s = e.ParsedURL.ParsedURL.fromString(r.documentURL);
					return (!s || (t && s.securityOrigin() !== t) || n.push(r.url), !1);
				})),
			this.getCookies(n)
		);
	}
	async deleteCookies(e) {
		const t = this.target().networkAgent();
		(this.#ui.clear(),
			this.#gi.clear(),
			await Promise.all(
				e.map((e) =>
					t.invoke_deleteCookies({
						name: e.name(),
						url: void 0,
						domain: e.domain(),
						path: e.path(),
					})
				)
			));
	}
}
c.register(Ar, { capabilities: We.Network, autostart: !1 });
var Nr = Object.freeze({ __proto__: null, CookieModel: Ar });
class Dr {
	#pi;
	#mi;
	#fi;
	#bi;
	#yi;
	#vi;
	#Ii;
	constructor(e) {
		(e && (this.#pi = e.toLowerCase().replace(/^\./, "")),
			(this.#mi = []),
			(this.#bi = 0));
	}
	static parseSetCookie(e, t) {
		return new Dr(t).parseSetCookie(e);
	}
	cookies() {
		return this.#mi;
	}
	parseSetCookie(e) {
		if (!this.initialize(e)) return null;
		for (let e = this.extractKeyValue(); e; e = this.extractKeyValue())
			(this.#yi
				? this.#yi.addAttribute(e.key, e.value)
				: this.addCookie(e, H.Response),
				this.advanceAndCheckCookieDelimiter() && this.flushCookie());
		return (this.flushCookie(), this.#mi);
	}
	initialize(e) {
		return (
			(this.#fi = e),
			"string" == typeof e &&
				((this.#mi = []),
				(this.#yi = null),
				(this.#vi = ""),
				(this.#bi = this.#fi.length),
				!0)
		);
	}
	flushCookie() {
		(this.#yi &&
			(this.#yi.setSize(this.#bi - this.#fi.length - this.#Ii),
			this.#yi.setCookieLine(this.#vi.replace("\n", ""))),
			(this.#yi = null),
			(this.#vi = ""));
	}
	extractKeyValue() {
		if (!this.#fi || !this.#fi.length) return null;
		const e = /^[ \t]*([^=;]+)[ \t]*(?:=[ \t]*([^;\n]*))?/.exec(this.#fi);
		if (!e)
			return (
				console.error("Failed parsing cookie header before: " + this.#fi),
				null
			);
		const t = new Fr(
			e[1] && e[1].trim(),
			e[2] && e[2].trim(),
			this.#bi - this.#fi.length
		);
		return ((this.#vi += e[0]), (this.#fi = this.#fi.slice(e[0].length)), t);
	}
	advanceAndCheckCookieDelimiter() {
		if (!this.#fi) return !1;
		const e = /^\s*[\n;]\s*/.exec(this.#fi);
		return (
			!!e &&
			((this.#vi += e[0]),
			(this.#fi = this.#fi.slice(e[0].length)),
			null !== e[0].match("\n"))
		);
	}
	addCookie(e, t) {
		(this.#yi && this.#yi.setSize(e.position - this.#Ii),
			(this.#yi =
				"string" == typeof e.value
					? new U(e.key, e.value, t)
					: new U("", e.key, t)),
			this.#pi && this.#yi.addAttribute("domain", this.#pi),
			(this.#Ii = e.position),
			this.#mi.push(this.#yi));
	}
}
class Fr {
	key;
	value;
	position;
	constructor(e, t, n) {
		((this.key = e), (this.value = t), (this.position = n));
	}
}
var Br = Object.freeze({ __proto__: null, CookieParser: Dr });
function Ur(e) {
	if ("*/*" === e) return { mimeType: null, charset: null };
	const { mimeType: t, params: n } = (function (e) {
		e = e.trim();
		let t = Hr(e, " \t;(");
		t < 0 && (t = e.length);
		const n = e.indexOf("/");
		if (n < 0 || n > t) return { mimeType: null, params: new Map() };
		const r = e.substring(0, t).toLowerCase(),
			s = new Map();
		let i = e.indexOf(";", t);
		for (; i >= 0 && i < e.length; ) {
			if ((++i, (i = qr(e, " \t", i)), i < 0)) continue;
			const t = i;
			if (((i = Hr(e, ";=", i)), i < 0 || ";" === e[i])) continue;
			const n = e.substring(t, i).toLowerCase();
			(++i, (i = qr(e, " \t", i)));
			let r = "";
			if (!(i < 0 || ";" === e[i])) {
				if ('"' !== e[i]) {
					const t = i;
					i = e.indexOf(";", i);
					const n = i >= 0 ? i : e.length;
					r = e.substring(t, n).trimEnd();
				} else {
					for (++i; i < e.length && '"' !== e[i]; )
						("\\" === e[i] && i + 1 < e.length && ++i, (r += e[i]), ++i);
					i = e.indexOf(";", i);
				}
				s.has(n) || s.set(n, r);
			}
		}
		return { mimeType: r, params: s };
	})(e);
	return {
		mimeType: t,
		charset: n.get("charset")?.toLowerCase().trim() ?? null,
	};
}
function Hr(e, t, n = 0) {
	for (let r = n; r < e.length; r++) if (t.includes(e[r])) return r;
	return -1;
}
function qr(e, t, n = 0) {
	for (let r = n; r < e.length; r++) if (!t.includes(e[r])) return r;
	return -1;
}
var _r = Object.freeze({ __proto__: null, parseContentType: Ur });
const zr = {
		deprecatedSyntaxFoundPleaseUse:
			"Deprecated syntax found. Please use: <name>;dur=<duration>;desc=<description>",
		duplicateParameterSIgnored: 'Duplicate parameter "{PH1}" ignored.',
		noValueFoundForParameterS: 'No value found for parameter "{PH1}".',
		unrecognizedParameterS: 'Unrecognized parameter "{PH1}".',
		extraneousTrailingCharacters: "Extraneous trailing characters.",
		unableToParseSValueS: 'Unable to parse "{PH1}" value "{PH2}".',
	},
	jr = i.i18n.registerUIStrings("core/sdk/ServerTiming.ts", zr),
	Wr = i.i18n.getLocalizedString.bind(void 0, jr);
class Vr {
	metric;
	value;
	description;
	constructor(e, t, n) {
		((this.metric = e), (this.value = t), (this.description = n));
	}
	static parseHeaders(e) {
		const n = e.filter((e) => "server-timing" === e.name.toLowerCase());
		if (!n.length) return null;
		const r = n.reduce((e, t) => {
			const n = this.createFromHeaderValue(t.value);
			return (
				e.push(
					...n.map(function (e) {
						return new Vr(
							e.name,
							e.hasOwnProperty("dur") ? e.dur : null,
							e.hasOwnProperty("desc") ? e.desc : ""
						);
					})
				),
				e
			);
		}, []);
		return (
			r.sort((e, n) =>
				t.StringUtilities.compare(
					e.metric.toLowerCase(),
					n.metric.toLowerCase()
				)
			),
			r
		);
	}
	static createFromHeaderValue(e) {
		function t() {
			e = e.replace(/^\s*/, "");
		}
		function n(n) {
			return (
				console.assert(1 === n.length),
				t(),
				e.charAt(0) === n && ((e = e.substring(1)), !0)
			);
		}
		function r() {
			const t = /^(?:\s*)([\w!#$%&'*+\-.^`|~]+)(?:\s*)(.*)/.exec(e);
			return t ? ((e = t[2]), t[1]) : null;
		}
		function s() {
			return (
				t(),
				'"' === e.charAt(0)
					? (function () {
							(console.assert('"' === e.charAt(0)), (e = e.substring(1)));
							let t = "";
							for (; e.length; ) {
								const n = /^([^"\\]*)(.*)/.exec(e);
								if (!n) return null;
								if (((t += n[1]), '"' === n[2].charAt(0)))
									return ((e = n[2].substring(1)), t);
								(console.assert("\\" === n[2].charAt(0)),
									(t += n[2].charAt(1)),
									(e = n[2].substring(2)));
							}
							return null;
						})()
					: r()
			);
		}
		function i() {
			const t = /([,;].*)/.exec(e);
			t && (e = t[1]);
		}
		const a = [];
		let o;
		for (; null !== (o = r()); ) {
			const t = { name: o };
			for (
				"=" === e.charAt(0) &&
				this.showWarning(Wr(zr.deprecatedSyntaxFoundPleaseUse));
				n(";");

			) {
				let e;
				if (null === (e = r())) continue;
				e = e.toLowerCase();
				const a = this.getParserForParameter(e);
				let o = null;
				if ((n("=") && ((o = s()), i()), a)) {
					if (t.hasOwnProperty(e)) {
						this.showWarning(Wr(zr.duplicateParameterSIgnored, { PH1: e }));
						continue;
					}
					(null === o &&
						this.showWarning(Wr(zr.noValueFoundForParameterS, { PH1: e })),
						a.call(this, t, o));
				} else this.showWarning(Wr(zr.unrecognizedParameterS, { PH1: e }));
			}
			if ((a.push(t), !n(","))) break;
		}
		return (
			e.length && this.showWarning(Wr(zr.extraneousTrailingCharacters)),
			a
		);
	}
	static getParserForParameter(e) {
		switch (e) {
			case "dur": {
				function t(t, n) {
					if (((t.dur = 0), null !== n)) {
						const r = parseFloat(n);
						if (isNaN(r))
							return void Vr.showWarning(
								Wr(zr.unableToParseSValueS, { PH1: e, PH2: n })
							);
						t.dur = r;
					}
				}
				return t;
			}
			case "desc": {
				function n(e, t) {
					e.desc = t || "";
				}
				return n;
			}
			default:
				return null;
		}
	}
	static showWarning(t) {
		e.Console.Console.instance().warn(`ServerTiming: ${t}`);
	}
}
var Gr = Object.freeze({ __proto__: null, ServerTiming: Vr });
const Kr = {
		binary: "(binary)",
		secureOnly:
			'This cookie was blocked because it had the "`Secure`" attribute and the connection was not secure.',
		notOnPath:
			"This cookie was blocked because its path was not an exact match for or a superdirectory of the request url's path.",
		domainMismatch:
			"This cookie was blocked because neither did the request URL's domain exactly match the cookie's domain, nor was the request URL's domain a subdomain of the cookie's Domain attribute value.",
		sameSiteStrict:
			'This cookie was blocked because it had the "`SameSite=Strict`" attribute and the request was made from a different site. This includes top-level navigation requests initiated by other sites.',
		sameSiteLax:
			'This cookie was blocked because it had the "`SameSite=Lax`" attribute and the request was made from a different site and was not initiated by a top-level navigation.',
		sameSiteUnspecifiedTreatedAsLax:
			'This cookie didn\'t specify a "`SameSite`" attribute when it was stored and was defaulted to "SameSite=Lax," and was blocked because the request was made from a different site and was not initiated by a top-level navigation. The cookie had to have been set with "`SameSite=None`" to enable cross-site usage.',
		sameSiteNoneInsecure:
			'This cookie was blocked because it had the "`SameSite=None`" attribute but was not marked "Secure". Cookies without SameSite restrictions must be marked "Secure" and sent over a secure connection.',
		userPreferences: "This cookie was blocked due to user preferences.",
		thirdPartyPhaseout:
			"This cookie was blocked due to third-party cookie phaseout. Learn more in the Issues tab.",
		unknownError:
			"An unknown error was encountered when trying to send this cookie.",
		schemefulSameSiteStrict:
			'This cookie was blocked because it had the "`SameSite=Strict`" attribute but the request was cross-site. This includes top-level navigation requests initiated by other sites. This request is considered cross-site because the URL has a different scheme than the current site.',
		schemefulSameSiteLax:
			'This cookie was blocked because it had the "`SameSite=Lax`" attribute but the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
		schemefulSameSiteUnspecifiedTreatedAsLax:
			'This cookie didn\'t specify a "`SameSite`" attribute when it was stored, was defaulted to "`SameSite=Lax"`, and was blocked because the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
		samePartyFromCrossPartyContext:
			"This cookie was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
		nameValuePairExceedsMaxSize:
			"This cookie was blocked because it was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
		thisSetcookieWasBlockedDueToUser:
			"This attempt to set a cookie via a `Set-Cookie` header was blocked due to user preferences.",
		thisSetcookieWasBlockedDueThirdPartyPhaseout:
			"Setting this cookie was blocked due to third-party cookie phaseout. Learn more in the Issues tab.",
		thisSetcookieHadInvalidSyntax:
			"This `Set-Cookie` header had invalid syntax.",
		thisSetcookieHadADisallowedCharacter:
			"This `Set-Cookie` header contained a disallowed character (a forbidden ASCII control character, or the tab character if it appears in the middle of the cookie name, value, an attribute name, or an attribute value).",
		theSchemeOfThisConnectionIsNot:
			"The scheme of this connection is not allowed to store cookies.",
		anUnknownErrorWasEncounteredWhenTrying:
			"An unknown error was encountered when trying to store this cookie.",
		thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
		thisSetcookieDidntSpecifyASamesite:
			'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute, was defaulted to "`SameSite=Lax"`, and was blocked because it came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
		thisSetcookieWasBlockedBecauseItHadTheSameparty:
			"This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
		thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameParty`" attribute but also had other conflicting attributes. Chrome requires cookies that use the "`SameParty`" attribute to also have the "Secure" attribute, and to not be restricted to "`SameSite=Strict`".',
		blockedReasonSecureOnly:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "Secure" attribute but was not received over a secure connection.',
		blockedReasonSameSiteStrictLax:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation.',
		blockedReasonSameSiteUnspecifiedTreatedAsLax:
			'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute and was defaulted to "`SameSite=Lax,`" and was blocked because it came from a cross-site response which was not the response to a top-level navigation. The `Set-Cookie` had to have been set with "`SameSite=None`" to enable cross-site usage.',
		blockedReasonSameSiteNoneInsecure:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameSite=None`" attribute but did not have the "Secure" attribute, which is required in order to use "`SameSite=None`".',
		blockedReasonOverwriteSecure:
			"This attempt to set a cookie via a `Set-Cookie` header was blocked because it was not sent over a secure connection and would have overwritten a cookie with the Secure attribute.",
		blockedReasonInvalidDomain:
			"This attempt to set a cookie via a `Set-Cookie` header was blocked because its Domain attribute was invalid with regards to the current host url.",
		blockedReasonInvalidPrefix:
			'This attempt to set a cookie via a `Set-Cookie` header was blocked because it used the "`__Secure-`" or "`__Host-`" prefix in its name and broke the additional rules applied to cookies with these prefixes as defined in `https://tools.ietf.org/html/draft-west-cookie-prefixes-05`.',
		thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize:
			"This attempt to set a cookie via a `Set-Cookie` header was blocked because the cookie was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
		setcookieHeaderIsIgnoredIn:
			"Set-Cookie header is ignored in response from url: {PH1}. The combined size of the name and value must be less than or equal to 4096 characters.",
	},
	Qr = i.i18n.registerUIStrings("core/sdk/NetworkRequest.ts", Kr),
	$r = i.i18n.getLocalizedString.bind(void 0, Qr);
class Xr extends e.ObjectWrapper.ObjectWrapper {
	#ki;
	#Si;
	#Ps;
	#Ls;
	#Es;
	#wi;
	#Ci;
	#Ri;
	#Ti;
	#xi;
	#Mi;
	#Pi;
	#Li;
	#Ei;
	#Oi;
	#Ai;
	#Ni;
	statusCode;
	statusText;
	requestMethod;
	requestTime;
	protocol;
	alternateProtocolUsage;
	mixedContentType;
	#Di;
	#Fi;
	#Bi;
	#Ui;
	#Hi;
	#qi;
	#_i;
	#zi;
	#ji;
	#Wi;
	#Vi;
	#Gi;
	#Ki;
	#Qi;
	#$i;
	#Xi;
	#Ji;
	#Yi;
	#Zi;
	#ea;
	#ta;
	connectionId;
	connectionReused;
	hasNetworkData;
	#na;
	#ra;
	#sa;
	#ia;
	#aa;
	#oa;
	#la;
	#da;
	#ca;
	#ha;
	localizedFailDescription;
	#Ms;
	#ua;
	#ga;
	#Ut;
	#pa;
	#ma;
	#fa;
	#As;
	#qs;
	#p;
	#ba;
	#ya;
	#va;
	#Ia;
	#ka;
	#Sa;
	#wa;
	#Ca;
	#Ra;
	#Ta;
	#xa;
	#Ma;
	#Pa;
	#La;
	#Ea;
	#Oa;
	#Aa;
	#Na;
	#Da;
	#Fa;
	#Ba;
	#Ua;
	#Ha;
	#qa;
	#_a;
	#za = new Map();
	#ja;
	#Wa;
	constructor(t, n, r, s, i, a, o, l) {
		(super(),
			(this.#ki = t),
			(this.#Si = n),
			this.setUrl(r),
			(this.#Ps = s),
			(this.#Ls = i),
			(this.#Es = a),
			(this.#wi = o),
			(this.#Ci = l),
			(this.#Ri = null),
			(this.#Ti = null),
			(this.#xi = null),
			(this.#Mi = !1),
			(this.#Pi = null),
			(this.#Li = -1),
			(this.#Ei = -1),
			(this.#Oi = -1),
			(this.#Ai = void 0),
			(this.#Ni = void 0),
			(this.statusCode = 0),
			(this.statusText = ""),
			(this.requestMethod = ""),
			(this.requestTime = 0),
			(this.protocol = ""),
			(this.alternateProtocolUsage = void 0),
			(this.mixedContentType = "none"),
			(this.#Di = null),
			(this.#Fi = null),
			(this.#Bi = null),
			(this.#Ui = null),
			(this.#Hi = null),
			(this.#qi = e.ResourceType.resourceTypes.Other),
			(this.#_i = null),
			(this.#zi = []),
			(this.#ji = []),
			(this.#Wi = {}),
			(this.#Vi = ""),
			(this.#Gi = []),
			(this.#Qi = []),
			(this.#$i = []),
			(this.#Xi = {}),
			(this.#Ji = ""),
			(this.#Yi = "Unknown"),
			(this.#Zi = null),
			(this.#ea = "unknown"),
			(this.#ta = null),
			(this.connectionId = "0"),
			(this.connectionReused = !1),
			(this.hasNetworkData = !1),
			(this.#na = null),
			(this.#ra = Promise.resolve(null)),
			(this.#sa = !1),
			(this.#ia = !1),
			(this.#aa = []),
			(this.#oa = []),
			(this.#la = []),
			(this.#ha = !1),
			(this.#da = null),
			(this.#ca = null),
			(this.localizedFailDescription = null),
			(this.#qa = null),
			(this.#_a = !1),
			(this.#ja = !1),
			(this.#Wa = !1));
	}
	static create(e, t, n, r, s, i, a) {
		return new Xr(e, e, t, n, r, s, i, a);
	}
	static createForWebSocket(e, n, r) {
		return new Xr(
			e,
			e,
			n,
			t.DevToolsPath.EmptyUrlString,
			null,
			null,
			r || null
		);
	}
	static createWithoutBackendRequest(e, t, n, r) {
		return new Xr(e, void 0, t, n, null, null, r);
	}
	identityCompare(e) {
		const t = this.requestId(),
			n = e.requestId();
		return t > n ? 1 : t < n ? -1 : 0;
	}
	requestId() {
		return this.#ki;
	}
	backendRequestId() {
		return this.#Si;
	}
	url() {
		return this.#Ms;
	}
	isBlobRequest() {
		return e.ParsedURL.schemeIs(this.#Ms, "blob:");
	}
	setUrl(t) {
		this.#Ms !== t &&
			((this.#Ms = t),
			(this.#qs = new e.ParsedURL.ParsedURL(t)),
			(this.#Ba = void 0),
			(this.#Ua = void 0),
			(this.#p = void 0),
			(this.#ba = void 0));
	}
	get documentURL() {
		return this.#Ps;
	}
	get parsedURL() {
		return this.#qs;
	}
	get frameId() {
		return this.#Ls;
	}
	get loaderId() {
		return this.#Es;
	}
	setRemoteAddress(e, t) {
		((this.#Ji = e + ":" + t),
			this.dispatchEventToListeners(Jr.RemoteAddressChanged, this));
	}
	remoteAddress() {
		return this.#Ji;
	}
	remoteAddressSpace() {
		return this.#Yi;
	}
	getResponseCacheStorageCacheName() {
		return this.#ka;
	}
	setResponseCacheStorageCacheName(e) {
		this.#ka = e;
	}
	serviceWorkerResponseSource() {
		return this.#Sa;
	}
	setServiceWorkerResponseSource(e) {
		this.#Sa = e;
	}
	setReferrerPolicy(e) {
		this.#Zi = e;
	}
	referrerPolicy() {
		return this.#Zi;
	}
	securityState() {
		return this.#ea;
	}
	setSecurityState(e) {
		this.#ea = e;
	}
	securityDetails() {
		return this.#ta;
	}
	securityOrigin() {
		return this.#qs.securityOrigin();
	}
	setSecurityDetails(e) {
		this.#ta = e;
	}
	get startTime() {
		return this.#Ei || -1;
	}
	setIssueTime(e, t) {
		((this.#Li = e), (this.#wa = t), (this.#Ei = e));
	}
	issueTime() {
		return this.#Li;
	}
	pseudoWallTime(e) {
		return this.#wa ? this.#wa - this.#Li + e : e;
	}
	get responseReceivedTime() {
		return this.#ua || -1;
	}
	set responseReceivedTime(e) {
		this.#ua = e;
	}
	getResponseRetrievalTime() {
		return this.#Ca;
	}
	setResponseRetrievalTime(e) {
		this.#Ca = e;
	}
	get endTime() {
		return this.#Oi || -1;
	}
	set endTime(e) {
		(this.timing && this.timing.requestTime
			? (this.#Oi = Math.max(e, this.responseReceivedTime))
			: ((this.#Oi = e), this.#ua > e && (this.#ua = e)),
			this.dispatchEventToListeners(Jr.TimingChanged, this));
	}
	get duration() {
		return -1 === this.#Oi || -1 === this.#Ei ? -1 : this.#Oi - this.#Ei;
	}
	get latency() {
		return -1 === this.#ua || -1 === this.#Ei ? -1 : this.#ua - this.#Ei;
	}
	get resourceSize() {
		return this.#Ra || 0;
	}
	set resourceSize(e) {
		this.#Ra = e;
	}
	get transferSize() {
		return this.#ga || 0;
	}
	increaseTransferSize(e) {
		this.#ga = (this.#ga || 0) + e;
	}
	setTransferSize(e) {
		this.#ga = e;
	}
	get finished() {
		return this.#Ut;
	}
	set finished(e) {
		this.#Ut !== e &&
			((this.#Ut = e),
			e && this.dispatchEventToListeners(Jr.FinishedLoading, this));
	}
	get failed() {
		return this.#pa;
	}
	set failed(e) {
		this.#pa = e;
	}
	get canceled() {
		return this.#ma;
	}
	set canceled(e) {
		this.#ma = e;
	}
	get preserved() {
		return this.#fa;
	}
	set preserved(e) {
		this.#fa = e;
	}
	blockedReason() {
		return this.#Ai;
	}
	setBlockedReason(e) {
		this.#Ai = e;
	}
	corsErrorStatus() {
		return this.#Ni;
	}
	setCorsErrorStatus(e) {
		this.#Ni = e;
	}
	wasBlocked() {
		return Boolean(this.#Ai);
	}
	cached() {
		return (Boolean(this.#Ta) || Boolean(this.#xa)) && !this.#ga;
	}
	cachedInMemory() {
		return Boolean(this.#Ta) && !this.#ga;
	}
	fromPrefetchCache() {
		return Boolean(this.#Ma);
	}
	setFromMemoryCache() {
		((this.#Ta = !0), (this.#Ea = void 0));
	}
	get fromDiskCache() {
		return this.#xa;
	}
	setFromDiskCache() {
		this.#xa = !0;
	}
	setFromPrefetchCache() {
		this.#Ma = !0;
	}
	get fetchedViaServiceWorker() {
		return Boolean(this.#Pa);
	}
	set fetchedViaServiceWorker(e) {
		this.#Pa = e;
	}
	get serviceWorkerRouterInfo() {
		return this.#La;
	}
	set serviceWorkerRouterInfo(e) {
		this.#La = e;
	}
	initiatedByServiceWorker() {
		const e = kt.forRequest(this);
		return !!e && e.target().type() === je.ServiceWorker;
	}
	get timing() {
		return this.#Ea;
	}
	set timing(e) {
		if (!e || this.#Ta) return;
		this.#Ei = e.requestTime;
		const t = e.requestTime + e.receiveHeadersEnd / 1e3;
		(((this.#ua || -1) < 0 || this.#ua > t) && (this.#ua = t),
			this.#Ei > this.#ua && (this.#ua = this.#Ei),
			(this.#Ea = e),
			this.dispatchEventToListeners(Jr.TimingChanged, this));
	}
	setConnectTimingFromExtraInfo(e) {
		((this.#Ei = e.requestTime),
			this.dispatchEventToListeners(Jr.TimingChanged, this));
	}
	get mimeType() {
		return this.#As;
	}
	set mimeType(e) {
		this.#As = e;
	}
	get displayName() {
		return this.#qs.displayName;
	}
	name() {
		return (this.#p || this.parseNameAndPathFromURL(), this.#p);
	}
	path() {
		return (this.#ba || this.parseNameAndPathFromURL(), this.#ba);
	}
	parseNameAndPathFromURL() {
		if (this.#qs.isDataURL())
			((this.#p = this.#qs.dataURLDisplayName()), (this.#ba = ""));
		else if (this.#qs.isBlobURL()) ((this.#p = this.#qs.url), (this.#ba = ""));
		else if (this.#qs.isAboutBlank())
			((this.#p = this.#qs.url), (this.#ba = ""));
		else {
			this.#ba = this.#qs.host + this.#qs.folderPathComponents;
			const n = kt.forRequest(this),
				r = n
					? e.ParsedURL.ParsedURL.fromString(n.target().inspectedURL())
					: null;
			((this.#ba = t.StringUtilities.trimURL(this.#ba, r ? r.host : "")),
				this.#qs.lastPathComponent || this.#qs.queryParams
					? (this.#p =
							this.#qs.lastPathComponent +
							(this.#qs.queryParams ? "?" + this.#qs.queryParams : ""))
					: this.#qs.folderPathComponents
						? ((this.#p =
								this.#qs.folderPathComponents.substring(
									this.#qs.folderPathComponents.lastIndexOf("/") + 1
								) + "/"),
							(this.#ba = this.#ba.substring(0, this.#ba.lastIndexOf("/"))))
						: ((this.#p = this.#qs.host), (this.#ba = "")));
		}
	}
	get folder() {
		let e = this.#qs.path;
		const t = e.indexOf("?");
		-1 !== t && (e = e.substring(0, t));
		const n = e.lastIndexOf("/");
		return -1 !== n ? e.substring(0, n) : "";
	}
	get pathname() {
		return this.#qs.path;
	}
	resourceType() {
		return this.#qi;
	}
	setResourceType(e) {
		this.#qi = e;
	}
	get domain() {
		return this.#qs.host;
	}
	get scheme() {
		return this.#qs.scheme;
	}
	getInferredStatusText() {
		return (
			this.statusText ||
			((e = this.statusCode),
			i.i18n.lockedString(
				{
					100: "Continue",
					101: "Switching Protocols",
					102: "Processing",
					103: "Early Hints",
					200: "OK",
					201: "Created",
					202: "Accepted",
					203: "Non-Authoritative Information",
					204: "No Content",
					205: "Reset Content",
					206: "Partial Content",
					207: "Multi-Status",
					208: "Already Reported",
					226: "IM Used",
					300: "Multiple Choices",
					301: "Moved Permanently",
					302: "Found",
					303: "See Other",
					304: "Not Modified",
					305: "Use Proxy",
					307: "Temporary Redirect",
					308: "Permanent Redirect",
					400: "Bad Request",
					401: "Unauthorized",
					402: "Payment Required",
					403: "Forbidden",
					404: "Not Found",
					405: "Method Not Allowed",
					406: "Not Acceptable",
					407: "Proxy Authentication Required",
					408: "Request Timeout",
					409: "Conflict",
					410: "Gone",
					411: "Length Required",
					412: "Precondition Failed",
					413: "Payload Too Large",
					414: "URI Too Long",
					415: "Unsupported Media Type",
					416: "Range Not Satisfiable",
					417: "Expectation Failed",
					418: "I'm a teapot",
					421: "Misdirected Request",
					422: "Unprocessable Content",
					423: "Locked",
					424: "Failed Dependency",
					425: "Too Early",
					426: "Upgrade Required",
					428: "Precondition Required",
					429: "Too Many Requests",
					431: "Request Header Fields Too Large",
					451: "Unavailable For Legal Reasons",
					500: "Internal Server Error",
					501: "Not Implemented",
					502: "Bad Gateway",
					503: "Service Unavailable",
					504: "Gateway Timeout",
					505: "HTTP Version Not Supported",
					506: "Variant Also Negotiates",
					507: "Insufficient Storage",
					508: "Loop Detected",
					510: "Not Extended",
					511: "Network Authentication Required",
				}[e] ?? ""
			))
		);
		var e;
	}
	redirectSource() {
		return this.#Ri;
	}
	setRedirectSource(e) {
		this.#Ri = e;
	}
	preflightRequest() {
		return this.#Ti;
	}
	setPreflightRequest(e) {
		this.#Ti = e;
	}
	preflightInitiatorRequest() {
		return this.#xi;
	}
	setPreflightInitiatorRequest(e) {
		this.#xi = e;
	}
	isPreflightRequest() {
		return (
			null !== this.#wi && void 0 !== this.#wi && "preflight" === this.#wi.type
		);
	}
	redirectDestination() {
		return this.#Pi;
	}
	setRedirectDestination(e) {
		this.#Pi = e;
	}
	requestHeaders() {
		return this.#$i;
	}
	setRequestHeaders(e) {
		((this.#$i = e), this.dispatchEventToListeners(Jr.RequestHeadersChanged));
	}
	requestHeadersText() {
		return this.#Oa;
	}
	setRequestHeadersText(e) {
		((this.#Oa = e), this.dispatchEventToListeners(Jr.RequestHeadersChanged));
	}
	requestHeaderValue(e) {
		return (
			this.#Xi[e] ||
				(this.#Xi[e] = this.computeHeaderValue(this.requestHeaders(), e)),
			this.#Xi[e]
		);
	}
	requestFormData() {
		return (this.#ra || (this.#ra = kt.requestPostData(this)), this.#ra);
	}
	setRequestFormData(e, t) {
		((this.#ra = e && null === t ? null : Promise.resolve(t)),
			(this.#na = null));
	}
	filteredProtocolName() {
		const e = this.protocol.toLowerCase();
		return "h2" === e ? "http/2.0" : e.replace(/^http\/2(\.0)?\+/, "http/2.0+");
	}
	requestHttpVersion() {
		const e = this.requestHeadersText();
		if (!e) {
			const e =
				this.requestHeaderValue("version") ||
				this.requestHeaderValue(":version");
			return e || this.filteredProtocolName();
		}
		const t = e.split(/\r\n/)[0].match(/(HTTP\/\d+\.\d+)$/);
		return t ? t[1] : "HTTP/0.9";
	}
	get responseHeaders() {
		return this.#Aa || [];
	}
	set responseHeaders(e) {
		((this.#Aa = e),
			(this.#Na = void 0),
			(this.#Fa = void 0),
			(this.#Da = void 0),
			(this.#Wi = {}),
			this.dispatchEventToListeners(Jr.ResponseHeadersChanged));
	}
	get originalResponseHeaders() {
		return this.#Gi;
	}
	set originalResponseHeaders(e) {
		((this.#Gi = e), (this.#Ki = void 0));
	}
	get setCookieHeaders() {
		return this.#Qi;
	}
	set setCookieHeaders(e) {
		this.#Qi = e;
	}
	get responseHeadersText() {
		return this.#Vi;
	}
	set responseHeadersText(e) {
		((this.#Vi = e), this.dispatchEventToListeners(Jr.ResponseHeadersChanged));
	}
	get sortedResponseHeaders() {
		return void 0 !== this.#Na
			? this.#Na
			: ((this.#Na = this.responseHeaders.slice()),
				this.#Na.sort(function (e, n) {
					return t.StringUtilities.compare(
						e.name.toLowerCase(),
						n.name.toLowerCase()
					);
				}));
	}
	get sortedOriginalResponseHeaders() {
		return void 0 !== this.#Ki
			? this.#Ki
			: ((this.#Ki = this.originalResponseHeaders.slice()),
				this.#Ki.sort(function (e, n) {
					return t.StringUtilities.compare(
						e.name.toLowerCase(),
						n.name.toLowerCase()
					);
				}));
	}
	get overrideTypes() {
		const e = [];
		return (
			this.hasOverriddenContent && e.push("content"),
			this.hasOverriddenHeaders() && e.push("headers"),
			e
		);
	}
	get hasOverriddenContent() {
		return this.#ja;
	}
	set hasOverriddenContent(e) {
		this.#ja = e;
	}
	#Va(e) {
		const t = [];
		for (const n of e)
			t.length && t[t.length - 1].name === n.name
				? (t[t.length - 1].value += `, ${n.value}`)
				: t.push({ name: n.name, value: n.value });
		return t;
	}
	hasOverriddenHeaders() {
		if (!this.#Gi.length) return !1;
		const e = this.#Va(this.sortedResponseHeaders),
			t = this.#Va(this.sortedOriginalResponseHeaders);
		if (e.length !== t.length) return !0;
		for (let n = 0; n < e.length; n++) {
			if (e[n].name.toLowerCase() !== t[n].name.toLowerCase()) return !0;
			if (e[n].value !== t[n].value) return !0;
		}
		return !1;
	}
	responseHeaderValue(e) {
		return (
			e in this.#Wi ||
				(this.#Wi[e] = this.computeHeaderValue(this.responseHeaders, e)),
			this.#Wi[e]
		);
	}
	wasIntercepted() {
		return this.#_a;
	}
	setWasIntercepted(e) {
		this.#_a = e;
	}
	get responseCookies() {
		if (!this.#Da)
			if (
				((this.#Da =
					Dr.parseSetCookie(
						this.responseHeaderValue("Set-Cookie"),
						this.domain
					) || []),
				this.#da)
			)
				for (const e of this.#Da) e.setPartitionKey(this.#da);
			else if (this.#ca) for (const e of this.#Da) e.setPartitionKeyOpaque();
		return this.#Da;
	}
	responseLastModified() {
		return this.responseHeaderValue("last-modified");
	}
	allCookiesIncludingBlockedOnes() {
		return [
			...this.includedRequestCookies(),
			...this.responseCookies,
			...this.blockedRequestCookies().map((e) => e.cookie),
			...this.blockedResponseCookies().map((e) => e.cookie),
		].filter((e) => Boolean(e));
	}
	get serverTimings() {
		return (
			void 0 === this.#Fa && (this.#Fa = Vr.parseHeaders(this.responseHeaders)),
			this.#Fa
		);
	}
	queryString() {
		if (void 0 !== this.#Ba) return this.#Ba;
		let e = null;
		const t = this.url(),
			n = t.indexOf("?");
		if (-1 !== n) {
			e = t.substring(n + 1);
			const r = e.indexOf("#");
			-1 !== r && (e = e.substring(0, r));
		}
		return ((this.#Ba = e), this.#Ba);
	}
	get queryParameters() {
		if (this.#Ua) return this.#Ua;
		const e = this.queryString();
		return e ? ((this.#Ua = this.parseParameters(e)), this.#Ua) : null;
	}
	async parseFormParameters() {
		const e = this.requestContentType();
		if (!e) return null;
		if (e.match(/^application\/x-www-form-urlencoded\s*(;.*)?$/i)) {
			const e = await this.requestFormData();
			return e ? this.parseParameters(e) : null;
		}
		const t = e.match(/^multipart\/form-data\s*;\s*boundary\s*=\s*(\S+)\s*$/);
		if (!t) return null;
		const n = t[1];
		if (!n) return null;
		const r = await this.requestFormData();
		return r ? this.parseMultipartFormDataParameters(r, n) : null;
	}
	formParameters() {
		return (this.#na || (this.#na = this.parseFormParameters()), this.#na);
	}
	responseHttpVersion() {
		const e = this.#Vi;
		if (!e) {
			const e =
				this.responseHeaderValue("version") ||
				this.responseHeaderValue(":version");
			return e || this.filteredProtocolName();
		}
		const t = e.split(/\r\n/)[0].match(/^(HTTP\/\d+\.\d+)/);
		return t ? t[1] : "HTTP/0.9";
	}
	parseParameters(e) {
		return e.split("&").map(function (e) {
			const t = e.indexOf("=");
			return -1 === t
				? { name: e, value: "" }
				: { name: e.substring(0, t), value: e.substring(t + 1) };
		});
	}
	parseMultipartFormDataParameters(e, n) {
		const r = t.StringUtilities.escapeForRegExp(n),
			s = new RegExp(
				'^\\r\\ncontent-disposition\\s*:\\s*form-data\\s*;\\s*name="([^"]*)"(?:\\s*;\\s*filename="([^"]*)")?(?:\\r\\ncontent-type\\s*:\\s*([^\\r\\n]*))?\\r\\n\\r\\n(.*)\\r\\n$',
				"is"
			);
		return e.split(new RegExp(`--${r}(?:--s*$)?`, "g")).reduce(function (e, t) {
			const [n, r, i, a, o] = t.match(s) || [];
			if (!n) return e;
			const l = i || a ? $r(Kr.binary) : o;
			return (e.push({ name: r, value: l }), e);
		}, []);
	}
	computeHeaderValue(e, t) {
		t = t.toLowerCase();
		const n = [];
		for (let r = 0; r < e.length; ++r)
			e[r].name.toLowerCase() === t && n.push(e[r].value);
		if (n.length) return "set-cookie" === t ? n.join("\n") : n.join(", ");
	}
	contentData() {
		return (
			this.#_i ||
				(this.#Ha
					? (this.#_i = this.#Ha())
					: (this.#_i = kt.requestContentData(this))),
			this.#_i
		);
	}
	setContentDataProvider(e) {
		(console.assert(!this.#_i, "contentData can only be set once."),
			(this.#Ha = e));
	}
	contentURL() {
		return this.#Ms;
	}
	contentType() {
		return this.#qi;
	}
	async requestContent() {
		return D.asDeferredContent(await this.contentData());
	}
	async searchInContent(e, t, n) {
		if (!this.#Ha) return kt.searchInRequest(this, e, t, n);
		const r = await this.contentData();
		return D.isError(r) || !r.resourceType.isTextType()
			? []
			: s.TextUtils.performSearchInContent(r.text, e, t, n);
	}
	isHttpFamily() {
		return Boolean(this.url().match(/^https?:/i));
	}
	requestContentType() {
		return this.requestHeaderValue("Content-Type");
	}
	hasErrorStatusCode() {
		return this.statusCode >= 400;
	}
	setInitialPriority(e) {
		this.#Di = e;
	}
	initialPriority() {
		return this.#Di;
	}
	setPriority(e) {
		this.#Fi = e;
	}
	priority() {
		return this.#Fi || this.#Di || null;
	}
	setSignedExchangeInfo(e) {
		this.#Bi = e;
	}
	signedExchangeInfo() {
		return this.#Bi;
	}
	setWebBundleInfo(e) {
		this.#Ui = e;
	}
	webBundleInfo() {
		return this.#Ui;
	}
	setWebBundleInnerRequestInfo(e) {
		this.#Hi = e;
	}
	webBundleInnerRequestInfo() {
		return this.#Hi;
	}
	async populateImageSource(e) {
		const t = await this.contentData();
		if (D.isError(t)) return;
		let n = t.asDataUrl();
		if (null === n && !this.#pa) {
			(this.responseHeaderValue("cache-control") || "").includes("no-cache") ||
				(n = this.#Ms);
		}
		null !== n && (e.src = n);
	}
	initiator() {
		return this.#wi || null;
	}
	hasUserGesture() {
		return this.#Ci ?? null;
	}
	frames() {
		return this.#zi;
	}
	addProtocolFrameError(e, t) {
		this.addFrame({
			type: Zr.Error,
			text: e,
			time: this.pseudoWallTime(t),
			opCode: -1,
			mask: !1,
		});
	}
	addProtocolFrame(e, t, n) {
		const r = n ? Zr.Send : Zr.Receive;
		this.addFrame({
			type: r,
			text: e.payloadData,
			time: this.pseudoWallTime(t),
			opCode: e.opcode,
			mask: e.mask,
		});
	}
	addFrame(e) {
		(this.#zi.push(e),
			this.dispatchEventToListeners(Jr.WebsocketFrameAdded, e));
	}
	eventSourceMessages() {
		return this.#ji;
	}
	addEventSourceMessage(e, t, n, r) {
		const s = {
			time: this.pseudoWallTime(e),
			eventName: t,
			eventId: n,
			data: r,
		};
		(this.#ji.push(s),
			this.dispatchEventToListeners(Jr.EventSourceMessageAdded, s));
	}
	markAsRedirect(e) {
		((this.#Mi = !0), (this.#ki = `${this.#Si}:redirected.${e}`));
	}
	isRedirect() {
		return this.#Mi;
	}
	setRequestIdForTest(e) {
		((this.#Si = e), (this.#ki = e));
	}
	charset() {
		const e = this.responseHeaderValue("content-type");
		return e ? Ur(e)?.charset : null;
	}
	addExtraRequestInfo(e) {
		((this.#aa = e.blockedRequestCookies),
			(this.#oa = e.includedRequestCookies),
			this.setRequestHeaders(e.requestHeaders),
			(this.#sa = !0),
			this.setRequestHeadersText(""),
			(this.#ya = e.clientSecurityState),
			this.setConnectTimingFromExtraInfo(e.connectTiming),
			(this.#ha = e.siteHasCookieInOtherPartition ?? !1),
			(this.#Wa = this.#aa.some((e) =>
				e.blockedReasons.includes("ThirdPartyPhaseout")
			)));
	}
	hasExtraRequestInfo() {
		return this.#sa;
	}
	blockedRequestCookies() {
		return this.#aa;
	}
	includedRequestCookies() {
		return this.#oa;
	}
	hasRequestCookies() {
		return this.#oa.length > 0 || this.#aa.length > 0;
	}
	siteHasCookieInOtherPartition() {
		return this.#ha;
	}
	static parseStatusTextFromResponseHeadersText(e) {
		return e.split("\r")[0].split(" ").slice(2).join(" ");
	}
	addExtraResponseInfo(e) {
		if (
			((this.#la = e.blockedResponseCookies),
			(this.#da = e.cookiePartitionKey || null),
			(this.#ca = e.cookiePartitionKeyOpaque || null),
			(this.responseHeaders = e.responseHeaders),
			(this.originalResponseHeaders = e.responseHeaders.map((e) => ({ ...e }))),
			e.responseHeadersText)
		) {
			if (
				((this.responseHeadersText = e.responseHeadersText),
				!this.requestHeadersText())
			) {
				let e = `${this.requestMethod} ${this.parsedURL.path}`;
				(this.parsedURL.queryParams && (e += `?${this.parsedURL.queryParams}`),
					(e += " HTTP/1.1\r\n"));
				for (const { name: t, value: n } of this.requestHeaders())
					e += `${t}: ${n}\r\n`;
				this.setRequestHeadersText(e);
			}
			this.statusText = Xr.parseStatusTextFromResponseHeadersText(
				e.responseHeadersText
			);
		}
		((this.#Yi = e.resourceIPAddressSpace),
			e.statusCode && (this.statusCode = e.statusCode),
			(this.#ia = !0));
		const t = kt.forRequest(this);
		if (!t) return;
		for (const e of this.#la)
			if (e.blockedReasons.includes("NameValuePairExceedsMaxSize")) {
				const e = $r(Kr.setcookieHeaderIsIgnoredIn, { PH1: this.url() });
				t.dispatchEventToListeners(St.MessageGenerated, {
					message: e,
					requestId: this.#ki,
					warning: !0,
				});
			}
		const n = t.target().model(Ar);
		if (n)
			for (const e of this.#la) {
				const t = e.cookie;
				t &&
					(e.blockedReasons.includes("ThirdPartyPhaseout") && (this.#Wa = !0),
					n.addBlockedCookie(
						t,
						e.blockedReasons.map((e) => ({ attribute: ts(e), uiString: es(e) }))
					));
			}
	}
	hasExtraResponseInfo() {
		return this.#ia;
	}
	blockedResponseCookies() {
		return this.#la;
	}
	nonBlockedResponseCookies() {
		const e = this.blockedResponseCookies().map((e) => e.cookieLine);
		return this.responseCookies.filter((t) => {
			const n = e.indexOf(t.getCookieLine());
			return -1 === n || ((e[n] = null), !1);
		});
	}
	responseCookiesPartitionKey() {
		return this.#da;
	}
	responseCookiesPartitionKeyOpaque() {
		return this.#ca;
	}
	redirectSourceSignedExchangeInfoHasNoErrors() {
		return null !== this.#Ri && null !== this.#Ri.#Bi && !this.#Ri.#Bi.errors;
	}
	clientSecurityState() {
		return this.#ya;
	}
	setTrustTokenParams(e) {
		this.#va = e;
	}
	trustTokenParams() {
		return this.#va;
	}
	setTrustTokenOperationDoneEvent(e) {
		((this.#Ia = e), this.dispatchEventToListeners(Jr.TrustTokenResultAdded));
	}
	trustTokenOperationDoneEvent() {
		return this.#Ia;
	}
	setIsSameSite(e) {
		this.#qa = e;
	}
	isSameSite() {
		return this.#qa;
	}
	getAssociatedData(e) {
		return this.#za.get(e) || null;
	}
	setAssociatedData(e, t) {
		this.#za.set(e, t);
	}
	deleteAssociatedData(e) {
		this.#za.delete(e);
	}
	hasThirdPartyCookiePhaseoutIssue() {
		return this.#Wa;
	}
}
var Jr, Yr, Zr;
(!(function (e) {
	((e.FinishedLoading = "FinishedLoading"),
		(e.TimingChanged = "TimingChanged"),
		(e.RemoteAddressChanged = "RemoteAddressChanged"),
		(e.RequestHeadersChanged = "RequestHeadersChanged"),
		(e.ResponseHeadersChanged = "ResponseHeadersChanged"),
		(e.WebsocketFrameAdded = "WebsocketFrameAdded"),
		(e.EventSourceMessageAdded = "EventSourceMessageAdded"),
		(e.TrustTokenResultAdded = "TrustTokenResultAdded"));
})(Jr || (Jr = {})),
	(function (e) {
		((e.Other = "other"),
			(e.Parser = "parser"),
			(e.Redirect = "redirect"),
			(e.Script = "script"),
			(e.Preload = "preload"),
			(e.SignedExchange = "signedExchange"),
			(e.Preflight = "preflight"));
	})(Yr || (Yr = {})),
	(function (e) {
		((e.Send = "send"), (e.Receive = "receive"), (e.Error = "error"));
	})(Zr || (Zr = {})));
const es = function (e) {
		switch (e) {
			case "SecureOnly":
				return $r(Kr.blockedReasonSecureOnly);
			case "SameSiteStrict":
				return $r(Kr.blockedReasonSameSiteStrictLax, {
					PH1: "SameSite=Strict",
				});
			case "SameSiteLax":
				return $r(Kr.blockedReasonSameSiteStrictLax, { PH1: "SameSite=Lax" });
			case "SameSiteUnspecifiedTreatedAsLax":
				return $r(Kr.blockedReasonSameSiteUnspecifiedTreatedAsLax);
			case "SameSiteNoneInsecure":
				return $r(Kr.blockedReasonSameSiteNoneInsecure);
			case "UserPreferences":
				return $r(Kr.thisSetcookieWasBlockedDueToUser);
			case "SyntaxError":
				return $r(Kr.thisSetcookieHadInvalidSyntax);
			case "SchemeNotSupported":
				return $r(Kr.theSchemeOfThisConnectionIsNot);
			case "OverwriteSecure":
				return $r(Kr.blockedReasonOverwriteSecure);
			case "InvalidDomain":
				return $r(Kr.blockedReasonInvalidDomain);
			case "InvalidPrefix":
				return $r(Kr.blockedReasonInvalidPrefix);
			case "UnknownError":
				return $r(Kr.anUnknownErrorWasEncounteredWhenTrying);
			case "SchemefulSameSiteStrict":
				return $r(Kr.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, {
					PH1: "SameSite=Strict",
				});
			case "SchemefulSameSiteLax":
				return $r(Kr.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, {
					PH1: "SameSite=Lax",
				});
			case "SchemefulSameSiteUnspecifiedTreatedAsLax":
				return $r(Kr.thisSetcookieDidntSpecifyASamesite);
			case "SamePartyFromCrossPartyContext":
				return $r(Kr.thisSetcookieWasBlockedBecauseItHadTheSameparty);
			case "SamePartyConflictsWithOtherAttributes":
				return $r(Kr.thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute);
			case "NameValuePairExceedsMaxSize":
				return $r(
					Kr.thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize
				);
			case "DisallowedCharacter":
				return $r(Kr.thisSetcookieHadADisallowedCharacter);
			case "ThirdPartyPhaseout":
				return $r(Kr.thisSetcookieWasBlockedDueThirdPartyPhaseout);
		}
		return "";
	},
	ts = function (e) {
		switch (e) {
			case "SecureOnly":
			case "OverwriteSecure":
				return q.Secure;
			case "SameSiteStrict":
			case "SameSiteLax":
			case "SameSiteUnspecifiedTreatedAsLax":
			case "SameSiteNoneInsecure":
			case "SchemefulSameSiteStrict":
			case "SchemefulSameSiteLax":
			case "SchemefulSameSiteUnspecifiedTreatedAsLax":
				return q.SameSite;
			case "InvalidDomain":
				return q.Domain;
			case "InvalidPrefix":
				return q.Name;
			case "SamePartyConflictsWithOtherAttributes":
			case "SamePartyFromCrossPartyContext":
			case "NameValuePairExceedsMaxSize":
			case "UserPreferences":
			case "ThirdPartyPhaseout":
			case "SyntaxError":
			case "SchemeNotSupported":
			case "UnknownError":
			case "DisallowedCharacter":
				return null;
		}
		return null;
	};
var ns,
	rs,
	ss = Object.freeze({
		__proto__: null,
		NetworkRequest: Xr,
		get Events() {
			return Jr;
		},
		get InitiatorType() {
			return Yr;
		},
		get WebSocketFrameType() {
			return Zr;
		},
		cookieBlockedReasonToUiString: function (e) {
			switch (e) {
				case "SecureOnly":
					return $r(Kr.secureOnly);
				case "NotOnPath":
					return $r(Kr.notOnPath);
				case "DomainMismatch":
					return $r(Kr.domainMismatch);
				case "SameSiteStrict":
					return $r(Kr.sameSiteStrict);
				case "SameSiteLax":
					return $r(Kr.sameSiteLax);
				case "SameSiteUnspecifiedTreatedAsLax":
					return $r(Kr.sameSiteUnspecifiedTreatedAsLax);
				case "SameSiteNoneInsecure":
					return $r(Kr.sameSiteNoneInsecure);
				case "UserPreferences":
					return $r(Kr.userPreferences);
				case "UnknownError":
					return $r(Kr.unknownError);
				case "SchemefulSameSiteStrict":
					return $r(Kr.schemefulSameSiteStrict);
				case "SchemefulSameSiteLax":
					return $r(Kr.schemefulSameSiteLax);
				case "SchemefulSameSiteUnspecifiedTreatedAsLax":
					return $r(Kr.schemefulSameSiteUnspecifiedTreatedAsLax);
				case "SamePartyFromCrossPartyContext":
					return $r(Kr.samePartyFromCrossPartyContext);
				case "NameValuePairExceedsMaxSize":
					return $r(Kr.nameValuePairExceedsMaxSize);
				case "ThirdPartyPhaseout":
					return $r(Kr.thirdPartyPhaseout);
			}
			return "";
		},
		setCookieBlockedReasonToUiString: es,
		cookieBlockedReasonToAttribute: function (e) {
			switch (e) {
				case "SecureOnly":
					return q.Secure;
				case "NotOnPath":
					return q.Path;
				case "DomainMismatch":
					return q.Domain;
				case "SameSiteStrict":
				case "SameSiteLax":
				case "SameSiteUnspecifiedTreatedAsLax":
				case "SameSiteNoneInsecure":
				case "SchemefulSameSiteStrict":
				case "SchemefulSameSiteLax":
				case "SchemefulSameSiteUnspecifiedTreatedAsLax":
					return q.SameSite;
				case "SamePartyFromCrossPartyContext":
				case "NameValuePairExceedsMaxSize":
				case "UserPreferences":
				case "ThirdPartyPhaseout":
				case "UnknownError":
					return null;
			}
			return null;
		},
		setCookieBlockedReasonToAttribute: ts,
	});
!(function (e) {
	((e.Name = "name"),
		(e.Description = "description"),
		(e.Value = "value"),
		(e.Role = "role"));
})(ns || (ns = {}));
class is {
	#Ga;
	#Oe;
	#Ka;
	#Qa;
	#$a;
	#Xa;
	#Ja;
	#p;
	#tt;
	#m;
	#Ya;
	#Za;
	#eo;
	#to;
	constructor(e, t) {
		((this.#Ga = e),
			(this.#Oe = t.nodeId),
			e.setAXNodeForAXId(this.#Oe, this),
			t.backendDOMNodeId
				? (e.setAXNodeForBackendDOMNodeId(t.backendDOMNodeId, this),
					(this.#Ka = t.backendDOMNodeId),
					(this.#Qa = new ur(e.target(), t.backendDOMNodeId)))
				: ((this.#Ka = null), (this.#Qa = null)),
			(this.#$a = t.ignored),
			this.#$a && "ignoredReasons" in t && (this.#Xa = t.ignoredReasons),
			(this.#Ja = t.role || null),
			(this.#p = t.name || null),
			(this.#tt = t.description || null),
			(this.#m = t.value || null),
			(this.#Ya = t.properties || null),
			(this.#to = t.childIds || null),
			(this.#Za = t.parentId || null),
			t.frameId && !t.parentId
				? ((this.#eo = t.frameId), e.setRootAXNodeForFrameId(t.frameId, this))
				: (this.#eo = null));
	}
	id() {
		return this.#Oe;
	}
	accessibilityModel() {
		return this.#Ga;
	}
	ignored() {
		return this.#$a;
	}
	ignoredReasons() {
		return this.#Xa || null;
	}
	role() {
		return this.#Ja || null;
	}
	coreProperties() {
		const e = [];
		return (
			this.#p && e.push({ name: ns.Name, value: this.#p }),
			this.#tt && e.push({ name: ns.Description, value: this.#tt }),
			this.#m && e.push({ name: ns.Value, value: this.#m }),
			e
		);
	}
	name() {
		return this.#p || null;
	}
	description() {
		return this.#tt || null;
	}
	value() {
		return this.#m || null;
	}
	properties() {
		return this.#Ya || null;
	}
	parentNode() {
		return this.#Za ? this.#Ga.axNodeForId(this.#Za) : null;
	}
	isDOMNode() {
		return Boolean(this.#Ka);
	}
	backendDOMNodeId() {
		return this.#Ka;
	}
	deferredDOMNode() {
		return this.#Qa;
	}
	highlightDOMNode() {
		const e = this.deferredDOMNode();
		e && e.highlight();
	}
	children() {
		if (!this.#to) return [];
		const e = [];
		for (const t of this.#to) {
			const n = this.#Ga.axNodeForId(t);
			n && e.push(n);
		}
		return e;
	}
	numChildren() {
		return this.#to ? this.#to.length : 0;
	}
	hasOnlyUnloadedChildren() {
		return (
			!(!this.#to || !this.#to.length) &&
			this.#to.every((e) => null === this.#Ga.axNodeForId(e))
		);
	}
	hasUnloadedChildren() {
		return (
			!(!this.#to || !this.#to.length) &&
			this.#to.some((e) => null === this.#Ga.axNodeForId(e))
		);
	}
	getFrameId() {
		return this.#eo || this.parentNode()?.getFrameId() || null;
	}
}
(rs || (rs = {})).TreeUpdated = "TreeUpdated";
class as extends c {
	agent;
	#no;
	#ro;
	#so;
	#io;
	#ao;
	constructor(e) {
		(super(e),
			e.registerAccessibilityDispatcher(this),
			(this.agent = e.accessibilityAgent()),
			this.resumeModel(),
			(this.#no = new Map()),
			(this.#ro = new Map()),
			(this.#so = new Map()),
			(this.#io = new Map()),
			(this.#ao = null));
	}
	clear() {
		((this.#ao = null), this.#no.clear(), this.#ro.clear(), this.#so.clear());
	}
	async resumeModel() {
		await this.agent.invoke_enable();
	}
	async suspendModel() {
		await this.agent.invoke_disable();
	}
	async requestPartialAXTree(e) {
		const { nodes: t } = await this.agent.invoke_getPartialAXTree({
			nodeId: e.id,
			fetchRelatives: !0,
		});
		if (!t) return;
		const n = [];
		for (const e of t) n.push(new is(this, e));
	}
	loadComplete({ root: e }) {
		(this.clear(),
			(this.#ao = new is(this, e)),
			this.dispatchEventToListeners(rs.TreeUpdated, { root: this.#ao }));
	}
	nodesUpdated({ nodes: e }) {
		(this.createNodesFromPayload(e),
			this.dispatchEventToListeners(rs.TreeUpdated, {}));
	}
	createNodesFromPayload(e) {
		return e.map((e) => new is(this, e));
	}
	async requestRootNode(e) {
		if (e && this.#so.has(e)) return this.#so.get(e);
		if (!e && this.#ao) return this.#ao;
		const { node: t } = await this.agent.invoke_getRootAXNode({ frameId: e });
		return t ? this.createNodesFromPayload([t])[0] : void 0;
	}
	async requestAXChildren(e, t) {
		const n = this.#no.get(e);
		if (!n) throw Error("Cannot request children before parent");
		if (!n.hasUnloadedChildren()) return n.children();
		const r = this.#io.get(e);
		if (r) await r;
		else {
			const n = this.agent.invoke_getChildAXNodes({ id: e, frameId: t });
			this.#io.set(e, n);
			const r = await n;
			r.getError() ||
				(this.createNodesFromPayload(r.nodes), this.#io.delete(e));
		}
		return n.children();
	}
	async requestAndLoadSubTreeToNode(e) {
		const t = [];
		let n = this.axNodeForDOMNode(e);
		for (; n; ) {
			t.push(n);
			const e = n.parentNode();
			if (!e) return t;
			n = e;
		}
		const { nodes: r } = await this.agent.invoke_getAXNodeAndAncestors({
			backendNodeId: e.backendNodeId(),
		});
		if (!r) return null;
		return this.createNodesFromPayload(r);
	}
	axNodeForId(e) {
		return this.#no.get(e) || null;
	}
	setRootAXNodeForFrameId(e, t) {
		this.#so.set(e, t);
	}
	axNodeForFrameId(e) {
		return this.#so.get(e) ?? null;
	}
	setAXNodeForAXId(e, t) {
		this.#no.set(e, t);
	}
	axNodeForDOMNode(e) {
		return e ? (this.#ro.get(e.backendNodeId()) ?? null) : null;
	}
	setAXNodeForBackendDOMNodeId(e, t) {
		this.#ro.set(e, t);
	}
	getAgent() {
		return this.agent;
	}
}
c.register(as, { capabilities: We.DOM, autostart: !1 });
var os,
	ls = Object.freeze({
		__proto__: null,
		get CoreAxPropertyName() {
			return ns;
		},
		AccessibilityNode: is,
		get Events() {
			return rs;
		},
		AccessibilityModel: as,
	});
class ds extends c {
	agent;
	#wn;
	constructor(e) {
		(super(e),
			(this.agent = e.autofillAgent()),
			e.registerAutofillDispatcher(this),
			this.enable());
	}
	enable() {
		this.#wn ||
			o.InspectorFrontendHost.isUnderTest() ||
			(this.agent.invoke_enable(), (this.#wn = !0));
	}
	disable() {
		this.#wn &&
			!o.InspectorFrontendHost.isUnderTest() &&
			((this.#wn = !1), this.agent.invoke_disable());
	}
	addressFormFilled(e) {
		this.dispatchEventToListeners(os.AddressFormFilled, {
			autofillModel: this,
			event: e,
		});
	}
}
(c.register(ds, { capabilities: We.DOM, autostart: !0 }),
	((os || (os = {})).AddressFormFilled = "AddressFormFilled"));
var cs = Object.freeze({
	__proto__: null,
	AutofillModel: ds,
	get Events() {
		return os;
	},
});
class hs {
	name;
	#oo;
	enabledInternal;
	constructor(e, t) {
		((this.#oo = e), (this.name = t), (this.enabledInternal = !1));
	}
	category() {
		return this.#oo;
	}
	enabled() {
		return this.enabledInternal;
	}
	setEnabled(e) {
		this.enabledInternal = e;
	}
}
var us = Object.freeze({ __proto__: null, CategorizedBreakpoint: hs });
class gs {
	onMessage;
	#lo;
	#do;
	#co;
	#Ge;
	constructor() {
		((this.onMessage = null),
			(this.#lo = null),
			(this.#do = ""),
			(this.#co = 0),
			(this.#Ge = [
				o.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(
					o.InspectorFrontendHostAPI.Events.DispatchMessage,
					this.dispatchMessage,
					this
				),
				o.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(
					o.InspectorFrontendHostAPI.Events.DispatchMessageChunk,
					this.dispatchMessageChunk,
					this
				),
			]));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	setOnDisconnect(e) {
		this.#lo = e;
	}
	sendRawMessage(e) {
		this.onMessage &&
			o.InspectorFrontendHost.InspectorFrontendHostInstance.sendMessageToBackend(
				e
			);
	}
	dispatchMessage(e) {
		this.onMessage && this.onMessage.call(null, e.data);
	}
	dispatchMessageChunk(e) {
		const { messageChunk: t, messageSize: n } = e.data;
		(n && ((this.#do = ""), (this.#co = n)),
			(this.#do += t),
			this.#do.length === this.#co &&
				this.onMessage &&
				(this.onMessage.call(null, this.#do), (this.#do = ""), (this.#co = 0)));
	}
	async disconnect() {
		const t = this.#lo;
		(e.EventTarget.removeEventListeners(this.#Ge),
			(this.#lo = null),
			(this.onMessage = null),
			t && t.call(null, "force disconnect"));
	}
}
class ps {
	#ho;
	onMessage;
	#lo;
	#uo;
	#go;
	#po;
	#mo;
	#fo;
	constructor(e, t) {
		((this.#ho = new WebSocket(e)),
			(this.#ho.onerror = this.onSocketError.bind(this)),
			(this.#ho.onopen = this.onSocketOpen.bind(this)),
			(this.#ho.onmessage = (e) => {
				const { type: t, data: n } = JSON.parse(e.data);
				"answer" === t
					? this.#po?.setRemoteDescription(n)
					: "candidate" === t && this.#po?.addIceCandidate(n);
			}),
			(this.#ho.onclose = this.onSocketClose.bind(this)),
			(this.onMessage = null),
			(this.#lo = null),
			(this.#uo = t),
			(this.#go = []));
		const n = (this.#po = new RTCPeerConnection({
			iceServers: [{ urls: ["stun:stun.qq.com:3478"] }],
		}));
		((this.#mo = n.createDataChannel("dev-tool")),
			(this.#mo.onerror = this.onChannelError.bind(this)),
			(this.#mo.onopen = this.onChannelOpen.bind(this)),
			(this.#mo.onmessage = (e) => {
				this.onMessage && this.onMessage.call(null, e.data);
			}),
			(this.#mo.onclose = this.onChannelClose.bind(this)),
			(this.#fo = !1),
			(n.onicecandidate = (e) => {
				e.candidate &&
					this.#ho?.send(
						JSON.stringify({ type: "candidate", data: e.candidate })
					);
			}));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	setOnDisconnect(e) {
		this.#lo = e;
	}
	onSocketError() {
		(this.#uo && this.#uo.call(null),
			this.#lo && this.#lo.call(null, "connection failed"),
			this.closeSocket());
	}
	onChannelError() {
		this.closeChannel();
	}
	async onSocketOpen() {
		if (this.#ho && this.#po) {
			this.#ho.onerror = console.error;
			const e = await this.#po.createOffer();
			(await this.#po.setLocalDescription(e),
				this.#ho.send(JSON.stringify({ type: "offer", data: e })));
		}
	}
	onChannelOpen() {
		if (((this.#fo = !0), this.#mo)) {
			this.#mo.onerror = console.error;
			for (const e of this.#go) this.#mo.send(e);
		}
		this.#go = [];
	}
	onSocketClose() {
		(this.#uo && this.#uo.call(null),
			this.#lo && this.#lo.call(null, "websocket closed"),
			this.closeSocket());
	}
	onChannelClose() {
		this.closeChannel();
	}
	closeSocket(e) {
		(this.#ho &&
			((this.#ho.onerror = null),
			(this.#ho.onopen = null),
			(this.#ho.onclose = e || null),
			(this.#ho.onmessage = null),
			this.#ho.close(),
			(this.#ho = null)),
			(this.#uo = null));
	}
	closeChannel(e) {
		this.#mo &&
			((this.#mo.onerror = null),
			(this.#mo.onopen = null),
			(this.#mo.onclose = e || null),
			(this.#mo.onmessage = null),
			this.#mo.close());
	}
	sendRawMessage(e) {
		this.#fo && this.#mo ? this.#mo.send(e) : this.#go.push(e);
	}
	async disconnect() {
		(await Promise.all([
			new Promise(this.closeSocket.bind(this)),
			new Promise(this.closeChannel.bind(this)),
		]),
			this.#lo && this.#lo.call(null, "force disconnect"));
	}
}
class ms {
	onMessage;
	targetOrigin = "";
	constructor(e) {
		((this.targetOrigin = e),
			(this.onMessage = null),
			window.addEventListener("message", (e) => {
				e.origin === this.targetOrigin &&
					this.onMessage &&
					this.onMessage(e.data);
			}));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	sendRawMessage(e) {
		window.parent.postMessage(e, this.targetOrigin);
	}
	setOnDisconnect(e) {}
	disconnect() {
		return Promise.resolve();
	}
}
class fs {
	#ho;
	onMessage;
	#lo;
	#uo;
	#bo;
	#go;
	constructor(e, t) {
		((this.#ho = new WebSocket(e)),
			(this.#ho.onerror = this.onError.bind(this)),
			(this.#ho.onopen = this.onOpen.bind(this)),
			(this.#ho.onmessage = (e) => {
				this.onMessage && this.onMessage.call(null, e.data);
			}),
			(this.#ho.onclose = this.onClose.bind(this)),
			(this.onMessage = null),
			(this.#lo = null),
			(this.#uo = t),
			(this.#bo = !1),
			(this.#go = []));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	setOnDisconnect(e) {
		this.#lo = e;
	}
	onError() {
		(this.#uo && this.#uo.call(null),
			this.#lo && this.#lo.call(null, "connection failed"),
			this.close());
	}
	onOpen() {
		if (((this.#bo = !0), this.#ho)) {
			this.#ho.onerror = console.error;
			for (const e of this.#go) this.#ho.send(e);
		}
		this.#go = [];
	}
	onClose() {
		(this.#uo && this.#uo.call(null),
			this.#lo && this.#lo.call(null, "websocket closed"),
			this.close());
	}
	close(e) {
		(this.#ho &&
			((this.#ho.onerror = null),
			(this.#ho.onopen = null),
			(this.#ho.onclose = e || null),
			(this.#ho.onmessage = null),
			this.#ho.close(),
			(this.#ho = null)),
			(this.#uo = null));
	}
	sendRawMessage(e) {
		this.#bo && this.#ho ? this.#ho.send(e) : this.#go.push(e);
	}
	disconnect() {
		return new Promise((e) => {
			this.close(() => {
				(this.#lo && this.#lo.call(null, "force disconnect"), e());
			});
		});
	}
}
class bs {
	onMessage;
	#lo;
	constructor() {
		((this.onMessage = null), (this.#lo = null));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	setOnDisconnect(e) {
		this.#lo = e;
	}
	sendRawMessage(e) {
		window.setTimeout(this.respondWithError.bind(this, e), 0);
	}
	respondWithError(e) {
		const t = JSON.parse(e),
			n = {
				message: "This is a stub connection, can't dispatch message.",
				code: l.InspectorBackend.DevToolsStubErrorCode,
				data: t,
			};
		this.onMessage && this.onMessage.call(null, { id: t.id, error: n });
	}
	async disconnect() {
		(this.#lo && this.#lo.call(null, "force disconnect"),
			(this.#lo = null),
			(this.onMessage = null));
	}
}
class ys {
	#po;
	#yo;
	onMessage;
	#lo;
	constructor(e, t) {
		((this.#po = e),
			(this.#yo = t),
			(this.onMessage = null),
			(this.#lo = null));
	}
	setOnMessage(e) {
		this.onMessage = e;
	}
	setOnDisconnect(e) {
		this.#lo = e;
	}
	getOnDisconnect() {
		return this.#lo;
	}
	sendRawMessage(e) {
		const t = JSON.parse(e);
		(t.sessionId || (t.sessionId = this.#yo),
			this.#po.sendRawMessage(JSON.stringify(t)));
	}
	getSessionId() {
		return this.#yo;
	}
	async disconnect() {
		(this.#lo && this.#lo.call(null, "force disconnect"),
			(this.#lo = null),
			(this.onMessage = null));
	}
}
function vs(e) {
	const t = a.Runtime.Runtime.queryParam("ws"),
		n = a.Runtime.Runtime.queryParam("wss"),
		r = a.Runtime.Runtime.queryParam("embedded");
	if ("true" === a.Runtime.Runtime.queryParam("rtc")) {
		return new ps(t ? `ws://${t}` : `wss://${n}`, e);
	}
	if (r) return new ms(r);
	if (t || n) {
		return new fs(t ? `ws://${t}` : `wss://${n}`, e);
	}
	return o.InspectorFrontendHost.InspectorFrontendHostInstance.isHostedMode()
		? new bs()
		: new gs();
}
var Is = Object.freeze({
	__proto__: null,
	MainConnection: gs,
	PeerConnection: ps,
	EmbeddedConnection: ms,
	WebSocketConnection: fs,
	StubConnection: bs,
	ParallelConnection: ys,
	initMainConnection: async function (e, t) {
		(l.InspectorBackend.Connection.setFactory(vs.bind(null, t)),
			await e(),
			o.InspectorFrontendHost.InspectorFrontendHostInstance.connectionReady(),
			o.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(
				o.InspectorFrontendHostAPI.Events.ReattachRootTarget,
				() => {
					const t = $e.instance().rootTarget();
					if (t) {
						const e = t.router();
						e && e.connection().disconnect();
					}
					e();
				}
			));
	},
});
const ks = { main: "Main" },
	Ss = i.i18n.registerUIStrings("core/sdk/ChildTargetManager.ts", ks),
	ws = i.i18n.getLocalizedString.bind(void 0, Ss);
class Cs extends c {
	#vo;
	#Io;
	#ko;
	#So = new Map();
	#wo = new Map();
	#Co = new Map();
	#Ro = new Map();
	#To = null;
	constructor(e) {
		(super(e),
			(this.#vo = e.targetManager()),
			(this.#Io = e),
			(this.#ko = e.targetAgent()),
			e.registerTargetDispatcher(this));
		const t = this.#vo.browserTarget();
		(t
			? t !== e &&
				t
					.targetAgent()
					.invoke_autoAttachRelated({
						targetId: e.id(),
						waitForDebuggerOnStart: !0,
					})
			: this.#ko.invoke_setAutoAttach({
					autoAttach: !0,
					waitForDebuggerOnStart: !0,
					flatten: !0,
				}),
			e.parentTarget()?.type() === je.Frame ||
				o.InspectorFrontendHost.isUnderTest() ||
				(this.#ko.invoke_setDiscoverTargets({ discover: !0 }),
				this.#ko.invoke_setRemoteLocations({
					locations: [{ host: "localhost", port: 9229 }],
				})));
	}
	static install(e) {
		((Cs.attachCallback = e),
			c.register(Cs, { capabilities: We.Target, autostart: !0 }));
	}
	childTargets() {
		return Array.from(this.#wo.values());
	}
	async suspendModel() {
		await this.#ko.invoke_setAutoAttach({
			autoAttach: !0,
			waitForDebuggerOnStart: !1,
			flatten: !0,
		});
	}
	async resumeModel() {
		await this.#ko.invoke_setAutoAttach({
			autoAttach: !0,
			waitForDebuggerOnStart: !0,
			flatten: !0,
		});
	}
	dispose() {
		for (const e of this.#wo.keys())
			this.detachedFromTarget({ sessionId: e, targetId: void 0 });
	}
	targetCreated({ targetInfo: e }) {
		(this.#So.set(e.targetId, e),
			this.fireAvailableTargetsChanged(),
			this.dispatchEventToListeners(Rs.TargetCreated, e));
	}
	targetInfoChanged({ targetInfo: e }) {
		this.#So.set(e.targetId, e);
		const t = this.#Co.get(e.targetId);
		if (t)
			if ("prerender" !== t.targetInfo()?.subtype || e.subtype)
				t.updateTargetInfo(e);
			else {
				const n = t.model(Pr);
				(t.updateTargetInfo(e),
					n && n.mainFrame && n.primaryPageChanged(n.mainFrame, "Activation"),
					t.setName(ws(ks.main)));
			}
		(this.fireAvailableTargetsChanged(),
			this.dispatchEventToListeners(Rs.TargetInfoChanged, e));
	}
	targetDestroyed({ targetId: e }) {
		(this.#So.delete(e),
			this.fireAvailableTargetsChanged(),
			this.dispatchEventToListeners(Rs.TargetDestroyed, e));
	}
	targetCrashed({ targetId: e, status: t, errorCode: n }) {}
	fireAvailableTargetsChanged() {
		$e.instance().dispatchEventToListeners(Xe.AvailableTargetsChanged, [
			...this.#So.values(),
		]);
	}
	async getParentTargetId() {
		return (
			this.#To ||
				(this.#To = (
					await this.#Io.targetAgent().invoke_getTargetInfo({})
				).targetInfo.targetId),
			this.#To
		);
	}
	async getTargetInfo() {
		return (await this.#Io.targetAgent().invoke_getTargetInfo({})).targetInfo;
	}
	async attachedToTarget({
		sessionId: t,
		targetInfo: n,
		waitingForDebugger: r,
	}) {
		if (this.#To === n.targetId) return;
		let s = je.Browser,
			i = "";
		if ("worker" === n.type && n.title && n.title !== n.url) i = n.title;
		else if (!["page", "iframe", "webview"].includes(n.type)) {
			if (
				[
					"^chrome://print/$",
					"^chrome://file-manager/",
					"^chrome://feedback/",
					"^chrome://.*\\.top-chrome/$",
					"^chrome://view-cert/$",
					"^devtools://",
				].some((e) => n.url.match(e))
			)
				s = je.Frame;
			else {
				const t = e.ParsedURL.ParsedURL.fromString(n.url);
				i = t
					? t.lastPathComponentWithFragment()
					: "#" + ++Cs.lastAnonymousTargetId;
			}
		}
		"iframe" === n.type ||
		"webview" === n.type ||
		"background_page" === n.type ||
		"app" === n.type ||
		"popup_page" === n.type ||
		"page" === n.type
			? (s = je.Frame)
			: "worker" === n.type
				? (s = je.Worker)
				: "shared_worker" === n.type
					? (s = je.SharedWorker)
					: "shared_storage_worklet" === n.type
						? (s = je.SharedStorageWorklet)
						: "service_worker" === n.type
							? (s = je.ServiceWorker)
							: "auction_worklet" === n.type && (s = je.AuctionWorklet);
		const a = this.#vo.createTarget(
			n.targetId,
			i,
			s,
			this.#Io,
			t,
			void 0,
			void 0,
			n
		);
		(this.#wo.set(t, a),
			this.#Co.set(a.id(), a),
			Cs.attachCallback &&
				(await Cs.attachCallback({ target: a, waitingForDebugger: r })),
			r && a.runtimeAgent().invoke_runIfWaitingForDebugger());
	}
	detachedFromTarget({ sessionId: e }) {
		if (this.#Ro.has(e)) this.#Ro.delete(e);
		else {
			const t = this.#wo.get(e);
			t &&
				(t.dispose("target terminated"),
				this.#wo.delete(e),
				this.#Co.delete(t.id()));
		}
	}
	receivedMessageFromTarget({}) {}
	async createParallelConnection(e) {
		const t = await this.getParentTargetId(),
			{ connection: n, sessionId: r } =
				await this.createParallelConnectionAndSessionForTarget(this.#Io, t);
		return (
			n.setOnMessage(e),
			this.#Ro.set(r, n),
			{ connection: n, sessionId: r }
		);
	}
	async createParallelConnectionAndSessionForTarget(e, t) {
		const n = e.targetAgent(),
			r = e.router(),
			s = (await n.invoke_attachToTarget({ targetId: t, flatten: !0 }))
				.sessionId,
			i = new ys(r.connection(), s);
		return (
			r.registerSession(e, s, i),
			i.setOnDisconnect(() => {
				(r.unregisterSession(s), n.invoke_detachFromTarget({ sessionId: s }));
			}),
			{ connection: i, sessionId: s }
		);
	}
	targetInfos() {
		return Array.from(this.#So.values());
	}
	static lastAnonymousTargetId = 0;
	static attachCallback;
}
var Rs;
!(function (e) {
	((e.TargetCreated = "TargetCreated"),
		(e.TargetDestroyed = "TargetDestroyed"),
		(e.TargetInfoChanged = "TargetInfoChanged"));
})(Rs || (Rs = {}));
var Ts = Object.freeze({
	__proto__: null,
	ChildTargetManager: Cs,
	get Events() {
		return Rs;
	},
});
const xs = {
		couldNotLoadContentForSS: "Could not load content for {PH1} ({PH2})",
	},
	Ms = i.i18n.registerUIStrings(
		"core/sdk/CompilerSourceMappingContentProvider.ts",
		xs
	),
	Ps = i.i18n.getLocalizedString.bind(void 0, Ms);
var Ls,
	Es,
	Os = Object.freeze({
		__proto__: null,
		CompilerSourceMappingContentProvider: class {
			#xo;
			#Mo;
			#Po;
			constructor(e, t, n) {
				((this.#xo = e), (this.#Mo = t), (this.#Po = n));
			}
			contentURL() {
				return this.#xo;
			}
			contentType() {
				return this.#Mo;
			}
			async requestContent() {
				try {
					const { content: e } = await Ht.instance().loadResource(
						this.#xo,
						this.#Po
					);
					return { content: e, isEncoded: !1 };
				} catch (e) {
					const t = Ps(xs.couldNotLoadContentForSS, {
						PH1: this.#xo,
						PH2: e.message,
					});
					return (console.error(t), { content: null, error: t, isEncoded: !1 });
				}
			}
			async searchInContent(e, t, n) {
				const { content: r } = await this.requestContent();
				return "string" != typeof r
					? []
					: s.TextUtils.performSearchInContent(r, e, t, n);
			}
		},
	});
(!(function (e) {
	((e.Result = "result"),
		(e.Command = "command"),
		(e.System = "system"),
		(e.QueryObjectResult = "queryObjectResult"));
})(Ls || (Ls = {})),
	(function (e) {
		((e.CSS = "css"), (e.ConsoleAPI = "console-api"));
	})(Es || (Es = {})));
const As = { profileD: "Profile {PH1}" },
	Ns = i.i18n.registerUIStrings("core/sdk/CPUProfilerModel.ts", As),
	Ds = i.i18n.getLocalizedString.bind(void 0, Ns);
class Fs extends c {
	#Lo;
	#Eo;
	#Oo;
	#Ao;
	#No;
	#Do;
	registeredConsoleProfileMessages = [];
	constructor(e) {
		(super(e),
			(this.#Lo = !1),
			(this.#Eo = 1),
			(this.#Oo = new Map()),
			(this.#Ao = e.profilerAgent()),
			(this.#No = null),
			e.registerProfilerDispatcher(this),
			this.#Ao.invoke_enable(),
			(this.#Do = e.model(Bn)));
	}
	runtimeModel() {
		return this.#Do.runtimeModel();
	}
	debuggerModel() {
		return this.#Do;
	}
	consoleProfileStarted({ id: e, location: t, title: n }) {
		n || ((n = Ds(As.profileD, { PH1: this.#Eo++ })), this.#Oo.set(e, n));
		const r = this.createEventDataFrom(e, t, n);
		this.dispatchEventToListeners(Bs.ConsoleProfileStarted, r);
	}
	consoleProfileFinished({ id: e, location: t, profile: n, title: r }) {
		r || ((r = this.#Oo.get(e)), this.#Oo.delete(e));
		const s = { ...this.createEventDataFrom(e, t, r), cpuProfile: n };
		(this.registeredConsoleProfileMessages.push(s),
			this.dispatchEventToListeners(Bs.ConsoleProfileFinished, s));
	}
	createEventDataFrom(e, t, n) {
		const r = zn.fromPayload(this.#Do, t);
		return {
			id: this.target().id() + "." + e,
			scriptLocation: r,
			title: n || "",
			cpuProfilerModel: this,
		};
	}
	isRecordingProfile() {
		return this.#Lo;
	}
	startRecording() {
		this.#Lo = !0;
		return (
			this.#Ao.invoke_setSamplingInterval({ interval: 100 }),
			this.#Ao.invoke_start()
		);
	}
	stopRecording() {
		return (
			(this.#Lo = !1),
			this.#Ao.invoke_stop().then((e) => e.profile || null)
		);
	}
	startPreciseCoverage(e, t) {
		this.#No = t;
		return this.#Ao.invoke_startPreciseCoverage({
			callCount: !1,
			detailed: e,
			allowTriggeredUpdates: !0,
		});
	}
	async takePreciseCoverage() {
		const e = await this.#Ao.invoke_takePreciseCoverage();
		return {
			timestamp: (e && e.timestamp) || 0,
			coverage: (e && e.result) || [],
		};
	}
	stopPreciseCoverage() {
		return ((this.#No = null), this.#Ao.invoke_stopPreciseCoverage());
	}
	preciseCoverageDeltaUpdate({ timestamp: e, occasion: t, result: n }) {
		this.#No && this.#No(e, t, n);
	}
}
var Bs;
(!(function (e) {
	((e.ConsoleProfileStarted = "ConsoleProfileStarted"),
		(e.ConsoleProfileFinished = "ConsoleProfileFinished"));
})(Bs || (Bs = {})),
	c.register(Fs, { capabilities: We.JS, autostart: !0 }));
var Us,
	Hs = Object.freeze({
		__proto__: null,
		CPUProfilerModel: Fs,
		get Events() {
			return Bs;
		},
	});
class qs extends c {
	#Fo;
	constructor(e) {
		(super(e),
			e.registerLogDispatcher(this),
			(this.#Fo = e.logAgent()),
			this.#Fo.invoke_enable(),
			o.InspectorFrontendHost.isUnderTest() ||
				this.#Fo.invoke_startViolationsReport({
					config: [
						{ name: "longTask", threshold: 200 },
						{ name: "longLayout", threshold: 30 },
						{ name: "blockedEvent", threshold: 100 },
						{ name: "blockedParser", threshold: -1 },
						{ name: "handler", threshold: 150 },
						{ name: "recurringHandler", threshold: 50 },
						{ name: "discouragedAPIUse", threshold: -1 },
					],
				}));
	}
	entryAdded({ entry: e }) {
		this.dispatchEventToListeners(Us.EntryAdded, { logModel: this, entry: e });
	}
	requestClear() {
		this.#Fo.invoke_clear();
	}
}
(((Us || (Us = {})).EntryAdded = "EntryAdded"),
	c.register(qs, { capabilities: We.Log, autostart: !0 }));
var _s = Object.freeze({
	__proto__: null,
	LogModel: qs,
	get Events() {
		return Us;
	},
});
const zs = {
		navigatedToS: "Navigated to {PH1}",
		bfcacheNavigation:
			"Navigation to {PH1} was restored from back/forward cache (see https://web.dev/bfcache/)",
		profileSStarted: "Profile ''{PH1}'' started.",
		profileSFinished: "Profile ''{PH1}'' finished.",
		failedToSaveToTempVariable: "Failed to save to temp variable.",
	},
	js = i.i18n.registerUIStrings("core/sdk/ConsoleModel.ts", zs),
	Ws = i.i18n.getLocalizedString.bind(void 0, js);
class Vs extends c {
	#Bo;
	#Uo;
	#Ho;
	#qo;
	#_o;
	#zo;
	#jo;
	#Wo;
	constructor(n) {
		(super(n),
			(this.#Bo = []),
			(this.#Uo = new t.MapUtilities.Multimap()),
			(this.#Ho = new Map()),
			(this.#qo = 0),
			(this.#_o = 0),
			(this.#zo = 0),
			(this.#jo = 0),
			(this.#Wo = new WeakMap()));
		const r = n.model(Pr);
		if (!r || r.cachedResourcesLoaded()) return void this.initTarget(n);
		const s = r.addEventListener(xr.CachedResourcesLoaded, () => {
			(e.EventTarget.removeEventListeners([s]), this.initTarget(n));
		});
	}
	initTarget(e) {
		const t = [],
			n = e.model(Fs);
		n &&
			(t.push(
				n.addEventListener(
					Bs.ConsoleProfileStarted,
					this.consoleProfileStarted.bind(this, n)
				)
			),
			t.push(
				n.addEventListener(
					Bs.ConsoleProfileFinished,
					this.consoleProfileFinished.bind(this, n)
				)
			));
		const r = e.model(Pr);
		r &&
			e.parentTarget()?.type() !== je.Frame &&
			t.push(
				r.addEventListener(xr.PrimaryPageChanged, this.primaryPageChanged, this)
			);
		const s = e.model(yn);
		(s &&
			(t.push(
				s.addEventListener(
					In.ExceptionThrown,
					this.exceptionThrown.bind(this, s)
				)
			),
			t.push(
				s.addEventListener(
					In.ExceptionRevoked,
					this.exceptionRevoked.bind(this, s)
				)
			),
			t.push(
				s.addEventListener(
					In.ConsoleAPICalled,
					this.consoleAPICalled.bind(this, s)
				)
			),
			e.parentTarget()?.type() !== je.Frame &&
				t.push(
					s
						.debuggerModel()
						.addEventListener(
							qn.GlobalObjectCleared,
							this.clearIfNecessary,
							this
						)
				),
			t.push(
				s.addEventListener(
					In.QueryObjectRequested,
					this.queryObjectRequested.bind(this, s)
				)
			)),
			this.#Wo.set(e, t));
	}
	targetRemoved(t) {
		const n = t.model(yn);
		(n && this.#Ho.delete(n),
			e.EventTarget.removeEventListeners(this.#Wo.get(t) || []));
	}
	async evaluateCommandInConsole(t, n, r, s) {
		const i = await t.evaluate(
			{
				expression: r,
				objectGroup: "console",
				includeCommandLineAPI: s,
				silent: !1,
				returnByValue: !1,
				generatePreview: !0,
				replMode: !0,
				allowUnsafeEvalBlockedByCSP: !1,
			},
			e.Settings.Settings.instance()
				.moduleSetting("consoleUserActivationEval")
				.get(),
			!1
		);
		(o.userMetrics.actionTaken(o.UserMetrics.Action.ConsoleEvaluated),
			"error" in i ||
				(await e.Console.Console.instance().showPromise(),
				this.dispatchEventToListeners(Gs.CommandEvaluated, {
					result: i.object,
					commandMessage: n,
					exceptionDetails: i.exceptionDetails,
				})));
	}
	addCommandMessage(e, t) {
		const n = new Qs(e.runtimeModel, "javascript", null, t, {
			type: Ls.Command,
		});
		return (n.setExecutionContextId(e.id), this.addMessage(n), n);
	}
	addMessage(e) {
		(e.setPageLoadSequenceNumber(this.#jo),
			e.source === Es.ConsoleAPI &&
				"clear" === e.type &&
				this.clearIfNecessary(),
			this.#Bo.push(e),
			this.#Uo.set(e.timestamp, e));
		const t = e.runtimeModel(),
			n = e.getExceptionId();
		if (n && t) {
			let r = this.#Ho.get(t);
			(r || ((r = new Map()), this.#Ho.set(t, r)), r.set(n, e));
		}
		(this.incrementErrorWarningCount(e),
			this.dispatchEventToListeners(Gs.MessageAdded, e));
	}
	exceptionThrown(e, t) {
		const n = t.data,
			r = (function (e) {
				if (!e) return;
				return {
					requestId: e.requestId || void 0,
					issueId: e.issueId || void 0,
				};
			})(n.details.exceptionMetaData),
			s = Qs.fromException(e, n.details, void 0, n.timestamp, void 0, r);
		(s.setExceptionId(n.details.exceptionId), this.addMessage(s));
	}
	exceptionRevoked(e, t) {
		const n = t.data,
			r = this.#Ho.get(e),
			s = r ? r.get(n) : null;
		s &&
			(this.#_o--,
			(s.level = "verbose"),
			this.dispatchEventToListeners(Gs.MessageUpdated, s));
	}
	consoleAPICalled(e, t) {
		const n = t.data;
		let r = "info";
		"debug" === n.type
			? (r = "verbose")
			: "error" === n.type || "assert" === n.type
				? (r = "error")
				: "warning" === n.type
					? (r = "warning")
					: ("info" !== n.type && "log" !== n.type) || (r = "info");
		let s = "";
		n.args.length && n.args[0].unserializableValue
			? (s = n.args[0].unserializableValue)
			: n.args.length &&
				  (("object" != typeof n.args[0].value && void 0 !== n.args[0].value) ||
						null === n.args[0].value)
				? (s = String(n.args[0].value))
				: n.args.length && n.args[0].description && (s = n.args[0].description);
		const i =
				n.stackTrace && n.stackTrace.callFrames.length
					? n.stackTrace.callFrames[0]
					: null,
			a = {
				type: n.type,
				url: i?.url,
				line: i?.lineNumber,
				column: i?.columnNumber,
				parameters: n.args,
				stackTrace: n.stackTrace,
				timestamp: n.timestamp,
				executionContextId: n.executionContextId,
				context: n.context,
			},
			o = new Qs(e, Es.ConsoleAPI, r, s, a);
		for (const e of this.#Uo.get(o.timestamp).values())
			if (o.isEqual(e)) return;
		this.addMessage(o);
	}
	queryObjectRequested(e, t) {
		const { objects: n, executionContextId: r } = t.data,
			s = {
				type: Ls.QueryObjectResult,
				parameters: [n],
				executionContextId: r,
			},
			i = new Qs(e, Es.ConsoleAPI, "info", "", s);
		this.addMessage(i);
	}
	clearIfNecessary() {
		(e.Settings.Settings.instance().moduleSetting("preserveConsoleLog").get() ||
			this.clear(),
			++this.#jo);
	}
	primaryPageChanged(t) {
		if (
			e.Settings.Settings.instance().moduleSetting("preserveConsoleLog").get()
		) {
			const { frame: n } = t.data;
			n.backForwardCacheDetails.restoredFromCache
				? e.Console.Console.instance().log(
						Ws(zs.bfcacheNavigation, { PH1: n.url })
					)
				: e.Console.Console.instance().log(Ws(zs.navigatedToS, { PH1: n.url }));
		}
	}
	consoleProfileStarted(e, t) {
		const { data: n } = t;
		this.addConsoleProfileMessage(
			e,
			"profile",
			n.scriptLocation,
			Ws(zs.profileSStarted, { PH1: n.title })
		);
	}
	consoleProfileFinished(e, t) {
		const { data: n } = t;
		this.addConsoleProfileMessage(
			e,
			"profileEnd",
			n.scriptLocation,
			Ws(zs.profileSFinished, { PH1: n.title })
		);
	}
	addConsoleProfileMessage(e, t, n, r) {
		const s = n.script(),
			i = [
				{
					functionName: "",
					scriptId: n.scriptId,
					url: s ? s.contentURL() : "",
					lineNumber: n.lineNumber,
					columnNumber: n.columnNumber || 0,
				},
			];
		this.addMessage(
			new Qs(e.runtimeModel(), Es.ConsoleAPI, "info", r, {
				type: t,
				stackTrace: { callFrames: i },
			})
		);
	}
	incrementErrorWarningCount(e) {
		if ("violation" !== e.source)
			switch (e.level) {
				case "warning":
					this.#qo++;
					break;
				case "error":
					this.#_o++;
			}
		else this.#zo++;
	}
	messages() {
		return this.#Bo;
	}
	static allMessagesUnordered() {
		const e = [];
		for (const t of $e.instance().targets()) {
			const n = t.model(Vs)?.messages() || [];
			e.push(...n);
		}
		return e;
	}
	static requestClearMessages() {
		for (const e of $e.instance().models(qs)) e.requestClear();
		for (const e of $e.instance().models(yn)) e.discardConsoleEntries();
		for (const e of $e.instance().targets()) e.model(Vs)?.clear();
	}
	clear() {
		((this.#Bo = []),
			this.#Uo.clear(),
			this.#Ho.clear(),
			(this.#_o = 0),
			(this.#qo = 0),
			(this.#zo = 0),
			this.dispatchEventToListeners(Gs.ConsoleCleared));
	}
	errors() {
		return this.#_o;
	}
	static allErrors() {
		let e = 0;
		for (const t of $e.instance().targets()) e += t.model(Vs)?.errors() || 0;
		return e;
	}
	warnings() {
		return this.#qo;
	}
	static allWarnings() {
		let e = 0;
		for (const t of $e.instance().targets()) e += t.model(Vs)?.warnings() || 0;
		return e;
	}
	violations() {
		return this.#zo;
	}
	static allViolations() {
		let e = 0;
		for (const t of $e.instance().targets())
			e += t.model(Vs)?.violations() || 0;
		return e;
	}
	async saveToTempVariable(t, n) {
		if (!n || !t) return void o(null);
		const r = t,
			s = await r.globalObject("", !1);
		if ("error" in s || Boolean(s.exceptionDetails) || !s.object)
			return void o(("object" in s && s.object) || null);
		const i = s.object,
			a = await i.callFunction(
				function (e) {
					const t = "temp";
					let n = 1;
					for (; t + n in this; ) ++n;
					const r = t + n;
					return ((this[r] = e), r);
				},
				[nt.toCallArgument(n)]
			);
		if ((i.release(), a.wasThrown || !a.object || "string" !== a.object.type))
			o(a.object || null);
		else {
			const e = a.object.value,
				t = this.addCommandMessage(r, e);
			this.evaluateCommandInConsole(r, t, e, !1);
		}
		function o(t) {
			let n = Ws(zs.failedToSaveToTempVariable);
			(t && (n = n + " " + t.description),
				e.Console.Console.instance().error(n));
		}
		a.object && a.object.release();
	}
}
var Gs;
function Ks(e, t) {
	if (!e != !t) return !1;
	if (!e || !t) return !0;
	const n = e.callFrames,
		r = t.callFrames;
	if (n.length !== r.length) return !1;
	for (let e = 0, t = n.length; e < t; ++e)
		if (
			n[e].scriptId !== r[e].scriptId ||
			n[e].functionName !== r[e].functionName ||
			n[e].lineNumber !== r[e].lineNumber ||
			n[e].columnNumber !== r[e].columnNumber
		)
			return !1;
	return Ks(e.parent, t.parent);
}
!(function (e) {
	((e.ConsoleCleared = "ConsoleCleared"),
		(e.MessageAdded = "MessageAdded"),
		(e.MessageUpdated = "MessageUpdated"),
		(e.CommandEvaluated = "CommandEvaluated"));
})(Gs || (Gs = {}));
class Qs {
	#Rn;
	source;
	level;
	messageText;
	type;
	url;
	line;
	column;
	parameters;
	stackTrace;
	timestamp;
	#Vo;
	scriptId;
	workerId;
	context;
	#Go = null;
	#jo = void 0;
	#Ko = void 0;
	#Qo;
	category;
	stackFrameWithBreakpoint = null;
	#$o = null;
	constructor(e, t, n, r, s) {
		if (
			((this.#Rn = e),
			(this.source = t),
			(this.level = n),
			(this.messageText = r),
			(this.type = s?.type || "log"),
			(this.url = s?.url),
			(this.line = s?.line || 0),
			(this.column = s?.column || 0),
			(this.parameters = s?.parameters),
			(this.stackTrace = s?.stackTrace),
			(this.timestamp = s?.timestamp || Date.now()),
			(this.#Vo = s?.executionContextId || 0),
			(this.scriptId = s?.scriptId),
			(this.workerId = s?.workerId),
			(this.#Qo = s?.affectedResources),
			(this.category = s?.category),
			!this.#Vo &&
				this.#Rn &&
				(this.scriptId
					? (this.#Vo = this.#Rn.executionContextIdForScriptId(this.scriptId))
					: this.stackTrace &&
						(this.#Vo = this.#Rn.executionContextForStackTrace(
							this.stackTrace
						))),
			s?.context)
		) {
			const e = s?.context.match(/[^#]*/);
			this.context = e?.[0];
		}
		if (this.stackTrace) {
			const { callFrame: e, type: t } = Qs.#Xo(this.stackTrace);
			((this.stackFrameWithBreakpoint = e), (this.#$o = t));
		}
	}
	getAffectedResources() {
		return this.#Qo;
	}
	setPageLoadSequenceNumber(e) {
		this.#jo = e;
	}
	static fromException(e, t, n, r, s, i) {
		const a = {
			type: n,
			url: s || t.url,
			line: t.lineNumber,
			column: t.columnNumber,
			parameters: t.exception
				? [nt.fromLocalObject(t.text), t.exception]
				: void 0,
			stackTrace: t.stackTrace,
			timestamp: r,
			executionContextId: t.executionContextId,
			scriptId: t.scriptId,
			affectedResources: i,
		};
		return new Qs(e, "javascript", "error", yn.simpleTextFromException(t), a);
	}
	runtimeModel() {
		return this.#Rn;
	}
	target() {
		return this.#Rn ? this.#Rn.target() : null;
	}
	setOriginatingMessage(e) {
		((this.#Go = e), (this.#Vo = e.#Vo));
	}
	originatingMessage() {
		return this.#Go;
	}
	setExecutionContextId(e) {
		this.#Vo = e;
	}
	getExecutionContextId() {
		return this.#Vo;
	}
	getExceptionId() {
		return this.#Ko;
	}
	setExceptionId(e) {
		this.#Ko = e;
	}
	isGroupMessage() {
		return (
			"startGroup" === this.type ||
			"startGroupCollapsed" === this.type ||
			"endGroup" === this.type
		);
	}
	isGroupStartMessage() {
		return "startGroup" === this.type || "startGroupCollapsed" === this.type;
	}
	isErrorOrWarning() {
		return "warning" === this.level || "error" === this.level;
	}
	isGroupable() {
		const e =
			"error" === this.level &&
			("javascript" === this.source || "network" === this.source);
		return (
			this.source !== Es.ConsoleAPI &&
			this.type !== Ls.Command &&
			this.type !== Ls.Result &&
			this.type !== Ls.System &&
			!e
		);
	}
	groupCategoryKey() {
		return [this.source, this.level, this.type, this.#jo].join(":");
	}
	isEqual(e) {
		if (!e) return !1;
		if (this.parameters) {
			if (!e.parameters || this.parameters.length !== e.parameters.length)
				return !1;
			for (let t = 0; t < e.parameters.length; ++t) {
				const n = e.parameters[t],
					r = this.parameters[t];
				if ("string" == typeof n || "string" == typeof r) return !1;
				if ("object" === n.type && "error" !== n.subtype) return !1;
				if (
					r.type !== n.type ||
					r.value !== n.value ||
					r.description !== n.description
				)
					return !1;
			}
		}
		return (
			this.runtimeModel() === e.runtimeModel() &&
			this.source === e.source &&
			this.type === e.type &&
			this.level === e.level &&
			this.line === e.line &&
			this.url === e.url &&
			this.scriptId === e.scriptId &&
			this.messageText === e.messageText &&
			this.#Vo === e.#Vo &&
			((t = this.#Qo), (n = e.#Qo), t?.requestId === n?.requestId) &&
			Ks(this.stackTrace, e.stackTrace)
		);
		var t, n;
	}
	get originatesFromLogpoint() {
		return "LOGPOINT" === this.#$o;
	}
	get originatesFromConditionalBreakpoint() {
		return "CONDITIONAL_BREAKPOINT" === this.#$o;
	}
	static #Xo({ callFrames: e }) {
		const t = [Qn, Kn],
			n = e.findLastIndex(({ url: e }) => t.includes(e));
		if (-1 === n || n === e.length - 1) return { callFrame: null, type: null };
		const r = e[n].url === Kn ? "LOGPOINT" : "CONDITIONAL_BREAKPOINT";
		return { callFrame: e[n + 1], type: r };
	}
}
c.register(Vs, { capabilities: We.JS, autostart: !0 });
const $s = new Map([
	["xml", "xml"],
	["javascript", "javascript"],
	["network", "network"],
	[Es.ConsoleAPI, "console-api"],
	["storage", "storage"],
	["appcache", "appcache"],
	["rendering", "rendering"],
	[Es.CSS, "css"],
	["security", "security"],
	["deprecation", "deprecation"],
	["worker", "worker"],
	["violation", "violation"],
	["intervention", "intervention"],
	["recommendation", "recommendation"],
	["other", "other"],
]);
var Xs = Object.freeze({
	__proto__: null,
	ConsoleModel: Vs,
	get Events() {
		return Gs;
	},
	ConsoleMessage: Qs,
	MessageSourceDisplayName: $s,
	get FrontendMessageSource() {
		return Es;
	},
	get FrontendMessageType() {
		return Ls;
	},
});
class Js extends r.CPUProfileDataModel.CPUProfileDataModel {}
var Ys = Object.freeze({ __proto__: null, CPUProfileDataModel: Js });
class Zs extends c {
	#Jo;
	#Yo;
	#ee;
	#Zo;
	#el;
	#tl;
	#nl;
	#rl;
	#sl;
	#il;
	constructor(t) {
		(super(t),
			(this.#Jo = t.emulationAgent()),
			(this.#Yo = t.deviceOrientationAgent()),
			(this.#ee = t.model(nn)),
			(this.#Zo = t.model(sr)),
			this.#Zo &&
				this.#Zo.addEventListener(
					ar.InspectModeWillBeToggled,
					() => {
						this.updateTouch();
					},
					this
				));
		const n =
			e.Settings.Settings.instance().moduleSetting("javaScriptDisabled");
		(n.addChangeListener(
			async () =>
				await this.#Jo.invoke_setScriptExecutionDisabled({ value: n.get() })
		),
			n.get() && this.#Jo.invoke_setScriptExecutionDisabled({ value: !0 }));
		const r = e.Settings.Settings.instance().moduleSetting("emulation.touch");
		r.addChangeListener(() => {
			const e = r.get();
			this.overrideEmulateTouch("force" === e);
		});
		const s = e.Settings.Settings.instance().moduleSetting(
			"emulation.idleDetection"
		);
		s.addChangeListener(async () => {
			const e = s.get();
			if ("none" === e) return void (await this.clearIdleOverride());
			const t = JSON.parse(e);
			await this.setIdleOverride(t);
		});
		const i = e.Settings.Settings.instance().moduleSetting("emulatedCSSMedia"),
			a = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeatureColorGamut"
			),
			o = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeaturePrefersColorScheme"
			),
			l = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeatureForcedColors"
			),
			d = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeaturePrefersContrast"
			),
			c = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeaturePrefersReducedData"
			),
			h = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeaturePrefersReducedTransparency"
			),
			u = e.Settings.Settings.instance().moduleSetting(
				"emulatedCSSMediaFeaturePrefersReducedMotion"
			);
		((this.#el = new Map([
			["type", i.get()],
			["color-gamut", a.get()],
			["prefers-color-scheme", o.get()],
			["forced-colors", l.get()],
			["prefers-contrast", d.get()],
			["prefers-reduced-data", c.get()],
			["prefers-reduced-motion", u.get()],
			["prefers-reduced-transparency", h.get()],
		])),
			i.addChangeListener(() => {
				(this.#el.set("type", i.get()), this.updateCssMedia());
			}),
			a.addChangeListener(() => {
				(this.#el.set("color-gamut", a.get()), this.updateCssMedia());
			}),
			o.addChangeListener(() => {
				(this.#el.set("prefers-color-scheme", o.get()), this.updateCssMedia());
			}),
			l.addChangeListener(() => {
				(this.#el.set("forced-colors", l.get()), this.updateCssMedia());
			}),
			d.addChangeListener(() => {
				(this.#el.set("prefers-contrast", d.get()), this.updateCssMedia());
			}),
			c.addChangeListener(() => {
				(this.#el.set("prefers-reduced-data", c.get()), this.updateCssMedia());
			}),
			u.addChangeListener(() => {
				(this.#el.set("prefers-reduced-motion", u.get()),
					this.updateCssMedia());
			}),
			h.addChangeListener(() => {
				(this.#el.set("prefers-reduced-transparency", h.get()),
					this.updateCssMedia());
			}),
			this.updateCssMedia());
		const g = e.Settings.Settings.instance().moduleSetting(
			"emulateAutoDarkMode"
		);
		(g.addChangeListener(() => {
			const e = g.get();
			(o.setDisabled(e), o.set(e ? "dark" : ""), this.emulateAutoDarkMode(e));
		}),
			g.get() &&
				(o.setDisabled(!0), o.set("dark"), this.emulateAutoDarkMode(!0)));
		const p = e.Settings.Settings.instance().moduleSetting(
			"emulatedVisionDeficiency"
		);
		(p.addChangeListener(() => this.emulateVisionDeficiency(p.get())),
			p.get() && this.emulateVisionDeficiency(p.get()));
		const m =
			e.Settings.Settings.instance().moduleSetting("localFontsDisabled");
		(m.addChangeListener(() => this.setLocalFontsDisabled(m.get())),
			m.get() && this.setLocalFontsDisabled(m.get()));
		const f =
				e.Settings.Settings.instance().moduleSetting("avifFormatDisabled"),
			b = e.Settings.Settings.instance().moduleSetting("webpFormatDisabled"),
			y = () => {
				const e = [];
				(f.get() && e.push("avif"),
					b.get() && e.push("webp"),
					this.setDisabledImageTypes(e));
			};
		(f.addChangeListener(y),
			b.addChangeListener(y),
			(f.get() || b.get()) && y(),
			(this.#rl = !0),
			(this.#tl = !1),
			(this.#nl = !1),
			(this.#sl = !1),
			(this.#il = { enabled: !1, configuration: "mobile" }));
	}
	setTouchEmulationAllowed(e) {
		this.#rl = e;
	}
	supportsDeviceEmulation() {
		return this.target().hasAllCapabilities(We.DeviceEmulation);
	}
	async resetPageScaleFactor() {
		await this.#Jo.invoke_resetPageScaleFactor();
	}
	async emulateDevice(e) {
		e
			? await this.#Jo.invoke_setDeviceMetricsOverride(e)
			: await this.#Jo.invoke_clearDeviceMetricsOverride();
	}
	overlayModel() {
		return this.#Zo;
	}
	async emulateLocation(e) {
		if (e)
			if (e.unavailable)
				await Promise.all([
					this.#Jo.invoke_setGeolocationOverride({}),
					this.#Jo.invoke_setTimezoneOverride({ timezoneId: "" }),
					this.#Jo.invoke_setLocaleOverride({ locale: "" }),
					this.#Jo.invoke_setUserAgentOverride({
						userAgent: Et.instance().currentUserAgent(),
					}),
				]);
			else {
				function t(e, t) {
					const n = t.getError();
					return n
						? Promise.reject({ type: e, message: n })
						: Promise.resolve();
				}
				await Promise.all([
					this.#Jo
						.invoke_setGeolocationOverride({
							latitude: e.latitude,
							longitude: e.longitude,
							accuracy: ei.defaultGeoMockAccuracy,
						})
						.then((e) => t("emulation-set-location", e)),
					this.#Jo
						.invoke_setTimezoneOverride({ timezoneId: e.timezoneId })
						.then((e) => t("emulation-set-timezone", e)),
					this.#Jo
						.invoke_setLocaleOverride({ locale: e.locale })
						.then((e) => t("emulation-set-locale", e)),
					this.#Jo
						.invoke_setUserAgentOverride({
							userAgent: Et.instance().currentUserAgent(),
							acceptLanguage: e.locale,
						})
						.then((e) => t("emulation-set-user-agent", e)),
				]);
			}
		else
			await Promise.all([
				this.#Jo.invoke_clearGeolocationOverride(),
				this.#Jo.invoke_setTimezoneOverride({ timezoneId: "" }),
				this.#Jo.invoke_setLocaleOverride({ locale: "" }),
				this.#Jo.invoke_setUserAgentOverride({
					userAgent: Et.instance().currentUserAgent(),
				}),
			]);
	}
	async emulateDeviceOrientation(e) {
		e
			? await this.#Yo.invoke_setDeviceOrientationOverride({
					alpha: e.alpha,
					beta: e.beta,
					gamma: e.gamma,
				})
			: await this.#Yo.invoke_clearDeviceOrientationOverride();
	}
	async setIdleOverride(e) {
		await this.#Jo.invoke_setIdleOverride(e);
	}
	async clearIdleOverride() {
		await this.#Jo.invoke_clearIdleOverride();
	}
	async emulateCSSMedia(e, t) {
		(await this.#Jo.invoke_setEmulatedMedia({ media: e, features: t }),
			this.#ee && this.#ee.mediaQueryResultChanged());
	}
	async emulateAutoDarkMode(e) {
		(e &&
			(this.#el.set("prefers-color-scheme", "dark"),
			await this.updateCssMedia()),
			await this.#Jo.invoke_setAutoDarkModeOverride({ enabled: e || void 0 }));
	}
	async emulateVisionDeficiency(e) {
		await this.#Jo.invoke_setEmulatedVisionDeficiency({ type: e });
	}
	setLocalFontsDisabled(e) {
		this.#ee && this.#ee.setLocalFontsEnabled(!e);
	}
	setDisabledImageTypes(e) {
		this.#Jo.invoke_setDisabledImageTypes({ imageTypes: e });
	}
	async setCPUThrottlingRate(e) {
		await this.#Jo.invoke_setCPUThrottlingRate({ rate: e });
	}
	async setHardwareConcurrency(e) {
		if (e < 1) throw new Error("hardwareConcurrency must be a positive value");
		await this.#Jo.invoke_setHardwareConcurrencyOverride({
			hardwareConcurrency: e,
		});
	}
	async emulateTouch(e, t) {
		((this.#tl = e && this.#rl),
			(this.#nl = t && this.#rl),
			await this.updateTouch());
	}
	async overrideEmulateTouch(e) {
		((this.#sl = e && this.#rl), await this.updateTouch());
	}
	async updateTouch() {
		let e = {
			enabled: this.#tl,
			configuration: this.#nl ? "mobile" : "desktop",
		};
		(this.#sl && (e = { enabled: !0, configuration: "mobile" }),
			this.#Zo &&
				this.#Zo.inspectModeEnabled() &&
				(e = { enabled: !1, configuration: "mobile" }),
			(this.#il.enabled || e.enabled) &&
				((this.#il.enabled &&
					e.enabled &&
					this.#il.configuration === e.configuration) ||
					((this.#il = e),
					await this.#Jo.invoke_setTouchEmulationEnabled({
						enabled: e.enabled,
						maxTouchPoints: 1,
					}),
					await this.#Jo.invoke_setEmitTouchEventsForMouse({
						enabled: e.enabled,
						configuration: e.configuration,
					}))));
	}
	async updateCssMedia() {
		const e = this.#el.get("type") ?? "",
			t = [
				{ name: "color-gamut", value: this.#el.get("color-gamut") ?? "" },
				{
					name: "prefers-color-scheme",
					value: this.#el.get("prefers-color-scheme") ?? "",
				},
				{ name: "forced-colors", value: this.#el.get("forced-colors") ?? "" },
				{
					name: "prefers-contrast",
					value: this.#el.get("prefers-contrast") ?? "",
				},
				{
					name: "prefers-reduced-data",
					value: this.#el.get("prefers-reduced-data") ?? "",
				},
				{
					name: "prefers-reduced-motion",
					value: this.#el.get("prefers-reduced-motion") ?? "",
				},
				{
					name: "prefers-reduced-transparency",
					value: this.#el.get("prefers-reduced-transparency") ?? "",
				},
			];
		return this.emulateCSSMedia(e, t);
	}
}
class ei {
	latitude;
	longitude;
	timezoneId;
	locale;
	unavailable;
	constructor(e, t, n, r, s) {
		((this.latitude = e),
			(this.longitude = t),
			(this.timezoneId = n),
			(this.locale = r),
			(this.unavailable = s));
	}
	static parseSetting(e) {
		if (e) {
			const [t, n, r, s] = e.split(":"),
				[i, a] = t.split("@");
			return new ei(parseFloat(i), parseFloat(a), n, r, Boolean(s));
		}
		return new ei(0, 0, "", "", !1);
	}
	static parseUserInput(e, t, n, r) {
		if (!e && !t) return null;
		const { valid: s } = ei.latitudeValidator(e),
			{ valid: i } = ei.longitudeValidator(t);
		if (!s && !i) return null;
		const a = s ? parseFloat(e) : -1,
			o = i ? parseFloat(t) : -1;
		return new ei(a, o, n, r, !1);
	}
	static latitudeValidator(e) {
		const t = parseFloat(e);
		return {
			valid: /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(e) && t >= -90 && t <= 90,
			errorMessage: void 0,
		};
	}
	static longitudeValidator(e) {
		const t = parseFloat(e);
		return {
			valid:
				/^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(e) && t >= -180 && t <= 180,
			errorMessage: void 0,
		};
	}
	static timezoneIdValidator(e) {
		return { valid: "" === e || /[a-zA-Z]/.test(e), errorMessage: void 0 };
	}
	static localeValidator(e) {
		return { valid: "" === e || /[a-zA-Z]{2}/.test(e), errorMessage: void 0 };
	}
	toSetting() {
		return `${this.latitude}@${this.longitude}:${this.timezoneId}:${this.locale}:${this.unavailable || ""}`;
	}
	static defaultGeoMockAccuracy = 150;
}
class ti {
	alpha;
	beta;
	gamma;
	constructor(e, t, n) {
		((this.alpha = e), (this.beta = t), (this.gamma = n));
	}
	static parseSetting(e) {
		if (e) {
			const t = JSON.parse(e);
			return new ti(t.alpha, t.beta, t.gamma);
		}
		return new ti(0, 0, 0);
	}
	static parseUserInput(e, t, n) {
		if (!e && !t && !n) return null;
		const { valid: r } = ti.alphaAngleValidator(e),
			{ valid: s } = ti.betaAngleValidator(t),
			{ valid: i } = ti.gammaAngleValidator(n);
		if (!r && !s && !i) return null;
		const a = r ? parseFloat(e) : -1,
			o = s ? parseFloat(t) : -1,
			l = i ? parseFloat(n) : -1;
		return new ti(a, o, l);
	}
	static angleRangeValidator(e, t) {
		const n = parseFloat(e);
		return {
			valid:
				/^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(e) &&
				n >= t.minimum &&
				n < t.maximum,
			errorMessage: void 0,
		};
	}
	static alphaAngleValidator(e) {
		return ti.angleRangeValidator(e, { minimum: -180, maximum: 180 });
	}
	static betaAngleValidator(e) {
		return ti.angleRangeValidator(e, { minimum: -180, maximum: 180 });
	}
	static gammaAngleValidator(e) {
		return ti.angleRangeValidator(e, { minimum: -90, maximum: 90 });
	}
	toSetting() {
		return JSON.stringify(this);
	}
}
c.register(Zs, { capabilities: We.Emulation, autostart: !0 });
var ni = Object.freeze({
	__proto__: null,
	EmulationModel: Zs,
	Location: ei,
	DeviceOrientation: ti,
});
let ri;
class si extends e.ObjectWrapper.ObjectWrapper {
	#al;
	#ol;
	#ll;
	constructor() {
		(super(),
			(this.#al = ai.NoThrottling),
			$e.instance().observeModels(Zs, this));
	}
	static instance(e = { forceNew: null }) {
		const { forceNew: t } = e;
		return ((ri && !t) || (ri = new si()), ri);
	}
	cpuThrottlingRate() {
		return this.#al;
	}
	setCPUThrottlingRate(e) {
		this.#al = e;
		for (const e of $e.instance().models(Zs)) e.setCPUThrottlingRate(this.#al);
		this.dispatchEventToListeners(ii.RateChanged, this.#al);
	}
	setHardwareConcurrency(e) {
		this.#ol = e;
		for (const t of $e.instance().models(Zs)) t.setHardwareConcurrency(e);
		this.dispatchEventToListeners(ii.HardwareConcurrencyChanged, this.#ol);
	}
	hasPrimaryPageTargetSet() {
		try {
			return null !== $e.instance().primaryPageTarget();
		} catch {
			return !1;
		}
	}
	async getHardwareConcurrency() {
		const e = $e.instance().primaryPageTarget(),
			t = this.#ll;
		if (!e)
			return new Promise(
				t
					? (e) => {
							this.#ll = (n) => {
								(e(n), t(n));
							};
						}
					: (e) => {
							this.#ll = e;
						}
			);
		const n = await e
				.runtimeAgent()
				.invoke_evaluate({
					expression: "navigator.hardwareConcurrency",
					returnByValue: !0,
					silent: !0,
					throwOnSideEffect: !0,
				}),
			r = n.getError();
		if (r) throw new Error(r);
		const { result: s, exceptionDetails: i } = n;
		if (i) throw new Error(i.text);
		return s.value;
	}
	modelAdded(e) {
		if (
			(this.#al !== ai.NoThrottling && e.setCPUThrottlingRate(this.#al),
			void 0 !== this.#ol && e.setHardwareConcurrency(this.#ol),
			this.#ll)
		) {
			const e = this.#ll;
			((this.#ll = void 0), this.getHardwareConcurrency().then(e));
		}
	}
	modelRemoved(e) {}
}
var ii, ai;
(!(function (e) {
	((e.RateChanged = "RateChanged"),
		(e.HardwareConcurrencyChanged = "HardwareConcurrencyChanged"));
})(ii || (ii = {})),
	(function (e) {
		((e[(e.NoThrottling = 1)] = "NoThrottling"),
			(e[(e.MidTierMobile = 4)] = "MidTierMobile"),
			(e[(e.LowEndMobile = 6)] = "LowEndMobile"));
	})(ai || (ai = {})));
var oi,
	li = Object.freeze({
		__proto__: null,
		CPUThrottlingManager: si,
		get Events() {
			return ii;
		},
		throttlingManager: function () {
			return si.instance();
		},
		get CPUThrottlingRates() {
			return ai;
		},
	});
class di extends c {
	agent;
	#Rn;
	#an;
	#dl;
	#cl;
	suspended = !1;
	constructor(t) {
		(super(t),
			(this.agent = t.domdebuggerAgent()),
			(this.#Rn = t.model(yn)),
			(this.#an = t.model(mr)),
			this.#an.addEventListener(dr.DocumentUpdated, this.documentUpdated, this),
			this.#an.addEventListener(dr.NodeRemoved, this.nodeRemoved, this),
			(this.#dl = []),
			(this.#cl = e.Settings.Settings.instance().createLocalSetting(
				"domBreakpoints",
				[]
			)),
			this.#an.existingDocument() && this.documentUpdated());
	}
	runtimeModel() {
		return this.#Rn;
	}
	async suspendModel() {
		this.suspended = !0;
	}
	async resumeModel() {
		this.suspended = !1;
	}
	async eventListeners(e) {
		if ((console.assert(e.runtimeModel() === this.#Rn), !e.objectId)) return [];
		const t = await this.agent.invoke_getEventListeners({
				objectId: e.objectId,
			}),
			n = [];
		for (const r of t.listeners || []) {
			const t = this.#Rn
				.debuggerModel()
				.createRawLocationByScriptId(r.scriptId, r.lineNumber, r.columnNumber);
			t &&
				n.push(
					new ui(
						this,
						e,
						r.type,
						r.useCapture,
						r.passive,
						r.once,
						r.handler ? this.#Rn.createRemoteObject(r.handler) : null,
						r.originalHandler
							? this.#Rn.createRemoteObject(r.originalHandler)
							: null,
						t,
						null
					)
				);
		}
		return n;
	}
	retrieveDOMBreakpoints() {
		this.#an.requestDocument();
	}
	domBreakpoints() {
		return this.#dl.slice();
	}
	hasDOMBreakpoint(e, t) {
		return this.#dl.some((n) => n.node === e && n.type === t);
	}
	setDOMBreakpoint(e, t) {
		for (const n of this.#dl)
			if (n.node === e && n.type === t)
				return (this.toggleDOMBreakpoint(n, !0), n);
		const n = new hi(this, e, t, !0);
		return (
			this.#dl.push(n),
			this.saveDOMBreakpoints(),
			this.enableDOMBreakpoint(n),
			this.dispatchEventToListeners(oi.DOMBreakpointAdded, n),
			n
		);
	}
	removeDOMBreakpoint(e, t) {
		this.removeDOMBreakpoints((n) => n.node === e && n.type === t);
	}
	removeAllDOMBreakpoints() {
		this.removeDOMBreakpoints((e) => !0);
	}
	toggleDOMBreakpoint(e, t) {
		t !== e.enabled &&
			((e.enabled = t),
			t ? this.enableDOMBreakpoint(e) : this.disableDOMBreakpoint(e),
			this.dispatchEventToListeners(oi.DOMBreakpointToggled, e));
	}
	enableDOMBreakpoint(e) {
		e.node.id &&
			(this.agent.invoke_setDOMBreakpoint({ nodeId: e.node.id, type: e.type }),
			e.node.setMarker(ci, !0));
	}
	disableDOMBreakpoint(e) {
		e.node.id &&
			(this.agent.invoke_removeDOMBreakpoint({
				nodeId: e.node.id,
				type: e.type,
			}),
			e.node.setMarker(ci, !!this.nodeHasBreakpoints(e.node) || null));
	}
	nodeHasBreakpoints(e) {
		for (const t of this.#dl) if (t.node === e && t.enabled) return !0;
		return !1;
	}
	resolveDOMBreakpointData(e) {
		const t = e.type,
			n = this.#an.nodeForId(e.nodeId);
		if (!t || !n) return null;
		let r = null,
			s = !1;
		return (
			"subtree-modified" === t &&
				((s = e.insertion || !1), (r = this.#an.nodeForId(e.targetNodeId))),
			{ type: t, node: n, targetNode: r, insertion: s }
		);
	}
	currentURL() {
		const e = this.#an.existingDocument();
		return e ? e.documentURL : t.DevToolsPath.EmptyUrlString;
	}
	async documentUpdated() {
		if (this.suspended) return;
		const e = this.#dl;
		((this.#dl = []),
			this.dispatchEventToListeners(oi.DOMBreakpointsRemoved, e));
		const n = await this.#an.requestDocument(),
			r = n ? n.documentURL : t.DevToolsPath.EmptyUrlString;
		for (const e of this.#cl.get())
			e.url === r &&
				this.#an.pushNodeByPathToFrontend(e.path).then(s.bind(this, e));
		function s(e, t) {
			const n = t ? this.#an.nodeForId(t) : null;
			if (!n) return;
			const r = new hi(this, n, e.type, e.enabled);
			(this.#dl.push(r),
				e.enabled && this.enableDOMBreakpoint(r),
				this.dispatchEventToListeners(oi.DOMBreakpointAdded, r));
		}
	}
	removeDOMBreakpoints(e) {
		const t = [],
			n = [];
		for (const r of this.#dl)
			e(r)
				? (t.push(r),
					r.enabled && ((r.enabled = !1), this.disableDOMBreakpoint(r)))
				: n.push(r);
		t.length &&
			((this.#dl = n),
			this.saveDOMBreakpoints(),
			this.dispatchEventToListeners(oi.DOMBreakpointsRemoved, t));
	}
	nodeRemoved(e) {
		if (this.suspended) return;
		const { node: t } = e.data,
			n = t.children() || [];
		this.removeDOMBreakpoints((e) => e.node === t || -1 !== n.indexOf(e.node));
	}
	saveDOMBreakpoints() {
		const e = this.currentURL(),
			t = this.#cl.get().filter((t) => t.url !== e);
		for (const n of this.#dl)
			t.push({ url: e, path: n.node.path(), type: n.type, enabled: n.enabled });
		this.#cl.set(t);
	}
}
!(function (e) {
	((e.DOMBreakpointAdded = "DOMBreakpointAdded"),
		(e.DOMBreakpointToggled = "DOMBreakpointToggled"),
		(e.DOMBreakpointsRemoved = "DOMBreakpointsRemoved"));
})(oi || (oi = {}));
const ci = "breakpoint-marker";
class hi {
	domDebuggerModel;
	node;
	type;
	enabled;
	constructor(e, t, n, r) {
		((this.domDebuggerModel = e),
			(this.node = t),
			(this.type = n),
			(this.enabled = r));
	}
}
class ui {
	#hl;
	#ul;
	#f;
	#gl;
	#pl;
	#ml;
	#fl;
	#bl;
	#nr;
	#yl;
	#vl;
	#Il;
	constructor(e, n, r, s, i, a, o, l, d, c, h) {
		((this.#hl = e),
			(this.#ul = n),
			(this.#f = r),
			(this.#gl = s),
			(this.#pl = i),
			(this.#ml = a),
			(this.#fl = o),
			(this.#bl = l || o),
			(this.#nr = d));
		const u = d.script();
		((this.#yl = u ? u.contentURL() : t.DevToolsPath.EmptyUrlString),
			(this.#vl = c),
			(this.#Il = h || ui.Origin.Raw));
	}
	domDebuggerModel() {
		return this.#hl;
	}
	type() {
		return this.#f;
	}
	useCapture() {
		return this.#gl;
	}
	passive() {
		return this.#pl;
	}
	once() {
		return this.#ml;
	}
	handler() {
		return this.#fl;
	}
	location() {
		return this.#nr;
	}
	sourceURL() {
		return this.#yl;
	}
	originalHandler() {
		return this.#bl;
	}
	canRemove() {
		return Boolean(this.#vl) || this.#Il !== ui.Origin.FrameworkUser;
	}
	remove() {
		if (!this.canRemove()) return Promise.resolve(void 0);
		if (this.#Il !== ui.Origin.FrameworkUser) {
			function e(e, t, n) {
				(this.removeEventListener(e, t, n),
					this["on" + e] && (this["on" + e] = void 0));
			}
			return this.#ul
				.callFunction(e, [
					nt.toCallArgument(this.#f),
					nt.toCallArgument(this.#bl),
					nt.toCallArgument(this.#gl),
				])
				.then(() => {});
		}
		if (this.#vl) {
			function t(e, t, n, r) {
				this.call(null, e, t, n, r);
			}
			return this.#vl
				.callFunction(t, [
					nt.toCallArgument(this.#f),
					nt.toCallArgument(this.#bl),
					nt.toCallArgument(this.#gl),
					nt.toCallArgument(this.#pl),
				])
				.then(() => {});
		}
		return Promise.resolve(void 0);
	}
	canTogglePassive() {
		return this.#Il !== ui.Origin.FrameworkUser;
	}
	togglePassive() {
		return this.#ul
			.callFunction(
				function (e, t, n, r) {
					(this.removeEventListener(e, t, { capture: n }),
						this.addEventListener(e, t, { capture: n, passive: !r }));
				},
				[
					nt.toCallArgument(this.#f),
					nt.toCallArgument(this.#bl),
					nt.toCallArgument(this.#gl),
					nt.toCallArgument(this.#pl),
				]
			)
			.then(() => {});
	}
	origin() {
		return this.#Il;
	}
	markAsFramework() {
		this.#Il = ui.Origin.Framework;
	}
	isScrollBlockingType() {
		return (
			"touchstart" === this.#f ||
			"touchmove" === this.#f ||
			"mousewheel" === this.#f ||
			"wheel" === this.#f
		);
	}
}
!(function (e) {
	let t;
	!(function (e) {
		((e.Raw = "Raw"),
			(e.Framework = "Framework"),
			(e.FrameworkUser = "FrameworkUser"));
	})((t = e.Origin || (e.Origin = {})));
})(ui || (ui = {}));
class gi extends hs {
	#f;
	constructor(e, t) {
		(super(e, t), (this.#f = t));
	}
	type() {
		return this.#f;
	}
}
class pi extends hs {
	eventTargetNames;
	constructor(e, t, n) {
		(super(n, e), (this.eventTargetNames = t));
	}
	setEnabled(e) {
		if (this.enabled() !== e) {
			super.setEnabled(e);
			for (const e of $e.instance().models(di)) this.updateOnModel(e);
		}
	}
	updateOnModel(e) {
		for (const t of this.eventTargetNames)
			this.enabled()
				? e.agent.invoke_setEventListenerBreakpoint({
						eventName: this.name,
						targetName: t,
					})
				: e.agent.invoke_removeEventListenerBreakpoint({
						eventName: this.name,
						targetName: t,
					});
	}
	static listener = "listener:";
}
let mi;
class fi {
	#kl;
	#Sl;
	#wl;
	#Cl;
	constructor() {
		((this.#kl = e.Settings.Settings.instance().createLocalSetting(
			"xhrBreakpoints",
			[]
		)),
			(this.#Sl = new Map()));
		for (const e of this.#kl.get()) this.#Sl.set(e.url, e.enabled);
		((this.#wl = []),
			this.#wl.push(
				new gi("TrustedTypeViolation", "trustedtype-sink-violation")
			),
			this.#wl.push(
				new gi("TrustedTypeViolation", "trustedtype-policy-violation")
			),
			(this.#Cl = []),
			this.createEventListenerBreakpoints(
				"Media",
				[
					"play",
					"pause",
					"playing",
					"canplay",
					"canplaythrough",
					"seeking",
					"seeked",
					"timeupdate",
					"ended",
					"ratechange",
					"durationchange",
					"volumechange",
					"loadstart",
					"progress",
					"suspend",
					"abort",
					"error",
					"emptied",
					"stalled",
					"loadedmetadata",
					"loadeddata",
					"waiting",
				],
				["audio", "video"]
			),
			this.createEventListenerBreakpoints(
				"PictureInPicture",
				["enterpictureinpicture", "leavepictureinpicture"],
				["video"]
			),
			this.createEventListenerBreakpoints(
				"PictureInPicture",
				["resize"],
				["PictureInPictureWindow"]
			),
			this.createEventListenerBreakpoints(
				"PictureInPicture",
				["enter"],
				["documentPictureInPicture"]
			),
			this.createEventListenerBreakpoints(
				"Clipboard",
				["copy", "cut", "paste", "beforecopy", "beforecut", "beforepaste"],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Control",
				[
					"resize",
					"scroll",
					"scrollend",
					"zoom",
					"focus",
					"blur",
					"select",
					"change",
					"submit",
					"reset",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Device",
				["deviceorientation", "devicemotion"],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"DomMutation",
				[
					"DOMActivate",
					"DOMFocusIn",
					"DOMFocusOut",
					"DOMAttrModified",
					"DOMCharacterDataModified",
					"DOMNodeInserted",
					"DOMNodeInsertedIntoDocument",
					"DOMNodeRemoved",
					"DOMNodeRemovedFromDocument",
					"DOMSubtreeModified",
					"DOMContentLoaded",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"DragDrop",
				[
					"drag",
					"dragstart",
					"dragend",
					"dragenter",
					"dragover",
					"dragleave",
					"drop",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Keyboard",
				["keydown", "keyup", "keypress", "input"],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Load",
				[
					"load",
					"beforeunload",
					"unload",
					"abort",
					"error",
					"hashchange",
					"popstate",
					"navigate",
					"navigatesuccess",
					"navigateerror",
					"currentchange",
					"navigateto",
					"navigatefrom",
					"finish",
					"dispose",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Mouse",
				[
					"auxclick",
					"click",
					"dblclick",
					"mousedown",
					"mouseup",
					"mouseover",
					"mousemove",
					"mouseout",
					"mouseenter",
					"mouseleave",
					"mousewheel",
					"wheel",
					"contextmenu",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Pointer",
				[
					"pointerover",
					"pointerout",
					"pointerenter",
					"pointerleave",
					"pointerdown",
					"pointerup",
					"pointermove",
					"pointercancel",
					"gotpointercapture",
					"lostpointercapture",
					"pointerrawupdate",
				],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Touch",
				["touchstart", "touchmove", "touchend", "touchcancel"],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Worker",
				["message", "messageerror"],
				["*"]
			),
			this.createEventListenerBreakpoints(
				"Xhr",
				[
					"readystatechange",
					"load",
					"loadstart",
					"loadend",
					"abort",
					"error",
					"progress",
					"timeout",
				],
				["xmlhttprequest", "xmlhttprequestupload"]
			),
			$e.instance().observeModels(di, this));
	}
	static instance(e = { forceNew: null }) {
		const { forceNew: t } = e;
		return ((mi && !t) || (mi = new fi()), mi);
	}
	cspViolationBreakpoints() {
		return this.#wl.slice();
	}
	createEventListenerBreakpoints(e, t, n) {
		for (const r of t) this.#Cl.push(new pi(r, n, e));
	}
	resolveEventListenerBreakpoint({ eventName: e, targetName: t }) {
		const n = "listener:";
		if (!e.startsWith(n)) return null;
		((e = e.substring(9)), (t = (t || "*").toLowerCase()));
		let r = null;
		for (const n of this.#Cl)
			(e && n.name === e && -1 !== n.eventTargetNames.indexOf(t) && (r = n),
				!r &&
					e &&
					n.name === e &&
					-1 !== n.eventTargetNames.indexOf("*") &&
					(r = n));
		return r;
	}
	eventListenerBreakpoints() {
		return this.#Cl.slice();
	}
	updateCSPViolationBreakpoints() {
		const e = this.#wl.filter((e) => e.enabled()).map((e) => e.type());
		for (const t of $e.instance().models(di))
			this.updateCSPViolationBreakpointsForModel(t, e);
	}
	updateCSPViolationBreakpointsForModel(e, t) {
		e.agent.invoke_setBreakOnCSPViolation({ violationTypes: t });
	}
	xhrBreakpoints() {
		return this.#Sl;
	}
	saveXHRBreakpoints() {
		const e = [];
		for (const t of this.#Sl.keys())
			e.push({ url: t, enabled: this.#Sl.get(t) || !1 });
		this.#kl.set(e);
	}
	addXHRBreakpoint(e, t) {
		if ((this.#Sl.set(e, t), t))
			for (const t of $e.instance().models(di))
				t.agent.invoke_setXHRBreakpoint({ url: e });
		this.saveXHRBreakpoints();
	}
	removeXHRBreakpoint(e) {
		const t = this.#Sl.get(e);
		if ((this.#Sl.delete(e), t))
			for (const t of $e.instance().models(di))
				t.agent.invoke_removeXHRBreakpoint({ url: e });
		this.saveXHRBreakpoints();
	}
	toggleXHRBreakpoint(e, t) {
		this.#Sl.set(e, t);
		for (const n of $e.instance().models(di))
			t
				? n.agent.invoke_setXHRBreakpoint({ url: e })
				: n.agent.invoke_removeXHRBreakpoint({ url: e });
		this.saveXHRBreakpoints();
	}
	modelAdded(e) {
		for (const t of this.#Sl.keys())
			this.#Sl.get(t) && e.agent.invoke_setXHRBreakpoint({ url: t });
		for (const t of this.#Cl) t.enabled() && t.updateOnModel(e);
		const t = this.#wl.filter((e) => e.enabled()).map((e) => e.type());
		this.updateCSPViolationBreakpointsForModel(e, t);
	}
	modelRemoved(e) {}
}
c.register(di, { capabilities: We.DOM, autostart: !1 });
var bi = Object.freeze({
	__proto__: null,
	DOMDebuggerModel: di,
	get Events() {
		return oi;
	},
	DOMBreakpoint: hi,
	get EventListener() {
		return ui;
	},
	CSPViolationBreakpoint: gi,
	DOMEventListenerBreakpoint: pi,
	DOMDebuggerManager: fi,
});
class yi extends c {
	agent;
	constructor(e) {
		(super(e), (this.agent = e.eventBreakpointsAgent()));
	}
}
class vi extends hs {
	setEnabled(e) {
		if (this.enabled() !== e) {
			super.setEnabled(e);
			for (const e of $e.instance().models(yi)) this.updateOnModel(e);
		}
	}
	updateOnModel(e) {
		this.enabled()
			? e.agent.invoke_setInstrumentationBreakpoint({ eventName: this.name })
			: e.agent.invoke_removeInstrumentationBreakpoint({
					eventName: this.name,
				});
	}
	static instrumentationPrefix = "instrumentation:";
}
let Ii;
class ki {
	#Cl = [];
	constructor() {
		(this.createInstrumentationBreakpoints("AuctionWorklet", [
			"beforeBidderWorkletBiddingStart",
			"beforeBidderWorkletReportingStart",
			"beforeSellerWorkletScoringStart",
			"beforeSellerWorkletReportingStart",
		]),
			this.createInstrumentationBreakpoints("Animation", [
				"requestAnimationFrame",
				"cancelAnimationFrame",
				"requestAnimationFrame.callback",
			]),
			this.createInstrumentationBreakpoints("Canvas", [
				"canvasContextCreated",
				"webglErrorFired",
				"webglWarningFired",
			]),
			this.createInstrumentationBreakpoints("Geolocation", [
				"Geolocation.getCurrentPosition",
				"Geolocation.watchPosition",
			]),
			this.createInstrumentationBreakpoints("Notification", [
				"Notification.requestPermission",
			]),
			this.createInstrumentationBreakpoints("Parse", [
				"Element.setInnerHTML",
				"Document.write",
			]),
			this.createInstrumentationBreakpoints("Script", [
				"scriptFirstStatement",
				"scriptBlockedByCSP",
			]),
			this.createInstrumentationBreakpoints("SharedStorageWorklet", [
				"sharedStorageWorkletScriptFirstStatement",
			]),
			this.createInstrumentationBreakpoints("Timer", [
				"setTimeout",
				"clearTimeout",
				"setInterval",
				"clearInterval",
				"setTimeout.callback",
				"setInterval.callback",
			]),
			this.createInstrumentationBreakpoints("Window", ["DOMWindow.close"]),
			this.createInstrumentationBreakpoints("WebAudio", [
				"audioContextCreated",
				"audioContextClosed",
				"audioContextResumed",
				"audioContextSuspended",
			]),
			$e.instance().observeModels(yi, this));
	}
	static instance(e = { forceNew: null }) {
		const { forceNew: t } = e;
		return ((Ii && !t) || (Ii = new ki()), Ii);
	}
	createInstrumentationBreakpoints(e, t) {
		for (const n of t) this.#Cl.push(new vi(e, n));
	}
	eventListenerBreakpoints() {
		return this.#Cl.slice();
	}
	resolveEventListenerBreakpoint({ eventName: e }) {
		if (!e.startsWith(vi.instrumentationPrefix)) return null;
		const t = e.substring(vi.instrumentationPrefix.length);
		return this.#Cl.find((e) => e.name === t) || null;
	}
	modelAdded(e) {
		for (const t of this.#Cl) t.enabled() && t.updateOnModel(e);
	}
	modelRemoved(e) {}
}
c.register(yi, { capabilities: We.EventBreakpoints, autostart: !1 });
var Si = Object.freeze({
		__proto__: null,
		EventBreakpointsModel: yi,
		EventBreakpointsManager: ki,
	}),
	wi = Object.freeze({ __proto__: null });
let Ci;
class Ri extends e.ObjectWrapper.ObjectWrapper {
	#Rl;
	#Tl;
	#Ue;
	#xl;
	constructor() {
		(super(),
			(this.#Rl = new Map()),
			(this.#Tl = new Map()),
			(this.#Ue = new Set()),
			$e.instance().observeModels(yn, this),
			(this.#xl = 0));
	}
	static instance({ forceNew: e } = { forceNew: !1 }) {
		return ((Ci && !e) || (Ci = new Ri()), Ci);
	}
	observeIsolates(e) {
		if (this.#Ue.has(e))
			throw new Error("Observer can only be registered once");
		(this.#Ue.size || this.poll(), this.#Ue.add(e));
		for (const t of this.#Rl.values()) e.isolateAdded(t);
	}
	unobserveIsolates(e) {
		(this.#Ue.delete(e), this.#Ue.size || ++this.#xl);
	}
	modelAdded(e) {
		this.modelAddedInternal(e);
	}
	async modelAddedInternal(e) {
		this.#Tl.set(e, null);
		const t = await e.isolateId();
		if (!this.#Tl.has(e)) return;
		if (!t) return void this.#Tl.delete(e);
		this.#Tl.set(e, t);
		let n = this.#Rl.get(t);
		if (
			(n || ((n = new Pi(t)), this.#Rl.set(t, n)),
			n.modelsInternal.add(e),
			1 === n.modelsInternal.size)
		)
			for (const e of this.#Ue) e.isolateAdded(n);
		else for (const e of this.#Ue) e.isolateChanged(n);
	}
	modelRemoved(e) {
		const t = this.#Tl.get(e);
		if ((this.#Tl.delete(e), !t)) return;
		const n = this.#Rl.get(t);
		if (n)
			if ((n.modelsInternal.delete(e), n.modelsInternal.size))
				for (const e of this.#Ue) e.isolateChanged(n);
			else {
				for (const e of this.#Ue) e.isolateRemoved(n);
				this.#Rl.delete(t);
			}
	}
	isolateByModel(e) {
		return this.#Rl.get(this.#Tl.get(e) || "") || null;
	}
	isolates() {
		return this.#Rl.values();
	}
	async poll() {
		const e = this.#xl;
		for (; e === this.#xl; )
			(await Promise.all(Array.from(this.isolates(), (e) => e.update())),
				await new Promise((e) => window.setTimeout(e, Mi)));
	}
}
var Ti;
(Ti || (Ti = {})).MemoryChanged = "MemoryChanged";
const xi = 12e4,
	Mi = 2e3;
class Pi {
	#Oe;
	modelsInternal;
	#Ml;
	#Pl;
	constructor(e) {
		((this.#Oe = e), (this.modelsInternal = new Set()), (this.#Ml = 0));
		const t = xi / Mi;
		this.#Pl = new Li(t);
	}
	id() {
		return this.#Oe;
	}
	models() {
		return this.modelsInternal;
	}
	runtimeModel() {
		return this.modelsInternal.values().next().value || null;
	}
	heapProfilerModel() {
		const e = this.runtimeModel();
		return e && e.heapProfilerModel();
	}
	async update() {
		const e = this.runtimeModel(),
			t = e && (await e.heapUsage());
		t &&
			((this.#Ml = t.usedSize),
			this.#Pl.add(this.#Ml),
			Ri.instance().dispatchEventToListeners(Ti.MemoryChanged, this));
	}
	samplesCount() {
		return this.#Pl.count();
	}
	usedHeapSize() {
		return this.#Ml;
	}
	usedHeapSizeGrowRate() {
		return this.#Pl.fitSlope();
	}
	isMainThread() {
		const e = this.runtimeModel();
		return !!e && "main" === e.target().id();
	}
}
class Li {
	#Ll;
	#El;
	#ur;
	#Ol;
	#Al;
	#Nl;
	#Dl;
	#Fl;
	#Bl;
	constructor(e) {
		((this.#Ll = 0 | e), this.reset());
	}
	reset() {
		((this.#El = Date.now()),
			(this.#ur = 0),
			(this.#Ol = []),
			(this.#Al = []),
			(this.#Nl = 0),
			(this.#Dl = 0),
			(this.#Fl = 0),
			(this.#Bl = 0));
	}
	count() {
		return this.#Ol.length;
	}
	add(e, t) {
		const n = "number" == typeof t ? t : Date.now() - this.#El,
			r = e;
		if (this.#Ol.length === this.#Ll) {
			const e = this.#Ol[this.#ur],
				t = this.#Al[this.#ur];
			((this.#Nl -= e),
				(this.#Dl -= t),
				(this.#Fl -= e * e),
				(this.#Bl -= e * t));
		}
		((this.#Nl += n),
			(this.#Dl += r),
			(this.#Fl += n * n),
			(this.#Bl += n * r),
			(this.#Ol[this.#ur] = n),
			(this.#Al[this.#ur] = r),
			(this.#ur = (this.#ur + 1) % this.#Ll));
	}
	fitSlope() {
		const e = this.count();
		return e < 2
			? 0
			: (this.#Bl - (this.#Nl * this.#Dl) / e) /
					(this.#Fl - (this.#Nl * this.#Nl) / e);
	}
}
var Ei = Object.freeze({
	__proto__: null,
	IsolateManager: Ri,
	get Events() {
		return Ti;
	},
	MemoryTrendWindowMs: xi,
	Isolate: Pi,
	MemoryTrend: Li,
});
class Oi extends c {
	#Ul = !1;
	#wn = !1;
	constructor(e) {
		(super(e), this.ensureEnabled());
	}
	async ensureEnabled() {
		if (this.#wn) return;
		((this.#wn = !0), this.target().registerAuditsDispatcher(this));
		const e = this.target().auditsAgent();
		await e.invoke_enable();
	}
	issueAdded(e) {
		this.dispatchEventToListeners("IssueAdded", {
			issuesModel: this,
			inspectorIssue: e.issue,
		});
	}
	dispose() {
		(super.dispose(), (this.#Ul = !0));
	}
	getTargetIfNotDisposed() {
		return this.#Ul ? null : this.target();
	}
}
c.register(Oi, { capabilities: We.Audits, autostart: !0 });
var Ai,
	Ni = Object.freeze({ __proto__: null, IssuesModel: Oi });
!(function (e) {
	let t;
	!(function (e) {
		((e.NonFastScrollable = "NonFastScrollable"),
			(e.TouchEventHandler = "TouchEventHandler"),
			(e.WheelEventHandler = "WheelEventHandler"),
			(e.RepaintsOnScroll = "RepaintsOnScroll"),
			(e.MainThreadScrollingReason = "MainThreadScrollingReason"));
	})((t = e.ScrollRectType || (e.ScrollRectType = {})));
})(Ai || (Ai = {}));
var Di = Object.freeze({
	__proto__: null,
	get Layer() {
		return Ai;
	},
	StickyPositionConstraint: class {
		#Hl;
		#ql;
		#_l;
		#zl;
		constructor(e, t) {
			((this.#Hl = t.stickyBoxRect),
				(this.#ql = t.containingBlockRect),
				(this.#_l = null),
				e &&
					t.nearestLayerShiftingStickyBox &&
					(this.#_l = e.layerById(t.nearestLayerShiftingStickyBox)),
				(this.#zl = null),
				e &&
					t.nearestLayerShiftingContainingBlock &&
					(this.#zl = e.layerById(t.nearestLayerShiftingContainingBlock)));
		}
		stickyBoxRect() {
			return this.#Hl;
		}
		containingBlockRect() {
			return this.#ql;
		}
		nearestLayerShiftingStickyBox() {
			return this.#_l;
		}
		nearestLayerShiftingContainingBlock() {
			return this.#zl;
		}
	},
	LayerTreeBase: class {
		#e;
		#an;
		layersById;
		#jl;
		#Wl;
		#Vl;
		#Gl;
		constructor(e) {
			((this.#e = e),
				(this.#an = e ? e.model(mr) : null),
				(this.layersById = new Map()),
				(this.#jl = null),
				(this.#Wl = null),
				(this.#Vl = new Map()));
		}
		target() {
			return this.#e;
		}
		root() {
			return this.#jl;
		}
		setRoot(e) {
			this.#jl = e;
		}
		contentRoot() {
			return this.#Wl;
		}
		setContentRoot(e) {
			this.#Wl = e;
		}
		forEachLayer(e, t) {
			return (
				!(!t && !(t = this.root())) &&
				(e(t) || t.children().some(this.forEachLayer.bind(this, e)))
			);
		}
		layerById(e) {
			return this.layersById.get(e) || null;
		}
		async resolveBackendNodeIds(e) {
			if (!e.size || !this.#an) return;
			const t = await this.#an.pushNodesByBackendIdsToFrontend(e);
			if (t) for (const e of t.keys()) this.#Vl.set(e, t.get(e) || null);
		}
		backendNodeIdToNode() {
			return this.#Vl;
		}
		setViewportSize(e) {
			this.#Gl = e;
		}
		viewportSize() {
			return this.#Gl;
		}
		nodeForId(e) {
			return this.#an ? this.#an.nodeForId(e) : null;
		}
	},
});
class Fi {
	id;
	url;
	startTime;
	loadTime;
	contentLoadTime;
	mainRequest;
	constructor(e) {
		((this.id = ++Fi.lastIdentifier),
			(this.url = e.url()),
			(this.startTime = e.startTime),
			(this.mainRequest = e));
	}
	static forRequest(e) {
		return Bi.get(e) || null;
	}
	bindRequest(e) {
		Bi.set(e, this);
	}
	static lastIdentifier = 0;
}
const Bi = new WeakMap();
var Ui = Object.freeze({ __proto__: null, PageLoad: Fi });
class Hi extends c {
	layerTreeAgent;
	constructor(e) {
		(super(e), (this.layerTreeAgent = e.layerTreeAgent()));
	}
	async loadSnapshotFromFragments(e) {
		const { snapshotId: t } = await this.layerTreeAgent.invoke_loadSnapshot({
			tiles: e,
		});
		return t ? new qi(this, t) : null;
	}
	loadSnapshot(e) {
		const t = { x: 0, y: 0, picture: e };
		return this.loadSnapshotFromFragments([t]);
	}
	async makeSnapshot(e) {
		const { snapshotId: t } = await this.layerTreeAgent.invoke_makeSnapshot({
			layerId: e,
		});
		return t ? new qi(this, t) : null;
	}
}
class qi {
	#Kl;
	#Ql;
	#$l;
	constructor(e, t) {
		((this.#Kl = e), (this.#Ql = t), (this.#$l = 1));
	}
	release() {
		(console.assert(this.#$l > 0, "release is already called on the object"),
			--this.#$l ||
				this.#Kl.layerTreeAgent.invoke_releaseSnapshot({
					snapshotId: this.#Ql,
				}));
	}
	addReference() {
		(++this.#$l, console.assert(this.#$l > 0, "Referencing a dead object"));
	}
	async replay(e, t, n) {
		return (
			await this.#Kl.layerTreeAgent.invoke_replaySnapshot({
				snapshotId: this.#Ql,
				fromStep: t,
				toStep: n,
				scale: e || 1,
			})
		).dataURL;
	}
	async profile(e) {
		return (
			await this.#Kl.layerTreeAgent.invoke_profileSnapshot({
				snapshotId: this.#Ql,
				minRepeatCount: 5,
				minDuration: 1,
				clipRect: e || void 0,
			})
		).timings;
	}
	async commandLog() {
		const e = await this.#Kl.layerTreeAgent.invoke_snapshotCommandLog({
			snapshotId: this.#Ql,
		});
		return e.commandLog ? e.commandLog.map((e, t) => new _i(e, t)) : null;
	}
}
class _i {
	method;
	params;
	commandIndex;
	constructor(e, t) {
		((this.method = e.method),
			(this.params = e.params),
			(this.commandIndex = t));
	}
}
c.register(Hi, { capabilities: We.DOM, autostart: !1 });
var zi = Object.freeze({
	__proto__: null,
	PaintProfilerModel: Hi,
	PaintProfilerSnapshot: qi,
	PaintProfilerLogItem: _i,
});
class ji extends c {
	#Zr;
	#Xl;
	#Jl;
	constructor(e) {
		(super(e),
			(this.#Zr = e.performanceAgent()),
			(this.#Xl = new Map([
				["TaskDuration", "CumulativeTime"],
				["ScriptDuration", "CumulativeTime"],
				["LayoutDuration", "CumulativeTime"],
				["RecalcStyleDuration", "CumulativeTime"],
				["LayoutCount", "CumulativeCount"],
				["RecalcStyleCount", "CumulativeCount"],
			])),
			(this.#Jl = new Map()));
	}
	enable() {
		return this.#Zr.invoke_enable({});
	}
	disable() {
		return this.#Zr.invoke_disable();
	}
	async requestMetrics() {
		const e = (await this.#Zr.invoke_getMetrics()) || [],
			n = new Map(),
			r = performance.now();
		for (const s of e.metrics) {
			let e,
				i = this.#Jl.get(s.name);
			switch (
				(i ||
					((i = { lastValue: void 0, lastTimestamp: void 0 }),
					this.#Jl.set(s.name, i)),
				this.#Xl.get(s.name))
			) {
				case "CumulativeTime":
					((e =
						i.lastTimestamp && i.lastValue
							? t.NumberUtilities.clamp(
									(1e3 * (s.value - i.lastValue)) / (r - i.lastTimestamp),
									0,
									1
								)
							: 0),
						(i.lastValue = s.value),
						(i.lastTimestamp = r));
					break;
				case "CumulativeCount":
					((e =
						i.lastTimestamp && i.lastValue
							? Math.max(
									0,
									(1e3 * (s.value - i.lastValue)) / (r - i.lastTimestamp)
								)
							: 0),
						(i.lastValue = s.value),
						(i.lastTimestamp = r));
					break;
				default:
					e = s.value;
			}
			n.set(s.name, e);
		}
		return { metrics: n, timestamp: r };
	}
}
c.register(ji, { capabilities: We.DOM, autostart: !1 });
var Wi,
	Vi = Object.freeze({ __proto__: null, PerformanceMetricsModel: ji });
class Gi extends c {
	agent;
	loaderIds = [];
	targetJustAttached = !0;
	lastPrimaryPageModel = null;
	documents = new Map();
	constructor(e) {
		(super(e),
			e.registerPreloadDispatcher(new Ki(this)),
			(this.agent = e.preloadAgent()),
			this.agent.invoke_enable());
		const t = e.targetInfo();
		(void 0 !== t &&
			"prerender" === t.subtype &&
			(this.lastPrimaryPageModel =
				$e.instance().primaryPageTarget()?.model(Gi) || null),
			$e
				.instance()
				.addModelListener(
					Pr,
					xr.PrimaryPageChanged,
					this.onPrimaryPageChanged,
					this
				));
	}
	dispose() {
		(super.dispose(),
			$e
				.instance()
				.removeModelListener(
					Pr,
					xr.PrimaryPageChanged,
					this.onPrimaryPageChanged,
					this
				),
			this.agent.invoke_disable());
	}
	ensureDocumentPreloadingData(e) {
		void 0 === this.documents.get(e) && this.documents.set(e, new Qi());
	}
	currentLoaderId() {
		if (this.targetJustAttached) return null;
		if (0 === this.loaderIds.length) throw new Error("unreachable");
		return this.loaderIds[this.loaderIds.length - 1];
	}
	currentDocument() {
		const e = this.currentLoaderId();
		return null === e ? null : this.documents.get(e) || null;
	}
	getRuleSetById(e) {
		return this.currentDocument()?.ruleSets.getById(e) || null;
	}
	getAllRuleSets() {
		return this.currentDocument()?.ruleSets.getAll() || [];
	}
	getPreloadCountsByRuleSetId() {
		const e = new Map();
		for (const { value: t } of this.getPreloadingAttempts(null))
			for (const r of [null, ...t.ruleSetIds]) {
				void 0 === e.get(r) && e.set(r, new Map());
				const s = e.get(r);
				n(s);
				const i = s.get(t.status) || 0;
				s.set(t.status, i + 1);
			}
		return e;
	}
	getPreloadingAttemptById(e) {
		const t = this.currentDocument();
		return null === t
			? null
			: t.preloadingAttempts.getById(e, t.sources) || null;
	}
	getPreloadingAttempts(e) {
		const t = this.currentDocument();
		return null === t ? [] : t.preloadingAttempts.getAll(e, t.sources);
	}
	getPreloadingAttemptsOfPreviousPage() {
		if (this.loaderIds.length <= 1) return [];
		const e = this.documents.get(this.loaderIds[this.loaderIds.length - 2]);
		return void 0 === e ? [] : e.preloadingAttempts.getAll(null, e.sources);
	}
	onPrimaryPageChanged(e) {
		const { frame: t, type: n } = e.data;
		if (null === this.lastPrimaryPageModel && "Activation" === n) return;
		if (null !== this.lastPrimaryPageModel && "Activation" !== n) return;
		if (null !== this.lastPrimaryPageModel && "Activation" === n) {
			this.loaderIds = this.lastPrimaryPageModel.loaderIds;
			for (const [e, t] of this.lastPrimaryPageModel.documents.entries())
				(this.ensureDocumentPreloadingData(e),
					this.documents.get(e)?.mergePrevious(t));
		}
		this.lastPrimaryPageModel = null;
		const r = t.loaderId;
		(this.loaderIds.push(r),
			(this.loaderIds = this.loaderIds.slice(-2)),
			this.ensureDocumentPreloadingData(r));
		for (const e of this.documents.keys())
			this.loaderIds.includes(e) || this.documents.delete(e);
		this.dispatchEventToListeners(Wi.ModelUpdated);
	}
	onRuleSetUpdated(e) {
		const t = e.ruleSet,
			n = t.loaderId;
		(null === this.currentLoaderId() &&
			((this.loaderIds = [n]), (this.targetJustAttached = !1)),
			this.ensureDocumentPreloadingData(n),
			this.documents.get(n)?.ruleSets.upsert(t),
			this.dispatchEventToListeners(Wi.ModelUpdated));
	}
	onRuleSetRemoved(e) {
		const t = e.id;
		for (const e of this.documents.values()) e.ruleSets.delete(t);
		this.dispatchEventToListeners(Wi.ModelUpdated);
	}
	onPreloadingAttemptSourcesUpdated(e) {
		const t = e.loaderId;
		this.ensureDocumentPreloadingData(t);
		const n = this.documents.get(t);
		void 0 !== n &&
			(n.sources.update(e.preloadingAttemptSources),
			n.preloadingAttempts.maybeRegisterNotTriggered(n.sources),
			this.dispatchEventToListeners(Wi.ModelUpdated));
	}
	onPrefetchStatusUpdated(e) {
		const t = e.key.loaderId;
		this.ensureDocumentPreloadingData(t);
		const n = {
			action: "Prefetch",
			key: e.key,
			status: Xi(e.status),
			prefetchStatus: e.prefetchStatus || null,
			requestId: e.requestId,
		};
		(this.documents.get(t)?.preloadingAttempts.upsert(n),
			this.dispatchEventToListeners(Wi.ModelUpdated));
	}
	onPrerenderStatusUpdated(e) {
		const t = e.key.loaderId;
		this.ensureDocumentPreloadingData(t);
		const n = {
			action: "Prerender",
			key: e.key,
			status: Xi(e.status),
			prerenderStatus: e.prerenderStatus || null,
			disallowedMojoInterface: e.disallowedMojoInterface || null,
			mismatchedHeaders: e.mismatchedHeaders || null,
		};
		(this.documents.get(t)?.preloadingAttempts.upsert(n),
			this.dispatchEventToListeners(Wi.ModelUpdated));
	}
	onPreloadEnabledStateUpdated(e) {
		this.dispatchEventToListeners(Wi.WarningsUpdated, e);
	}
}
(c.register(Gi, { capabilities: We.DOM, autostart: !1 }),
	(function (e) {
		((e.ModelUpdated = "ModelUpdated"),
			(e.WarningsUpdated = "WarningsUpdated"));
	})(Wi || (Wi = {})));
class Ki {
	model;
	constructor(e) {
		this.model = e;
	}
	ruleSetUpdated(e) {
		this.model.onRuleSetUpdated(e);
	}
	ruleSetRemoved(e) {
		this.model.onRuleSetRemoved(e);
	}
	preloadingAttemptSourcesUpdated(e) {
		this.model.onPreloadingAttemptSourcesUpdated(e);
	}
	prefetchStatusUpdated(e) {
		this.model.onPrefetchStatusUpdated(e);
	}
	prerenderStatusUpdated(e) {
		this.model.onPrerenderStatusUpdated(e);
	}
	preloadEnabledStateUpdated(e) {
		this.model.onPreloadEnabledStateUpdated(e);
	}
}
class Qi {
	ruleSets = new $i();
	preloadingAttempts = new Yi();
	sources = new Zi();
	mergePrevious(e) {
		if (!this.ruleSets.isEmpty() || !this.sources.isEmpty())
			throw new Error("unreachable");
		((this.ruleSets = e.ruleSets),
			this.preloadingAttempts.mergePrevious(e.preloadingAttempts),
			(this.sources = e.sources));
	}
}
class $i {
	map = new Map();
	isEmpty() {
		return 0 === this.map.size;
	}
	getById(e) {
		return this.map.get(e) || null;
	}
	getAll() {
		return Array.from(this.map.entries()).map(([e, t]) => ({
			id: e,
			value: t,
		}));
	}
	upsert(e) {
		this.map.set(e.id, e);
	}
	delete(e) {
		this.map.delete(e);
	}
}
function Xi(e) {
	switch (e) {
		case "Pending":
			return "Pending";
		case "Running":
			return "Running";
		case "Ready":
			return "Ready";
		case "Success":
			return "Success";
		case "Failure":
			return "Failure";
		case "NotSupported":
			return "NotSupported";
	}
	throw new Error("unreachable");
}
function Ji(e) {
	let t, n;
	switch (e.action) {
		case "Prefetch":
			t = "Prefetch";
			break;
		case "Prerender":
			t = "Prerender";
	}
	switch (e.targetHint) {
		case void 0:
			n = "undefined";
			break;
		case "Blank":
			n = "Blank";
			break;
		case "Self":
			n = "Self";
	}
	return `${e.loaderId}:${t}:${e.url}:${n}`;
}
class Yi {
	map = new Map();
	enrich(e, t) {
		let n = [],
			r = [];
		return (
			null !== t && ((n = t.ruleSetIds), (r = t.nodeIds)),
			{ ...e, ruleSetIds: n, nodeIds: r }
		);
	}
	getById(e, t) {
		const n = this.map.get(e) || null;
		return null === n ? null : this.enrich(n, t.getById(e));
	}
	getAll(e, t) {
		return [...this.map.entries()]
			.map(([e, n]) => ({ id: e, value: this.enrich(n, t.getById(e)) }))
			.filter(({ value: t }) => !e || t.ruleSetIds.includes(e));
	}
	upsert(e) {
		const t = Ji(e.key);
		this.map.set(t, e);
	}
	maybeRegisterNotTriggered(e) {
		for (const [t, { key: n }] of e.entries()) {
			if (void 0 !== this.map.get(t)) continue;
			let e;
			switch (n.action) {
				case "Prefetch":
					e = {
						action: "Prefetch",
						key: n,
						status: "NotTriggered",
						prefetchStatus: null,
						requestId: "",
					};
					break;
				case "Prerender":
					e = {
						action: "Prerender",
						key: n,
						status: "NotTriggered",
						prerenderStatus: null,
						disallowedMojoInterface: null,
						mismatchedHeaders: null,
					};
			}
			this.map.set(t, e);
		}
	}
	mergePrevious(e) {
		for (const [t, n] of this.map.entries()) e.map.set(t, n);
		this.map = e.map;
	}
}
class Zi {
	map = new Map();
	entries() {
		return this.map.entries();
	}
	isEmpty() {
		return 0 === this.map.size;
	}
	getById(e) {
		return this.map.get(e) || null;
	}
	update(e) {
		this.map = new Map(e.map((e) => [Ji(e.key), e]));
	}
}
var ea = Object.freeze({
	__proto__: null,
	PreloadingModel: Gi,
	get Events() {
		return Wi;
	},
});
class ta extends c {
	#Zr;
	#Yl;
	#Zl;
	constructor(e) {
		(super(e),
			(this.#Zr = e.pageAgent()),
			(this.#Yl = null),
			(this.#Zl = null),
			e.registerPageDispatcher(this));
	}
	startScreencast(e, t, n, r, s, i, a) {
		((this.#Yl = i),
			(this.#Zl = a),
			this.#Zr.invoke_startScreencast({
				format: e,
				quality: t,
				maxWidth: n,
				maxHeight: r,
				everyNthFrame: s,
			}));
	}
	stopScreencast() {
		((this.#Yl = null), (this.#Zl = null), this.#Zr.invoke_stopScreencast());
	}
	async captureScreenshot(e, t, n, r) {
		const s = { format: e, quality: t, fromSurface: !0 };
		switch (n) {
			case "fromClip":
				((s.captureBeyondViewport = !0), (s.clip = r));
				break;
			case "fullpage":
				s.captureBeyondViewport = !0;
				break;
			case "fromViewport":
				s.captureBeyondViewport = !1;
				break;
			default:
				throw new Error("Unexpected or unspecified screnshotMode");
		}
		await sr.muteHighlight();
		const i = await this.#Zr.invoke_captureScreenshot(s);
		return (await sr.unmuteHighlight(), i.data);
	}
	async fetchLayoutMetrics() {
		const e = await this.#Zr.invoke_getLayoutMetrics();
		return e.getError()
			? null
			: {
					viewportX: e.cssVisualViewport.pageX,
					viewportY: e.cssVisualViewport.pageY,
					viewportScale: e.cssVisualViewport.scale,
					contentWidth: e.cssContentSize.width,
					contentHeight: e.cssContentSize.height,
				};
	}
	screencastFrame({ data: e, metadata: t, sessionId: n }) {
		(this.#Zr.invoke_screencastFrameAck({ sessionId: n }),
			this.#Yl && this.#Yl.call(null, e, t));
	}
	screencastVisibilityChanged({ visible: e }) {
		this.#Zl && this.#Zl.call(null, e);
	}
	backForwardCacheNotUsed(e) {}
	domContentEventFired(e) {}
	loadEventFired(e) {}
	lifecycleEvent(e) {}
	navigatedWithinDocument(e) {}
	frameAttached(e) {}
	frameNavigated(e) {}
	documentOpened(e) {}
	frameDetached(e) {}
	frameStartedLoading(e) {}
	frameStoppedLoading(e) {}
	frameRequestedNavigation(e) {}
	frameScheduledNavigation(e) {}
	frameClearedScheduledNavigation(e) {}
	frameResized() {}
	javascriptDialogOpening(e) {}
	javascriptDialogClosed(e) {}
	interstitialShown() {}
	interstitialHidden() {}
	windowOpen(e) {}
	fileChooserOpened(e) {}
	compilationCacheProduced(e) {}
	downloadWillBegin(e) {}
	downloadProgress() {}
	prefetchStatusUpdated(e) {}
	prerenderStatusUpdated(e) {}
}
c.register(ta, { capabilities: We.ScreenCapture, autostart: !1 });
var na = Object.freeze({ __proto__: null, ScreenCaptureModel: ta });
class ra {
	#ed;
	#td;
	constructor(e, t) {
		((this.#ed = new TextDecoderStream(t)),
			(this.#td = this.#ed.writable.getWriter()),
			this.#ed.readable.pipeTo(new WritableStream({ write: e })));
	}
	async addBase64Chunk(e) {
		const t = window.atob(e),
			n = Uint8Array.from(t, (e) => e.codePointAt(0));
		(await this.#td.ready, await this.#td.write(n));
	}
}
var sa = Object.freeze({
	__proto__: null,
	ServerSentEventsParser: class {
		#nd;
		#ed;
		#rd = !1;
		#sd = "";
		#Ql = "";
		#id = "";
		#ad = "";
		constructor(e, t) {
			((this.#nd = e), (this.#ed = new ra(this.#od.bind(this), t)));
		}
		async addBase64Chunk(e) {
			await this.#ed.addBase64Chunk(e);
		}
		#od(e) {
			let t = 0;
			for (let n = 0; n < e.length; ++n)
				this.#rd && "\n" === e[n]
					? ((this.#rd = !1), ++t)
					: ((this.#rd = !1),
						("\r" !== e[n] && "\n" !== e[n]) ||
							((this.#sd += e.substring(t, n)),
							this.#ld(),
							(this.#sd = ""),
							(t = n + 1),
							(this.#rd = "\r" === e[n])));
			this.#sd += e.substring(t);
		}
		#ld() {
			if (0 === this.#sd.length) {
				if (this.#id.length > 0) {
					const e = this.#id.slice(0, -1);
					(this.#nd(this.#ad || "message", e, this.#Ql), (this.#id = ""));
				}
				return void (this.#ad = "");
			}
			let e,
				t = this.#sd.indexOf(":");
			t < 0
				? ((t = this.#sd.length), (e = t))
				: ((e = t + 1), e < this.#sd.length && " " === this.#sd[e] && ++e);
			const n = this.#sd.substring(0, t);
			"event" !== n
				? ("data" === n &&
						((this.#id += this.#sd.substring(e)), (this.#id += "\n")),
					"id" === n && (this.#Ql = this.#sd.substring(e)))
				: (this.#ad = this.#sd.substring(e));
		}
	},
});
class ia extends c {
	enabled = !1;
	storageAgent;
	storageKeyManager;
	bucketsById = new Map();
	trackedStorageKeys = new Set();
	constructor(e) {
		(super(e),
			e.registerStorageDispatcher(this),
			(this.storageAgent = e.storageAgent()),
			(this.storageKeyManager = e.model(Tr)));
	}
	getBuckets() {
		return new Set(this.bucketsById.values());
	}
	getBucketsForStorageKey(e) {
		const t = [...this.bucketsById.values()];
		return new Set(t.filter(({ bucket: t }) => t.storageKey === e));
	}
	getDefaultBucketForStorageKey(e) {
		return (
			[...this.bucketsById.values()].find(
				({ bucket: t }) => t.storageKey === e && void 0 === t.name
			) ?? null
		);
	}
	getBucketById(e) {
		return this.bucketsById.get(e) ?? null;
	}
	getBucketByName(e, t) {
		if (!t) return this.getDefaultBucketForStorageKey(e);
		return (
			[...this.bucketsById.values()].find(
				({ bucket: n }) => n.storageKey === e && n.name === t
			) ?? null
		);
	}
	deleteBucket(e) {
		this.storageAgent.invoke_deleteStorageBucket({ bucket: e });
	}
	enable() {
		if (!this.enabled) {
			if (this.storageKeyManager) {
				(this.storageKeyManager.addEventListener(
					Cr.StorageKeyAdded,
					this.storageKeyAdded,
					this
				),
					this.storageKeyManager.addEventListener(
						Cr.StorageKeyRemoved,
						this.storageKeyRemoved,
						this
					));
				for (const e of this.storageKeyManager.storageKeys())
					this.addStorageKey(e);
			}
			this.enabled = !0;
		}
	}
	storageKeyAdded(e) {
		this.addStorageKey(e.data);
	}
	storageKeyRemoved(e) {
		this.removeStorageKey(e.data);
	}
	addStorageKey(e) {
		if (this.trackedStorageKeys.has(e))
			throw new Error(
				"Can't call addStorageKey for a storage key if it has already been added."
			);
		(this.trackedStorageKeys.add(e),
			this.storageAgent.invoke_setStorageBucketTracking({
				storageKey: e,
				enable: !0,
			}));
	}
	removeStorageKey(e) {
		if (!this.trackedStorageKeys.has(e))
			throw new Error(
				"Can't call removeStorageKey for a storage key if it hasn't already been added."
			);
		const t = this.getBucketsForStorageKey(e);
		for (const e of t) this.bucketRemoved(e);
		(this.trackedStorageKeys.delete(e),
			this.storageAgent.invoke_setStorageBucketTracking({
				storageKey: e,
				enable: !1,
			}));
	}
	bucketAdded(e) {
		(this.bucketsById.set(e.id, e),
			this.dispatchEventToListeners("BucketAdded", {
				model: this,
				bucketInfo: e,
			}));
	}
	bucketRemoved(e) {
		(this.bucketsById.delete(e.id),
			this.dispatchEventToListeners("BucketRemoved", {
				model: this,
				bucketInfo: e,
			}));
	}
	bucketChanged(e) {
		this.dispatchEventToListeners("BucketChanged", {
			model: this,
			bucketInfo: e,
		});
	}
	bucketInfosAreEqual(e, t) {
		return (
			e.bucket.storageKey === t.bucket.storageKey &&
			e.id === t.id &&
			e.bucket.name === t.bucket.name &&
			e.expiration === t.expiration &&
			e.quota === t.quota &&
			e.persistent === t.persistent &&
			e.durability === t.durability
		);
	}
	storageBucketCreatedOrUpdated({ bucketInfo: e }) {
		const t = this.getBucketById(e.id);
		t
			? this.bucketInfosAreEqual(t, e) || this.bucketChanged(e)
			: this.bucketAdded(e);
	}
	storageBucketDeleted({ bucketId: e }) {
		const t = this.getBucketById(e);
		if (!t)
			throw new Error(
				`Received an event that Storage Bucket '${e}' was deleted, but it wasn't in the StorageBucketsModel.`
			);
		this.bucketRemoved(t);
	}
	interestGroupAccessed(e) {}
	indexedDBListUpdated(e) {}
	indexedDBContentUpdated(e) {}
	cacheStorageListUpdated(e) {}
	cacheStorageContentUpdated(e) {}
	sharedStorageAccessed(e) {}
	attributionReportingSourceRegistered(e) {}
}
c.register(ia, { capabilities: We.Storage, autostart: !1 });
var aa = Object.freeze({ __proto__: null, StorageBucketsModel: ia });
const oa = {
		serviceworkercacheagentError:
			"`ServiceWorkerCacheAgent` error deleting cache entry {PH1} in cache: {PH2}",
	},
	la = i.i18n.registerUIStrings("core/sdk/ServiceWorkerCacheModel.ts", oa),
	da = i.i18n.getLocalizedString.bind(void 0, la);
class ca extends c {
	cacheAgent;
	#dd;
	#cd;
	#hd = new Map();
	#ud = new Set();
	#gd = new Set();
	#pd = new e.Throttler.Throttler(2e3);
	#wn = !1;
	#md = !1;
	constructor(e) {
		(super(e),
			e.registerStorageDispatcher(this),
			(this.cacheAgent = e.cacheStorageAgent()),
			(this.#dd = e.storageAgent()),
			(this.#cd = e.model(ia)));
	}
	enable() {
		if (!this.#wn) {
			(this.#cd.addEventListener("BucketAdded", this.storageBucketAdded, this),
				this.#cd.addEventListener(
					"BucketRemoved",
					this.storageBucketRemoved,
					this
				));
			for (const e of this.#cd.getBuckets()) this.addStorageBucket(e.bucket);
			this.#wn = !0;
		}
	}
	clearForStorageKey(e) {
		for (const [t, n] of this.#hd.entries())
			n.storageKey === e && (this.#hd.delete(t), this.cacheRemoved(n));
		for (const t of this.#cd.getBucketsForStorageKey(e))
			this.loadCacheNames(t.bucket);
	}
	refreshCacheNames() {
		for (const e of this.#hd.values()) this.cacheRemoved(e);
		this.#hd.clear();
		const e = this.#cd.getBuckets();
		for (const t of e) this.loadCacheNames(t.bucket);
	}
	async deleteCache(e) {
		const t = await this.cacheAgent.invoke_deleteCache({ cacheId: e.cacheId });
		t.getError()
			? console.error(
					`ServiceWorkerCacheAgent error deleting cache ${e.toString()}: ${t.getError()}`
				)
			: (this.#hd.delete(e.cacheId), this.cacheRemoved(e));
	}
	async deleteCacheEntry(t, n) {
		const r = await this.cacheAgent.invoke_deleteEntry({
			cacheId: t.cacheId,
			request: n,
		});
		r.getError() &&
			e.Console.Console.instance().error(
				da(oa.serviceworkercacheagentError, {
					PH1: t.toString(),
					PH2: String(r.getError()),
				})
			);
	}
	loadCacheData(e, t, n, r, s) {
		this.requestEntries(e, t, n, r, s);
	}
	loadAllCacheData(e, t, n) {
		this.requestAllEntries(e, t, n);
	}
	caches() {
		const e = new Array();
		for (const t of this.#hd.values()) e.push(t);
		return e;
	}
	dispose() {
		for (const e of this.#hd.values()) this.cacheRemoved(e);
		(this.#hd.clear(),
			this.#wn &&
				(this.#cd.removeEventListener(
					"BucketAdded",
					this.storageBucketAdded,
					this
				),
				this.#cd.removeEventListener(
					"BucketRemoved",
					this.storageBucketRemoved,
					this
				)));
	}
	addStorageBucket(e) {
		(this.loadCacheNames(e),
			this.#ud.has(e.storageKey) ||
				(this.#ud.add(e.storageKey),
				this.#dd.invoke_trackCacheStorageForStorageKey({
					storageKey: e.storageKey,
				})));
	}
	removeStorageBucket(e) {
		let t = 0;
		for (const [n, r] of this.#hd.entries())
			(e.storageKey === r.storageKey && t++,
				r.inBucket(e) && (t--, this.#hd.delete(n), this.cacheRemoved(r)));
		0 === t &&
			(this.#ud.delete(e.storageKey),
			this.#dd.invoke_untrackCacheStorageForStorageKey({
				storageKey: e.storageKey,
			}));
	}
	async loadCacheNames(e) {
		const t = await this.cacheAgent.invoke_requestCacheNames({
			storageBucket: e,
		});
		t.getError() || this.updateCacheNames(e, t.caches);
	}
	updateCacheNames(e, t) {
		const n = new Set(),
			r = new Map(),
			s = new Map();
		for (const e of t) {
			const t =
				e.storageBucket ??
				this.#cd.getDefaultBucketForStorageKey(e.storageKey)?.bucket;
			if (!t) continue;
			const s = new ua(this, t, e.cacheName, e.cacheId);
			(n.add(s.cacheId),
				this.#hd.has(s.cacheId) ||
					(r.set(s.cacheId, s), this.#hd.set(s.cacheId, s)));
		}
		(this.#hd.forEach(function (t) {
			t.inBucket(e) &&
				!n.has(t.cacheId) &&
				(s.set(t.cacheId, t), this.#hd.delete(t.cacheId));
		}, this),
			r.forEach(this.cacheAdded, this),
			s.forEach(this.cacheRemoved, this));
	}
	storageBucketAdded({
		data: {
			bucketInfo: { bucket: e },
		},
	}) {
		this.addStorageBucket(e);
	}
	storageBucketRemoved({
		data: {
			bucketInfo: { bucket: e },
		},
	}) {
		this.removeStorageBucket(e);
	}
	cacheAdded(e) {
		this.dispatchEventToListeners(ha.CacheAdded, { model: this, cache: e });
	}
	cacheRemoved(e) {
		this.dispatchEventToListeners(ha.CacheRemoved, { model: this, cache: e });
	}
	async requestEntries(e, t, n, r, s) {
		const i = await this.cacheAgent.invoke_requestEntries({
			cacheId: e.cacheId,
			skipCount: t,
			pageSize: n,
			pathFilter: r,
		});
		i.getError()
			? console.error(
					"ServiceWorkerCacheAgent error while requesting entries: ",
					i.getError()
				)
			: s(i.cacheDataEntries, i.returnCount);
	}
	async requestAllEntries(e, t, n) {
		const r = await this.cacheAgent.invoke_requestEntries({
			cacheId: e.cacheId,
			pathFilter: t,
		});
		r.getError()
			? console.error(
					"ServiceWorkerCacheAgent error while requesting entries: ",
					r.getError()
				)
			: n(r.cacheDataEntries, r.returnCount);
	}
	cacheStorageListUpdated({ bucketId: e }) {
		const t = this.#cd.getBucketById(e)?.bucket;
		t &&
			(this.#gd.add(t),
			this.#pd.schedule(() => {
				const e = Array.from(this.#gd, (e) => this.loadCacheNames(e));
				return (this.#gd.clear(), Promise.all(e));
			}, this.#md));
	}
	cacheStorageContentUpdated({ bucketId: e, cacheName: t }) {
		const n = this.#cd.getBucketById(e)?.bucket;
		n &&
			this.dispatchEventToListeners(ha.CacheStorageContentUpdated, {
				storageBucket: n,
				cacheName: t,
			});
	}
	indexedDBListUpdated(e) {}
	indexedDBContentUpdated(e) {}
	interestGroupAccessed(e) {}
	sharedStorageAccessed(e) {}
	storageBucketCreatedOrUpdated(e) {}
	storageBucketDeleted(e) {}
	setThrottlerSchedulesAsSoonAsPossibleForTest() {
		this.#md = !0;
	}
	attributionReportingSourceRegistered(e) {}
}
var ha;
!(function (e) {
	((e.CacheAdded = "CacheAdded"),
		(e.CacheRemoved = "CacheRemoved"),
		(e.CacheStorageContentUpdated = "CacheStorageContentUpdated"));
})(ha || (ha = {}));
class ua {
	#gr;
	storageKey;
	storageBucket;
	cacheName;
	cacheId;
	constructor(e, t, n, r) {
		((this.#gr = e),
			(this.storageBucket = t),
			(this.storageKey = t.storageKey),
			(this.cacheName = n),
			(this.cacheId = r));
	}
	inBucket(e) {
		return (
			this.storageKey === e.storageKey && this.storageBucket.name === e.name
		);
	}
	equals(e) {
		return this.cacheId === e.cacheId;
	}
	toString() {
		return this.storageKey + this.cacheName;
	}
	async requestCachedResponse(e, t) {
		const n = await this.#gr.cacheAgent.invoke_requestCachedResponse({
			cacheId: this.cacheId,
			requestURL: e,
			requestHeaders: t,
		});
		return n.getError() ? null : n.response;
	}
}
c.register(ca, { capabilities: We.Storage, autostart: !1 });
var ga = Object.freeze({
	__proto__: null,
	ServiceWorkerCacheModel: ca,
	get Events() {
		return ha;
	},
	Cache: ua,
});
const pa = {
		running: "running",
		starting: "starting",
		stopped: "stopped",
		stopping: "stopping",
		activated: "activated",
		activating: "activating",
		installed: "installed",
		installing: "installing",
		new: "new",
		redundant: "redundant",
		sSS: "{PH1} #{PH2} ({PH3})",
	},
	ma = i.i18n.registerUIStrings("core/sdk/ServiceWorkerManager.ts", pa),
	fa = i.i18n.getLocalizedString.bind(void 0, ma),
	ba = i.i18n.getLazilyComputedLocalizedString.bind(void 0, ma);
class ya extends c {
	#Zr;
	#fd;
	#wn;
	#bd;
	serviceWorkerNetworkRequestsPanelStatus;
	constructor(t) {
		(super(t),
			t.registerServiceWorkerDispatcher(new Ia(this)),
			(this.#Zr = t.serviceWorkerAgent()),
			(this.#fd = new Map()),
			(this.#wn = !1),
			this.enable(),
			(this.#bd = e.Settings.Settings.instance().createSetting(
				"serviceWorkerUpdateOnReload",
				!1
			)),
			this.#bd.get() && this.forceUpdateSettingChanged(),
			this.#bd.addChangeListener(this.forceUpdateSettingChanged, this),
			new Ra(t, this),
			(this.serviceWorkerNetworkRequestsPanelStatus = {
				isOpen: !1,
				openedAt: 0,
			}));
	}
	async enable() {
		this.#wn || ((this.#wn = !0), await this.#Zr.invoke_enable());
	}
	async disable() {
		this.#wn &&
			((this.#wn = !1), this.#fd.clear(), await this.#Zr.invoke_enable());
	}
	registrations() {
		return this.#fd;
	}
	hasRegistrationForURLs(e) {
		for (const t of this.#fd.values())
			if (e.filter((e) => e && e.startsWith(t.scopeURL)).length === e.length)
				return !0;
		return !1;
	}
	findVersion(e) {
		for (const t of this.registrations().values()) {
			const n = t.versions.get(e);
			if (n) return n;
		}
		return null;
	}
	deleteRegistration(e) {
		const t = this.#fd.get(e);
		if (t) {
			if (t.isRedundant())
				return (
					this.#fd.delete(e),
					void this.dispatchEventToListeners(va.RegistrationDeleted, t)
				);
			t.deleting = !0;
			for (const e of t.versions.values()) this.stopWorker(e.id);
			this.unregister(t.scopeURL);
		}
	}
	async updateRegistration(e) {
		const t = this.#fd.get(e);
		t && (await this.#Zr.invoke_updateRegistration({ scopeURL: t.scopeURL }));
	}
	async deliverPushMessage(t, n) {
		const r = this.#fd.get(t);
		if (!r) return;
		const s = e.ParsedURL.ParsedURL.extractOrigin(r.scopeURL);
		await this.#Zr.invoke_deliverPushMessage({
			origin: s,
			registrationId: t,
			data: n,
		});
	}
	async dispatchSyncEvent(t, n, r) {
		const s = this.#fd.get(t);
		if (!s) return;
		const i = e.ParsedURL.ParsedURL.extractOrigin(s.scopeURL);
		await this.#Zr.invoke_dispatchSyncEvent({
			origin: i,
			registrationId: t,
			tag: n,
			lastChance: r,
		});
	}
	async dispatchPeriodicSyncEvent(t, n) {
		const r = this.#fd.get(t);
		if (!r) return;
		const s = e.ParsedURL.ParsedURL.extractOrigin(r.scopeURL);
		await this.#Zr.invoke_dispatchPeriodicSyncEvent({
			origin: s,
			registrationId: t,
			tag: n,
		});
	}
	async unregister(e) {
		await this.#Zr.invoke_unregister({ scopeURL: e });
	}
	async startWorker(e) {
		await this.#Zr.invoke_startWorker({ scopeURL: e });
	}
	async skipWaiting(e) {
		await this.#Zr.invoke_skipWaiting({ scopeURL: e });
	}
	async stopWorker(e) {
		await this.#Zr.invoke_stopWorker({ versionId: e });
	}
	async inspectWorker(e) {
		await this.#Zr.invoke_inspectWorker({ versionId: e });
	}
	workerRegistrationUpdated(e) {
		for (const t of e) {
			let e = this.#fd.get(t.registrationId);
			e
				? (e.update(t),
					e.shouldBeRemoved()
						? (this.#fd.delete(e.id),
							this.dispatchEventToListeners(va.RegistrationDeleted, e))
						: this.dispatchEventToListeners(va.RegistrationUpdated, e))
				: ((e = new Ca(t)),
					this.#fd.set(t.registrationId, e),
					this.dispatchEventToListeners(va.RegistrationUpdated, e));
		}
	}
	workerVersionUpdated(e) {
		const t = new Set();
		for (const n of e) {
			const e = this.#fd.get(n.registrationId);
			e && (e.updateVersion(n), t.add(e));
		}
		for (const e of t)
			e.shouldBeRemoved()
				? (this.#fd.delete(e.id),
					this.dispatchEventToListeners(va.RegistrationDeleted, e))
				: this.dispatchEventToListeners(va.RegistrationUpdated, e);
	}
	workerErrorReported(e) {
		const t = this.#fd.get(e.registrationId);
		t &&
			(t.errors.push(e),
			this.dispatchEventToListeners(va.RegistrationErrorAdded, {
				registration: t,
				error: e,
			}));
	}
	forceUpdateOnReloadSetting() {
		return this.#bd;
	}
	forceUpdateSettingChanged() {
		const e = this.#bd.get();
		this.#Zr.invoke_setForceUpdateOnPageLoad({ forceUpdateOnPageLoad: e });
	}
}
var va;
!(function (e) {
	((e.RegistrationUpdated = "RegistrationUpdated"),
		(e.RegistrationErrorAdded = "RegistrationErrorAdded"),
		(e.RegistrationDeleted = "RegistrationDeleted"));
})(va || (va = {}));
class Ia {
	#pt;
	constructor(e) {
		this.#pt = e;
	}
	workerRegistrationUpdated({ registrations: e }) {
		this.#pt.workerRegistrationUpdated(e);
	}
	workerVersionUpdated({ versions: e }) {
		this.#pt.workerVersionUpdated(e);
	}
	workerErrorReported({ errorMessage: e }) {
		this.#pt.workerErrorReported(e);
	}
}
class ka {
	runningStatus;
	status;
	last_updated_timestamp;
	previousState;
	constructor(e, t, n, r) {
		((this.runningStatus = e),
			(this.status = t),
			(this.last_updated_timestamp = r),
			(this.previousState = n));
	}
}
class Sa {
	condition;
	source;
	id;
	constructor(e, t, n) {
		((this.condition = e), (this.source = t), (this.id = n));
	}
}
class wa {
	id;
	scriptURL;
	parsedURL;
	securityOrigin;
	scriptLastModified;
	scriptResponseTime;
	controlledClients;
	targetId;
	routerRules;
	currentState;
	registration;
	constructor(e, t) {
		((this.registration = e), this.update(t));
	}
	update(t) {
		((this.id = t.versionId), (this.scriptURL = t.scriptURL));
		const n = new e.ParsedURL.ParsedURL(t.scriptURL);
		((this.securityOrigin = n.securityOrigin()),
			(this.currentState = new ka(
				t.runningStatus,
				t.status,
				this.currentState,
				Date.now()
			)),
			(this.scriptLastModified = t.scriptLastModified),
			(this.scriptResponseTime = t.scriptResponseTime),
			t.controlledClients
				? (this.controlledClients = t.controlledClients.slice())
				: (this.controlledClients = []),
			(this.targetId = t.targetId || null),
			(this.routerRules = null),
			t.routerRules && (this.routerRules = this.parseJSONRules(t.routerRules)));
	}
	isStartable() {
		return (
			!this.registration.isDeleted && this.isActivated() && this.isStopped()
		);
	}
	isStoppedAndRedundant() {
		return "stopped" === this.runningStatus && "redundant" === this.status;
	}
	isStopped() {
		return "stopped" === this.runningStatus;
	}
	isStarting() {
		return "starting" === this.runningStatus;
	}
	isRunning() {
		return "running" === this.runningStatus;
	}
	isStopping() {
		return "stopping" === this.runningStatus;
	}
	isNew() {
		return "new" === this.status;
	}
	isInstalling() {
		return "installing" === this.status;
	}
	isInstalled() {
		return "installed" === this.status;
	}
	isActivating() {
		return "activating" === this.status;
	}
	isActivated() {
		return "activated" === this.status;
	}
	isRedundant() {
		return "redundant" === this.status;
	}
	get status() {
		return this.currentState.status;
	}
	get runningStatus() {
		return this.currentState.runningStatus;
	}
	mode() {
		return this.isNew() || this.isInstalling()
			? wa.Modes.Installing
			: this.isInstalled()
				? wa.Modes.Waiting
				: this.isActivating() || this.isActivated()
					? wa.Modes.Active
					: wa.Modes.Redundant;
	}
	parseJSONRules(e) {
		try {
			const t = JSON.parse(e);
			if (!Array.isArray(t))
				return (
					console.error(
						"Parse error: `routerRules` in ServiceWorkerVersion should be an array"
					),
					null
				);
			const n = [];
			for (const e of t) {
				const { condition: t, source: r, id: s } = e;
				if (void 0 === t || void 0 === r || void 0 === s)
					return (
						console.error(
							"Parse error: Missing some fields of `routerRules` in ServiceWorkerVersion"
						),
						null
					);
				n.push(new Sa(JSON.stringify(t), JSON.stringify(r), s));
			}
			return n;
		} catch (e) {
			return (
				console.error(
					"Parse error: Invalid `routerRules` in ServiceWorkerVersion"
				),
				null
			);
		}
	}
}
!(function (e) {
	let t;
	((e.RunningStatus = {
		running: ba(pa.running),
		starting: ba(pa.starting),
		stopped: ba(pa.stopped),
		stopping: ba(pa.stopping),
	}),
		(e.Status = {
			activated: ba(pa.activated),
			activating: ba(pa.activating),
			installed: ba(pa.installed),
			installing: ba(pa.installing),
			new: ba(pa.new),
			redundant: ba(pa.redundant),
		}),
		(function (e) {
			((e.Installing = "installing"),
				(e.Waiting = "waiting"),
				(e.Active = "active"),
				(e.Redundant = "redundant"));
		})((t = e.Modes || (e.Modes = {}))));
})(wa || (wa = {}));
class Ca {
	#yd;
	id;
	scopeURL;
	securityOrigin;
	isDeleted;
	versions;
	deleting;
	errors;
	constructor(e) {
		(this.update(e),
			(this.versions = new Map()),
			(this.deleting = !1),
			(this.errors = []));
	}
	update(t) {
		((this.#yd = Symbol("fingerprint")),
			(this.id = t.registrationId),
			(this.scopeURL = t.scopeURL));
		const n = new e.ParsedURL.ParsedURL(t.scopeURL);
		((this.securityOrigin = n.securityOrigin()),
			(this.isDeleted = t.isDeleted));
	}
	fingerprint() {
		return this.#yd;
	}
	versionsByMode() {
		const e = new Map();
		for (const t of this.versions.values()) e.set(t.mode(), t);
		return e;
	}
	updateVersion(e) {
		this.#yd = Symbol("fingerprint");
		let t = this.versions.get(e.versionId);
		return t
			? (t.update(e), t)
			: ((t = new wa(this, e)), this.versions.set(e.versionId, t), t);
	}
	isRedundant() {
		for (const e of this.versions.values())
			if (!e.isStoppedAndRedundant()) return !1;
		return !0;
	}
	shouldBeRemoved() {
		return this.isRedundant() && (!this.errors.length || this.deleting);
	}
	canBeRemoved() {
		return this.isDeleted || this.deleting;
	}
	clearErrors() {
		((this.#yd = Symbol("fingerprint")), (this.errors = []));
	}
}
class Ra {
	#tn;
	#vd;
	#Id;
	constructor(e, t) {
		((this.#tn = e),
			(this.#vd = t),
			(this.#Id = new Map()),
			t.addEventListener(
				va.RegistrationUpdated,
				this.registrationsUpdated,
				this
			),
			t.addEventListener(
				va.RegistrationDeleted,
				this.registrationsUpdated,
				this
			),
			$e
				.instance()
				.addModelListener(
					yn,
					In.ExecutionContextCreated,
					this.executionContextCreated,
					this
				));
	}
	registrationsUpdated() {
		this.#Id.clear();
		const e = this.#vd.registrations().values();
		for (const t of e)
			for (const e of t.versions.values())
				e.targetId && this.#Id.set(e.targetId, e);
		this.updateAllContextLabels();
	}
	executionContextCreated(e) {
		const t = e.data,
			n = this.serviceWorkerTargetId(t.target());
		n && this.updateContextLabel(t, this.#Id.get(n) || null);
	}
	serviceWorkerTargetId(e) {
		return e.parentTarget() !== this.#tn || e.type() !== je.ServiceWorker
			? null
			: e.id();
	}
	updateAllContextLabels() {
		for (const e of $e.instance().targets()) {
			const t = this.serviceWorkerTargetId(e);
			if (!t) continue;
			const n = this.#Id.get(t) || null,
				r = e.model(yn),
				s = r ? r.executionContexts() : [];
			for (const e of s) this.updateContextLabel(e, n);
		}
	}
	updateContextLabel(t, n) {
		if (!n) return void t.setLabel("");
		const r = e.ParsedURL.ParsedURL.fromString(t.origin),
			s = r ? r.lastPathComponentWithFragment() : t.name,
			i = wa.Status[n.status];
		t.setLabel(fa(pa.sSS, { PH1: s, PH2: n.id, PH3: i() }));
	}
}
c.register(ya, { capabilities: We.ServiceWorker, autostart: !0 });
var Ta = Object.freeze({
	__proto__: null,
	ServiceWorkerManager: ya,
	get Events() {
		return va;
	},
	ServiceWorkerVersionState: ka,
	ServiceWorkerRouterRule: Sa,
	get ServiceWorkerVersion() {
		return wa;
	},
	ServiceWorkerRegistration: Ca,
});
class xa extends c {
	#Zr;
	constructor(e) {
		(super(e),
			(this.#Zr = e.webAuthnAgent()),
			e.registerWebAuthnDispatcher(new Ma(this)));
	}
	setVirtualAuthEnvEnabled(e) {
		return e
			? this.#Zr.invoke_enable({ enableUI: !0 })
			: this.#Zr.invoke_disable();
	}
	async addAuthenticator(e) {
		return (await this.#Zr.invoke_addVirtualAuthenticator({ options: e }))
			.authenticatorId;
	}
	async removeAuthenticator(e) {
		await this.#Zr.invoke_removeVirtualAuthenticator({ authenticatorId: e });
	}
	async setAutomaticPresenceSimulation(e, t) {
		await this.#Zr.invoke_setAutomaticPresenceSimulation({
			authenticatorId: e,
			enabled: t,
		});
	}
	async getCredentials(e) {
		return (await this.#Zr.invoke_getCredentials({ authenticatorId: e }))
			.credentials;
	}
	async removeCredential(e, t) {
		await this.#Zr.invoke_removeCredential({
			authenticatorId: e,
			credentialId: t,
		});
	}
	credentialAdded(e) {
		this.dispatchEventToListeners("CredentialAdded", e);
	}
	credentialAsserted(e) {
		this.dispatchEventToListeners("CredentialAsserted", e);
	}
}
class Ma {
	#gr;
	constructor(e) {
		this.#gr = e;
	}
	credentialAdded(e) {
		this.#gr.credentialAdded(e);
	}
	credentialAsserted(e) {
		this.#gr.credentialAsserted(e);
	}
}
c.register(xa, { capabilities: We.WebAuthn, autostart: !1 });
var Pa = Object.freeze({ __proto__: null, WebAuthnModel: xa });
export {
	ls as AccessibilityModel,
	cs as AutofillModel,
	Ys as CPUProfileDataModel,
	Hs as CPUProfilerModel,
	li as CPUThrottlingManager,
	X as CSSContainerQuery,
	j as CSSFontFace,
	Y as CSSLayer,
	Ue as CSSMatchedStyles,
	ne as CSSMedia,
	O as CSSMetadata,
	pn as CSSModel,
	pe as CSSProperty,
	he as CSSPropertyParser,
	V as CSSQuery,
	Me as CSSRule,
	se as CSSScope,
	fe as CSSStyleDeclaration,
	Ve as CSSStyleSheetHeader,
	ye as CSSSupports,
	us as CategorizedBreakpoint,
	Ts as ChildTargetManager,
	Os as CompilerSourceMappingContentProvider,
	Is as Connections,
	Xs as ConsoleModel,
	F as ContentData,
	_ as Cookie,
	Nr as CookieModel,
	Br as CookieParser,
	bi as DOMDebuggerModel,
	vr as DOMModel,
	$n as DebuggerModel,
	ni as EmulationModel,
	Si as EventBreakpointsModel,
	wi as FrameAssociated,
	tt as FrameManager,
	bn as HeapProfilerModel,
	pt as IOModel,
	Ei as IsolateManager,
	Ni as IssuesModel,
	Di as LayerTreeBase,
	_s as LogModel,
	_r as MimeType,
	Nt as NetworkManager,
	ss as NetworkRequest,
	Jn as OverlayColorGenerator,
	cr as OverlayModel,
	Zn as OverlayPersistentHighlighter,
	Ui as PageLoad,
	zt as PageResourceLoader,
	zi as PaintProfiler,
	Vi as PerformanceMetricsModel,
	ea as PreloadingModel,
	N as ProfileTreeModel,
	ut as RemoteObject,
	Sr as Resource,
	Or as ResourceTreeModel,
	wn as RuntimeModel,
	h as SDKModel,
	na as ScreenCaptureModel,
	En as Script,
	Rr as SecurityOriginManager,
	sa as ServerSentEventProtocol,
	Gr as ServerTiming,
	ga as ServiceWorkerCacheModel,
	Ta as ServiceWorkerManager,
	Yt as SourceMap,
	tn as SourceMapManager,
	aa as StorageBucketsModel,
	Mr as StorageKeyManager,
	Ke as Target,
	Je as TargetManager,
	Pa as WebAuthnModel,
};
