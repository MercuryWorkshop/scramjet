import { basicTest } from "../../testcommon.ts";

// General JS sanity tests to ensure the rewriter doesn't break normal JS functionality
// llm autogenerated

export default [
	// ===========================================
	// EVAL HANDLING
	// ===========================================

	// Direct eval call
	basicTest({
		name: "sanity-eval-direct",
		js: `

        const result = eval("1 + 1");
        assertEqual(result, 2, "eval should work");

    `,
	}),

	// Indirect eval (should still work)
	basicTest({
		name: "sanity-eval-indirect",
		js: `

        const e = eval;
        const result = e("1 + 1");
        assertEqual(result, 2, "indirect eval should work");

    `,
	}),

	// ===========================================
	// DEBUGGER STATEMENTS
	// ===========================================

	// Debugger statement removal
	basicTest({
		name: "sanity-debugger-removed",
		js: `

        // This should not pause execution
        debugger;
        pass();

    `,
	}),

	// ===========================================
	// OBJECT SHORTHAND
	// ===========================================

	// Object shorthand syntax works
	basicTest({
		name: "sanity-object-shorthand",
		js: `

        const value = "test";
        const obj = { value };
        assertEqual(obj.value, "test", "object shorthand should work");

    `,
	}),

	// ===========================================
	// ASSIGNMENT EXPRESSIONS
	// ===========================================

	// Member expression assignment
	basicTest({
		name: "sanity-assignment-member",
		js: `

        const obj = { prop: "old" };
        obj.prop = "new";
        assertEqual(obj.prop, "new", "member assignment should work");

    `,
	}),

	// Computed member assignment
	basicTest({
		name: "sanity-assignment-computed",
		js: `

        const obj = { prop: "old" };
        obj["prop"] = "new";
        assertEqual(obj["prop"], "new", "computed assignment should work");

    `,
	}),

	// ===========================================
	// OBJECT DESTRUCTURING
	// ===========================================

	// Basic object destructuring
	basicTest({
		name: "sanity-destructure-object-basic",
		js: `

        const obj = { a: "test", b: "value" };
        const { a, b } = obj;
        assertEqual(a, "test", "destructured a should work");
        assertEqual(b, "value", "destructured b should work");

    `,
	}),

	// Object destructuring with rename
	basicTest({
		name: "sanity-destructure-object-rename",
		js: `

        const obj = { original: "test" };
        const { original: renamed } = obj;
        assertEqual(renamed, "test", "renamed destructure should work");

    `,
	}),

	// Nested object destructuring
	basicTest({
		name: "sanity-destructure-object-nested",
		js: `

        const obj = { nested: { value: "test" } };
        const { nested: { value } } = obj;
        assertEqual(value, "test", "nested destructure should work");

    `,
	}),

	// Object destructuring with rest
	basicTest({
		name: "sanity-destructure-object-rest",
		js: `

        const obj = { a: 1, b: 2, c: 3 };
        const { a, ...rest } = obj;
        assertEqual(a, 1, "destructured a should work");
        assertEqual(rest.b, 2, "rest should contain b");
        assertEqual(rest.c, 3, "rest should contain c");

    `,
	}),

	// Object destructuring with default value
	basicTest({
		name: "sanity-destructure-object-default",
		js: `

        const obj = {};
        const { missing = "default" } = obj;
        assertEqual(missing, "default", "default value should work");

    `,
	}),

	// Computed property in destructuring
	basicTest({
		name: "sanity-destructure-computed-property",
		js: `

        const key = "prop";
        const obj = { prop: "test" };
        const { [key]: value } = obj;
        assertEqual(value, "test", "computed destructuring should work");

    `,
	}),

	// ===========================================
	// ARRAY DESTRUCTURING
	// ===========================================

	// Basic array destructuring
	basicTest({
		name: "sanity-destructure-array-basic",
		js: `

        const arr = [1, 2, 3];
        const [a, b, c] = arr;
        assertEqual(a, 1, "first element should be 1");
        assertEqual(b, 2, "second element should be 2");
        assertEqual(c, 3, "third element should be 3");

    `,
	}),

	// Array destructuring with default
	basicTest({
		name: "sanity-destructure-array-default",
		js: `

        const arr = [1];
        const [a, b = 2] = arr;
        assertEqual(a, 1, "first element should be 1");
        assertEqual(b, 2, "default should be 2");

    `,
	}),

	// Nested array in object destructuring
	basicTest({
		name: "sanity-destructure-array-nested",
		js: `

        const obj = { arr: [1, 2] };
        const { arr: [a, b] } = obj;
        assertEqual(a, 1, "first element should be 1");
        assertEqual(b, 2, "second element should be 2");

    `,
	}),

	// ===========================================
	// FOR LOOPS
	// ===========================================

	// For loop with var declaration
	basicTest({
		name: "sanity-for-var-declaration",
		js: `

        let sum = 0;
        for (var i = 0; i < 3; i++) {
          sum += i;
        }
        assertEqual(sum, 3, "for loop should work");

    `,
	}),

	// For-in loop
	basicTest({
		name: "sanity-for-in",
		js: `

        const obj = { a: 1, b: 2 };
        const keys = [];
        for (const key in obj) {
          keys.push(key);
        }
        assert(keys.includes("a"), "should have key a");
        assert(keys.includes("b"), "should have key b");

    `,
	}),

	// For-of loop
	basicTest({
		name: "sanity-for-of",
		js: `

        const arr = [1, 2, 3];
        let sum = 0;
        for (const val of arr) {
          sum += val;
        }
        assertEqual(sum, 6, "for-of should work");

    `,
	}),

	// For-of with destructuring
	basicTest({
		name: "sanity-for-of-destructure",
		js: `

        const arr = [{ a: 1 }, { a: 2 }];
        let sum = 0;
        for (const { a } of arr) {
          sum += a;
        }
        assertEqual(sum, 3, "for-of destructure should work");

    `,
	}),

	// ===========================================
	// FUNCTION PARAMETERS
	// ===========================================

	// Function with destructured parameters
	basicTest({
		name: "sanity-function-param-destructure",
		js: `

        function test({ value }) {
          return value;
        }
        assertEqual(test({ value: "test" }), "test", "destructured param should work");

    `,
	}),

	// Function with nested destructured parameters
	basicTest({
		name: "sanity-function-param-nested",
		js: `

        function test({ nested: { value } }) {
          return value;
        }
        assertEqual(test({ nested: { value: "test" } }), "test", "nested destructured param should work");

    `,
	}),

	// Function with default parameter value
	basicTest({
		name: "sanity-function-param-default",
		js: `

        function test({ value = "default" } = {}) {
          return value;
        }
        assertEqual(test(), "default", "default param should work");
        assertEqual(test({ value: "test" }), "test", "provided param should work");

    `,
	}),

	// ===========================================
	// ARROW FUNCTIONS
	// ===========================================

	// Arrow function with destructured parameters
	basicTest({
		name: "sanity-arrow-param-destructure",
		js: `

        const test = ({ value }) => value;
        assertEqual(test({ value: "test" }), "test", "arrow destructured param should work");

    `,
	}),

	// Arrow function expression body
	basicTest({
		name: "sanity-arrow-expression",
		js: `

        const add = (a, b) => a + b;
        assertEqual(add(1, 2), 3, "arrow expression should work");

    `,
	}),

	// Arrow function with rest parameters
	basicTest({
		name: "sanity-arrow-rest-params",
		js: `

        const sum = (...args) => args.reduce((a, b) => a + b, 0);
        assertEqual(sum(1, 2, 3), 6, "arrow rest params should work");

    `,
	}),

	// ===========================================
	// TRY/CATCH
	// ===========================================

	// Try/catch basic
	basicTest({
		name: "sanity-try-catch-basic",
		js: `

        let caught = false;
        try {
          throw new Error("test");
        } catch (e) {
          caught = true;
        }
        assert(caught, "should have caught error");

    `,
	}),

	// Try/catch with destructured parameter
	basicTest({
		name: "sanity-try-catch-destructure",
		js: `

        let msg = "";
        try {
          throw { message: "test", code: 123 };
        } catch ({ message, code }) {
          msg = message + code;
        }
        assertEqual(msg, "test123", "destructured catch should work");

    `,
	}),

	// ===========================================
	// TYPEOF EXPRESSIONS
	// ===========================================

	// typeof with identifier (special case - should not throw for undefined)
	basicTest({
		name: "sanity-typeof-identifier",
		js: `

        const result = typeof undefinedVariable;
        assertEqual(result, "undefined", "typeof undefined should work");

    `,
	}),

	// typeof with expression
	basicTest({
		name: "sanity-typeof-expression",
		js: `

        const obj = { a: 1 };
        assertEqual(typeof obj.a, "number", "typeof expression should work");
        assertEqual(typeof (1 + 1), "number", "typeof grouped should work");

    `,
	}),

	// ===========================================
	// UPDATE EXPRESSIONS
	// ===========================================

	// Update expression on member
	basicTest({
		name: "sanity-update-member",
		js: `

        const obj = { count: 0 };
        obj.count++;
        assertEqual(obj.count, 1, "post-increment should work");
        ++obj.count;
        assertEqual(obj.count, 2, "pre-increment should work");

    `,
	}),

	// Update expression on variable
	basicTest({
		name: "sanity-update-variable",
		js: `

        let count = 0;
        count++;
        assertEqual(count, 1, "variable post-increment should work");
        --count;
        assertEqual(count, 0, "variable pre-decrement should work");

    `,
	}),

	// ===========================================
	// POSTMESSAGE
	// ===========================================

	// postMessage call
	basicTest({
		name: "sanity-postmessage",
		js: `

        // Test that postMessage structure is preserved
        const messages = [];
        const fakeTarget = {
          postMessage: (msg, origin) => {
            messages.push({ msg, origin });
          }
        };
        fakeTarget.postMessage("test", "*");
        assertEqual(messages.length, 1, "postMessage should be called");
        assertEqual(messages[0].msg, "test", "message should be correct");

    `,
	}),

	// Optional chaining with postMessage
	basicTest({
		name: "sanity-postmessage-optional",
		js: `

        const messages = [];
        const fakeTarget = {
          postMessage: (msg) => messages.push(msg)
        };
        fakeTarget?.postMessage("test");
        assertEqual(messages.length, 1, "optional postMessage should work");

        const nullTarget = null;
        nullTarget?.postMessage("test");
        assertEqual(messages.length, 1, "null optional should not call");

    `,
	}),

	// ===========================================
	// VARIABLE DECLARATIONS
	// ===========================================

	// var declaration
	basicTest({
		name: "sanity-var-declaration",
		js: `

        var myVar = "test";
        assertEqual(myVar, "test", "var declaration should work");

    `,
	}),

	// let declaration
	basicTest({
		name: "sanity-let-declaration",
		js: `

        let myLet = "test";
        assertEqual(myLet, "test", "let declaration should work");

    `,
	}),

	// const declaration
	basicTest({
		name: "sanity-const-declaration",
		js: `

        const myConst = "test";
        assertEqual(myConst, "test", "const declaration should work");

    `,
	}),

	// ===========================================
	// NEW EXPRESSIONS
	// ===========================================

	// New expression
	basicTest({
		name: "sanity-new-expression",
		js: `

        class TestClass {
          constructor(value) {
            this.value = value;
          }
        }
        const instance = new TestClass("test");
        assertEqual(instance.value, "test", "new expression should work");

    `,
	}),

	// ===========================================
	// OTHER JS FEATURES
	// ===========================================

	// Chained member access
	basicTest({
		name: "sanity-chained-member",
		js: `

        const obj = { nested: { value: "test" } };
        assertEqual(obj.nested.value, "test", "chained access should work");

    `,
	}),

	// Nested function with destructuring
	basicTest({
		name: "sanity-nested-function-destructure",
		js: `

        function outer({ a }) {
          return function inner({ b }) {
            return a + b;
          };
        }
        const inner = outer({ a: "x" });
        assertEqual(inner({ b: "y" }), "xy", "nested destructure should work");

    `,
	}),

	// Assignment in various contexts
	basicTest({
		name: "sanity-assignment-contexts",
		js: `

        // Regular assignment
        let a = 1;
        a = 2;
        assertEqual(a, 2, "regular assignment");

        // Compound assignment
        a += 1;
        assertEqual(a, 3, "compound assignment");

        // Object property assignment
        const obj = {};
        obj.prop = "test";
        assertEqual(obj.prop, "test", "property assignment");

        // Computed property assignment
        obj["computed"] = "value";
        assertEqual(obj.computed, "value", "computed assignment");

    `,
	}),

	// This expression
	basicTest({
		name: "sanity-this-expression",
		js: `

        const obj = {
          value: "test",
          getValue() {
            return this.value;
          }
        };
        assertEqual(obj.getValue(), "test", "this should work");

    `,
	}),

	// Spread in various contexts
	basicTest({
		name: "sanity-spread",
		js: `

        // Array spread
        const arr1 = [1, 2];
        const arr2 = [...arr1, 3];
        assertEqual(arr2.length, 3, "array spread should work");

        // Object spread
        const obj1 = { a: 1 };
        const obj2 = { ...obj1, b: 2 };
        assertEqual(obj2.a, 1, "object spread should preserve");
        assertEqual(obj2.b, 2, "object spread should add");

    `,
	}),

	// Async/await
	basicTest({
		name: "sanity-async-await",
		js: `

        const asyncFn = async () => {
          return await Promise.resolve("test");
        };
        const result = await asyncFn();
        assertEqual(result, "test", "async/await should work");

    `,
	}),

	// Template literals
	basicTest({
		name: "sanity-template-literals",
		js: `

        const value = "world";
        const result = \`hello \${value}\`;
        assertEqual(result, "hello world", "template literal should work");

    `,
	}),

	// Optional chaining
	basicTest({
		name: "sanity-optional-chaining",
		js: `

        const obj = { nested: { value: "test" } };
        assertEqual(obj?.nested?.value, "test", "optional chaining should work");
        assertEqual(obj?.missing?.value, undefined, "missing optional should be undefined");

    `,
	}),

	// Nullish coalescing
	basicTest({
		name: "sanity-nullish-coalescing",
		js: `

        const a = null ?? "default";
        assertEqual(a, "default", "nullish coalescing should work");
        const b = "value" ?? "default";
        assertEqual(b, "value", "non-null should keep value");

    `,
	}),
];
